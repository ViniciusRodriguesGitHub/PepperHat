<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pr√©dio Procedural Infinito v11: Ultimate Detail (Fixed)</title>
    <style>
        :root {
            --bg-color: #0d0d0d;
            --text-color: #e0e0e0;
            --accent-color: #00e5ff;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Consolas', monospace;
        }


        body.paused * {
            animation-play-state: paused !important;
        }
        body.paused #currentMission:hover {
            transform: none !important;
        }

        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            pointer-events: none;
            width: 250px;
            z-index: 100;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }

        h2 { margin: 0 0 10px 0; color: var(--accent-color); font-size: 1.1rem; text-transform: uppercase; letter-spacing: 1px; }
        p { margin: 5px 0; font-size: 0.85rem; color: #aaa; }
        
        .controls-hint {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #444;
            font-size: 0.8rem;
            color: #ddd;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
        }
    
        /* --- Info overlay (Setor + Objetos) --- */
        #infoOverlay {
            position: absolute;
            top: 18px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            z-index: 9999;
            pointer-events: none;
            font-family: 'Consolas', monospace;
            text-align: center;
        }
        #sectorBox, #objectBox {
            background: rgba(0, 0, 0, 0.70);
            border: 1px solid #333;
            border-radius: 10px;
            padding: 10px 14px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.4);
            display: inline-block;
            max-width: min(92vw, 720px);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        #sectorBox {
            font-size: 2.4rem; /* dobro do antigo 1.2rem */
            font-weight: 800;
            color: var(--accent-color);
            letter-spacing: 1px;
            text-transform: uppercase;
        }
        #objectBox {
            margin-top: 8px;
            font-size: 1.0rem;
            font-weight: 600;
            color: #ffd700;
        }

    
/* ===============================
   TOUCH UI (Mobile Buttons)
   =============================== */
html, body {
    touch-action: none; /* evita scroll/zoom durante o jogo */
    overscroll-behavior: none;
}
#worldCanvas {
    touch-action: none;
}

#touchUI {
    position: fixed;
    left: 0;
    bottom: 0;
    width: 100vw;
    height: 220px;
    z-index: 15000;
    pointer-events: none; /* s√≥ os bot√µes recebem clique */
}

.touchPadLeft, .touchPadRight {
    position: absolute;
    bottom: 18px;
    display: flex;
    gap: 12px;
    pointer-events: auto;
}

.touchPadLeft { left: 18px; }
.touchPadRight { right: 18px; }

.touchBtn {
    width: 74px;
    height: 74px;
    border-radius: 18px;
    border: 1px solid rgba(255,255,255,0.25);
    background: rgba(0,0,0,0.45);
    color: rgba(255,255,255,0.92);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    font-size: 12px;
    font-weight: 700;
    letter-spacing: 0.2px;
    display: grid;
    place-items: center;
    user-select: none;
    -webkit-user-select: none;
    -webkit-touch-callout: none;
    box-shadow: 0 10px 25px rgba(0,0,0,0.35);
    backdrop-filter: blur(6px);
}

.touchBtn:active {
    transform: scale(0.96);
    background: rgba(0,0,0,0.62);
}

.touchBtn.smallText {
    font-size: 11px;
    line-height: 1.05;
    padding: 8px;
    text-align: center;
}


/* ===============================
   MISSION UI (compact + always visible)
   =============================== */
#missionBottomDisplay {
    bottom: calc(env(safe-area-inset-bottom, 0px) + 10px) !important;
    left: 50% !important;
    transform: translateX(-50%) !important;
    width: auto !important;
    max-width: min(94vw, 560px) !important;
    padding: 0 !important;
}
#currentMission {
    font-size: clamp(0.9rem, 2.6vw, 1.05rem) !important;
    padding: 10px 14px !important;
    border-radius: 14px !important;
    border-width: 2px !important;
    max-width: min(94vw, 560px) !important;
    white-space: normal !important;
    line-height: 1.15 !important;
    word-break: break-word !important;
    animation: none !important;
}

</style>
</head>
<body>

    <!-- Menu Inicial -->
    <div id="mainMenu" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 10000; color: white; font-family: Arial, sans-serif; text-align: center;">
        <div style="background: rgba(0,0,0,0.8); padding: 40px; border-radius: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); max-width: 500px; width: 90%;">
            <h1 style="font-size: 3rem; margin-bottom: 10px; color: #ffd700; text-shadow: 2px 2px 4px #000;">üè¢ SkyTower Ultimate üè¢</h1>
            <p style="font-size: 1.2rem; margin-bottom: 40px; color: #e0e0e0;">Escolha seu modo de jogo:</p>

            <div style="display: flex; flex-direction: column; gap: 20px;">
                <button id="gameModeBtn" style="padding: 20px 30px; font-size: 1.4rem; background: linear-gradient(45deg, #ff6b6b, #ee5a52); color: white; border: none; border-radius: 10px; cursor: pointer; box-shadow: 0 6px 15px rgba(0,0,0,0.3); transition: all 0.3s ease; font-weight: bold;">
                    üéÆ MODO JOGO üéÆ<br>
                    <small style="font-size: 0.8rem; opacity: 0.9;">Sobreviva ao perseguidor e complete miss√µes</small>
                </button>

                <button id="exploreModeBtn" style="padding: 20px 30px; font-size: 1.4rem; background: linear-gradient(45deg, #4ecdc4, #44a08d); color: white; border: none; border-radius: 10px; cursor: pointer; box-shadow: 0 6px 15px rgba(0,0,0,0.3); transition: all 0.3s ease; font-weight: bold;">
                    üó∫Ô∏è MODO EXPLORAT√ìRIO üó∫Ô∏è<br>
                    <small style="font-size: 0.8rem; opacity: 0.9;">Explore livremente sem amea√ßas</small>
                </button>
            </div>

            <!-- Ferramenta de teste de miss√£o (lista e sele√ß√£o direta) -->
            <div id="missionTestContainer"></div>

            <div style="margin-top: 30px; font-size: 0.9rem; color: #ccc; border-top: 1px solid #555; padding-top: 20px;">
                <p><strong>üéØ Objetivo do Modo Jogo:</strong> Ligue um fliperama e leve uma TV para o quarto</p>
                <p><strong>üïπÔ∏è Controles:</strong> ‚Üê‚Üí Andar | ‚¨ÜÔ∏è‚¨áÔ∏è Elevador/Escada | Z Interagir | X Pegar/Soltar</p>
            </div>
        </div>
    </div>

    <div class="hud" style="display: none;">
        <h2>SkyTower Ultimate</h2>
        <p>Andar Atual: <span id="floorDisplay" style="color: var(--accent-color); font-size: 1.2rem;">0</span></p>
        <p>Setores: <span id="roomDisplay" style="font-size: 1.2rem; font-weight: bold;">...</span></p>
        <p>Objetos: <span id="objCount">0</span> | Pontua√ß√£o: <span id="scoreDisplay" style="color: #ffd700; font-weight: bold;">0</span></p>
        <div class="controls-hint">
            ‚¨ÖÔ∏è ‚û°Ô∏è Andar<br>
            ‚¨ÜÔ∏è ‚¨áÔ∏è Elevador/Escada<br>
            <span style="font-size: 0.8rem; color: #aaa;">W: Pular | ‚Üê‚Üí Duplo-clique: Correr | Z: Interagir | X: Pegar/Soltar | Espa√ßo: Dash</span><br>
            <span style="font-size: 0.75rem; color: #888;">Pegue e carregue objetos!</span><br>
            <div style="margin-top: 5px;">
                <span style="color: #ff0000; font-weight: bold;">VIDAS:</span>
                <span id="healthBar" style="display: inline-block; margin-left: 10px;">
                    ${'‚ù§Ô∏è'.repeat(playerLives)}${'üíî'.repeat(3-playerLives)}
                </span>
                <span id="enemyDelay" style="display: inline-block; margin-left: 20px; color: #ff4444; font-weight: bold;">
                    Delay: ${(enemy.delayTime / 1000).toFixed(4).replace('.', ',')}s
                </span>
            </div>
            <div id="protectionIndicator" style="display: none; margin-top: 5px; color: #4CAF50; font-weight: bold; font-size: 0.9rem;">
                üõ°Ô∏è Protegido - Use ‚Üê ‚Üí para iniciar o jogo!
            </div>
            <div style="margin-top: 10px; font-size: 0.9rem;">
                <div id="missionsSection" style="display: none;">
                    <div style="color: #ffd700; font-weight: bold; margin-bottom: 5px;">
                        MISS√ÉO ATUAL: <span id="missionProgress" style="color: #fff;">0/10</span>
                    </div>
                </div>
                <div id="exploreModeIndicator" style="display: none; color: #4ecdc4; font-weight: bold;">
                    üó∫Ô∏è MODO EXPLORAT√ìRIO - Explore livremente!
                </div>
                <div id="pauseIndicator" style="display: none; color: #ffcc00; font-weight: bold; font-size: 1.1rem;">
                    ‚è∏Ô∏è JOGO PAUSADO - Pressione ENTER ou START para continuar
                </div>
            </div>

            <!-- Miss√£o atual na parte inferior central -->
            <div id="missionBottomDisplay" style="
                position: fixed;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                display: block;
                z-index: 1000;
                pointer-events: none;
                text-align: center;
            ">
                <div id="currentMission" style="
                    font-family: 'Comic Sans MS', 'Chalkduster', cursive;
                    font-size: 1.5rem;
                    font-weight: bold;
                    color: #ff6b6b;
                    text-shadow:
                        -2px -2px 0px #04413d,
                        2px -2px 0px #817331,
                        -2px 2px 0px #169e6c,
                        2px 2px 0px #65540f;
                    background: rgba(0, 0, 0, 0.8);
                    padding: 15px 25px;
                    border-radius: 20px;
                    border: 3px solid #4e4202;
                    box-shadow: 0 4px 15px rgba(0,0,0,0.5);
                    animation: missionPulse 2s ease-in-out infinite;
                ">
                    üéØ Carregando miss√£o...
                </div>
            </div>

            <style>
                @keyframes missionPulse {
                    0%, 100% { transform: scale(1); }
                    50% { transform: scale(1.05); }
                }

                #currentMission {
                    transition: all 0.3s ease;
                }

                #currentMission:hover {
                    transform: scale(1.1);
                }
            
        /* --- Info overlay (Setor + Objetos) --- */
        #infoOverlay {
            position: absolute;
            top: 18px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            z-index: 9999;
            pointer-events: none;
            font-family: 'Consolas', monospace;
            text-align: center;
        }
        #sectorBox, #objectBox {
            background: rgba(0, 0, 0, 0.70);
            border: 1px solid #333;
            border-radius: 10px;
            padding: 10px 14px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.4);
            display: inline-block;
            max-width: min(92vw, 720px);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        #sectorBox {
            font-size: 2.4rem; /* dobro do antigo 1.2rem */
            font-weight: 800;
            color: var(--accent-color);
            letter-spacing: 1px;
            text-transform: uppercase;
        }
        #objectBox {
            margin-top: 8px;
            font-size: 1.0rem;
            font-weight: 600;
            color: #ffd700;
        }

    </style>
        </div>
    </div>


    <!-- Overlay minimal (Setor e Objetos) -->
    <div id="infoOverlay">
        <div id="sectorBox">...</div>
        <div id="objectBox" style="display:none;">...</div>
    </div>

    <canvas id="worldCanvas"></canvas>

    <script>
        const canvas = document.getElementById('worldCanvas');
        const ctx = canvas.getContext('2d');

        // --- Canvas DPR (Retina) ---
        // viewW/viewH = tamanho l√≥gico em CSS pixels (o que seu jogo usa para coordenadas)
        // CW()/height = buffer real em device pixels (para ficar n√≠tido em telas de alta densidade)
        let viewW = 0;
        let viewH = 0;
        let DPR = 1;

        const CW = () => viewW; // Canvas Width (CSS px)
        const CH = () => viewH; // Canvas Height (CSS px)



        // --- Configura√ß√µes do Pr√©dio ---
        const FLOOR_HEIGHT = 140; 
        const BUILDING_WIDTH = 900;
        const ELEVATOR_X = -400; 
        const STAIRS_X = 400;    
        const ELEVATOR_WIDTH = 60;
        const STAIRS_WIDTH = 60;

        // --- Nomes para Tooltips ---
        const ITEM_NAMES = {
            table: 'Mesa de Jantar', lab_table: 'Bancada Lab', chair: 'Cadeira', bed: 'Cama King', sofa: 'Sof√° Confort',
            fridge: 'Geladeira Duplex', stove: 'Fog√£o Industrial', bookshelf: 'Biblioteca', desk: 'Escrivaninha',
            tv: 'Smart TV', plant: 'Planta Decorativa', treadmill: 'Esteira Pro', weights: 'Halteres',
            computer: 'Workstation', server: 'Rack Servidor', coffee_machine: 'Expresso',
            mag_rack: 'Revisteiro', water_cooler: 'Bebedouro', info_kiosk: 'Info Point',
            waiting_bench: 'Banco Espera', arcade: 'Arcade Retro', floor_lamp: 'Lumin√°ria Piso',
            coffee_table: 'Mesa de Centro', painting: 'Arte Abstrata', speaker: 'Home Theater',
            microwave: 'Microondas', trash_can: 'Lixeira Inox', sink: 'Pia Cozinha',
            vending: 'Snack Machine', stool: 'Banqueta', nightstand: 'Criado-mudo',
            wardrobe: 'Guarda-Roupa', mirror: 'Espelho Oval', desk_lamp: 'Lumin√°ria Mesa',
            bunk_bed: 'Beliche Militar', yoga_mat: 'Tapete Yoga', punching_bag: 'Saco de Pancada',
            locker: 'Arm√°rio Vesti√°rio', bench_press: 'Supino', dumbbell_rack: 'Rack Pesos',
            filing_cabinet: 'Arquivo A√ßo', whiteboard: 'Quadro Branco', printer: 'LaserJet',
            meeting_table: 'Mesa Reuni√£o', coat_rack: 'Mancebo', garden_bench: 'Banco Jardim',
            fountain: 'Fonte D\'√°gua', bush: 'Arbusto', statue: 'Est√°tua Moderna', street_lamp: 'Poste Luz',
            microscope: 'Microsc√≥pio', chem_rack: 'Estante Qu√≠mica', safety_shower: 'Chuveiro Emerg√™ncia',
            robo_arm: 'Bra√ßo Rob√≥tico', equations_board: 'Lousa F√≠sica', box_pile: 'Caixas',
            barrel: 'Barril', crate: 'Engradado', pallet_jack: 'Paleteira', tool_cabinet: 'Carrinho Ferramentas',
            tv_stand: 'Rack TV 3D',
            dumbbells: 'Halteres Pequenos', medicine_ball: 'Bola Medicinal', resistance_bands: 'Faixas El√°sticas',
            foam_roller: 'Rolo Espuma', kettlebell: 'Peso Russo', pull_up_bar: 'Barra Fixa',
            ankle_weights: 'Pesos Tornozelo', hand_grips: 'Aperto M√£o', massage_ball: 'Bola Massagem',
            protein_shaker: 'Shaker Prote√≠na',
            swing: 'Balan√ßo', slide: 'Escorregador', seesaw: 'Gangorra', dollhouse: 'Casa Boneca',
            sandbox: 'Caixote Areia', jungle_gym: 'Trepa-Trepa', spring_rider: 'Cavalinho',
            ball_pit: 'Piscina Bolas', teddy_bear: 'Ursinho Pel√∫cia', tire_swing: 'Pneu Balan√ßo',
            test_cube: 'Cubo Teste', toilet: 'Vaso Sanit√°rio', shower: 'Chuveiro', bathtub: 'Banheira',
            medicine_cabinet: 'Arm√°rio Rem√©dios', laundry_basket: 'Cesto Roupa', towel_rack: 'Toalheiro',
            piano: 'Piano', violin: 'Violino', guitar: 'Guitarra', drum_set: 'Bateria',
            saxophone: 'Saxofone', trumpet: 'Trompete', acoustic_guitar: 'Viol√£o', keyboard: 'Teclado',
            bar_counter: 'Balc√£o Bar', bar_stools: 'Banquetas', beer_taps: 'Torneiras Chope',
            bottles_rack: 'Prateleira Garrafas', jukebox: 'Jukebox', pool_table: 'Mesa Sinuca',
            dart_board: 'Alvo Dardos', neon_signs: 'Letreiros Neon',
            clothing_rack: 'Cabideiro Roupas', cash_register: 'Caixa Registradora', mannequins: 'Manequins',
            fitting_rooms: 'Provadores', shoe_rack: 'Prateleira Sapatos', mirror_wall: 'Espelho Parede',
            display_window: 'Vitrine', hangers_rack: 'Suporte Cabides',
            classical_statue: 'Est√°tua Cl√°ssica', ancient_painting: 'Quadro Antigo', artifact_display: 'Vitrine Artefatos',
            marble_bust: 'Busto de M√°rmore', abstract_sculpture: 'Escultura Abstrata', art_installation: 'Instala√ß√£o Art√≠stica',
            decorative_pedestal: 'Pedestal Decorativo', exhibit_light: 'Lumin√°ria Exposi√ß√£o'
        };

        // --- Cores e Temas ---
        const ROOM_THEMES = {
            reception: { color: '#263238', label: 'RECEP√á√ÉO', wall: '#455a64', signColor: '#00bcd4' },
            living:    { color: '#3e2723', label: 'SALA', wall: '#5d4037', signColor: '#ffa726' },
            kitchen:   { color: '#263238', label: 'COPA', wall: '#546e7a', signColor: '#f44336' },
            bedroom:   { color: '#1a237e', label: 'QUARTO', wall: '#283593', signColor: '#7e57c2' },
            gym:       { color: '#212121', label: 'ACADEMIA', wall: '#424242', signColor: '#ff5722' },
            office:    { color: '#004d40', label: 'ESCRIT√ìRIO', wall: '#00695c', signColor: '#26a69a' },
            garden:    { color: '#1b5e20', label: 'JARDIM', wall: '#1b5e20', signColor: '#66bb6a' },
            lab:       { color: '#01579b', label: 'LABORAT√ìRIO', wall: '#0277bd', signColor: '#29b6f6' },
            bathroom:  { color: '#e1f5fe', label: 'BANHEIRO', wall: '#b3e5fc', signColor: '#00bcd4' },
            playground: { color: '#fff9c4', label: 'PARQUINHO', wall: '#ffeb3b', signColor: '#ff5722' },
            music_room:{ color: '#fce4ec', label: 'SALA M√öSICA', wall: '#f8bbd9', signColor: '#e91e63' },
            bar:       { color: '#2d1b3d', label: 'BAR', wall: '#4a2c5a', signColor: '#ff5722' },
            clothing_store: { color: '#f5f5f5', label: 'LOJA ROUPAS', wall: '#e0e0e0', signColor: '#9c27b0' },
            museum:    { color: '#ffffff', label: 'MUSEU', wall: '#25f5f5', signColor: '#607d8b' },
            storage:   { color: '#3e2723', label: 'DEP√ìSITO', wall: '#795548', signColor: '#a1887f' }
        };
        const THEME_KEYS = Object.keys(ROOM_THEMES);

        // --- Assets e Regras de Stacking ---
        const topCounts = {}; // Contador global para balanceamento de itens de topo
        const baseCounts = {}; // Contador global para balanceamento de itens base

        // Pr√©-calcular quantos temas cada item √© eleg√≠vel
        const eligibleThemesCount = {};
        const mapTemplate = {
            reception: ['desk', 'chair', 'plant', 'sofa', 'water_cooler', 'info_kiosk', 'waiting_bench'],
            living: ['plant', 'tv_stand', 'sofa', 'bookshelf', 'arcade', 'floor_lamp', 'coffee_table', 'painting', 'speaker'],
            bedroom: ['bed', 'desk', 'chair', 'nightstand', 'wardrobe', 'mirror', 'bunk_bed'],
            kitchen: ['fridge', 'stove', 'table', 'chair', 'trash_can', 'sink', 'vending', 'stool'],
            gym: ['treadmill', 'weights', 'punching_bag', 'locker', 'bench_press', 'water_cooler', 'dumbbells', 'medicine_ball', 'resistance_bands', 'foam_roller', 'kettlebell', 'pull_up_bar', 'ankle_weights', 'hand_grips', 'massage_ball', 'protein_shaker'],
            lab: ['server', 'lab_table', 'chem_rack', 'safety_shower', 'robo_arm', 'equations_board'],
            office: ['desk', 'chair', 'filing_cabinet', 'whiteboard', 'meeting_table', 'coat_rack', 'water_cooler', 'bookshelf'],
            garden: ['plant', 'garden_bench', 'fountain', 'bush', 'statue', 'street_lamp'],
            bathroom: ['toilet', 'sink', 'shower', 'bathtub', 'medicine_cabinet', 'laundry_basket', 'towel_rack'],
            playground: ['swing', 'slide', 'seesaw', 'dollhouse', 'sandbox', 'jungle_gym', 'spring_rider', 'ball_pit', 'teddy_bear', 'tire_swing'],
            music_room: ['piano', 'violin', 'guitar', 'drum_set', 'saxophone', 'trumpet', 'acoustic_guitar', 'keyboard', 'desk', 'meeting_table'],
            bar: ['bar_counter', 'stool', 'beer_taps', 'bottles_rack', 'jukebox', 'pool_table', 'dart_board', 'neon_signs'],
            clothing_store: ['desk', 'clothing_rack', 'cash_register', 'mannequins', 'fitting_rooms', 'shoe_rack', 'mirror_wall', 'display_window', 'hangers_rack'],
            museum: ['classical_statue', 'ancient_painting', 'artifact_display', 'marble_bust', 'abstract_sculpture', 'art_installation', 'decorative_pedestal', 'exhibit_light'],
            storage: ['box_pile', 'barrel', 'crate', 'pallet_jack', 'tool_cabinet', 'bookshelf']
        };

        // Inicializar eligibleThemesCount
        Object.keys(mapTemplate).forEach(theme => {
            mapTemplate[theme].forEach(item => {
                eligibleThemesCount[item] = (eligibleThemesCount[item] || 0) + 1;
            });
        });

        // Pr√©-calcular elegibilidade de tops
        const eligibleTopsCount = {};
        const tabletopsTemplate = {
            reception: ['computer', 'coffee_machine', 'desk_lamp'],
            living: ['coffee_machine', 'tv'],
            bedroom: ['desk_lamp'],
            kitchen: ['microwave', 'coffee_machine'],
            lab: ['microscope', 'computer'],
            office: ['computer', 'printer', 'desk_lamp'],
            music_room: ['keyboard', 'desk_lamp'],
            storage: ['box_pile'],
            gym: ['water_cooler']
        };

        Object.keys(tabletopsTemplate).forEach(theme => {
            tabletopsTemplate[theme].forEach(top => {
                eligibleTopsCount[top] = (eligibleTopsCount[top] || 0) + 1;
            });
        });

        function weightedPick(types) {
            let total = 0;
            const w = types.map(t => {
                // Peso = (1 / (contagem + 1)) * (1 / temas eleg√≠veis)
                // Tops raros por elegibilidade ganham boost
                const count = topCounts[t] || 0;
                const eligible = eligibleTopsCount[t] || 1;
                const weight = (1 / (count + 1)) * (1 / eligible);
                total += weight;
                return weight;
            });
            let r = Math.random() * total;
            for (let i = 0; i < types.length; i++) {
                r -= w[i];
                if (r <= 0) return types[i];
            }
            return types[types.length - 1];
        }

        // Sele√ß√£o ponderada por raridade para itens base
        function weightedPickBase(types) {
            let total = 0;
            const w = types.map(type => {
                // Peso = (1 / (contagem + 1)) * (1 / temas eleg√≠veis)
                // Itens raros por elegibilidade ganham boost
                const count = baseCounts[type] || 0;
                const eligible = eligibleThemesCount[type] || 1;
                const weight = (1 / (count + 1)) * (1 / eligible);
                total += weight;
                return weight;
            });
            let r = Math.random() * total;
            for (let i = 0; i < types.length; i++) {
                r -= w[i];
                if (r <= 0) return types[i];
            }
            return types[types.length - 1];
        }

        const SPECS = {
            // Superf√≠cies
            table: { w: 44, h: 28, col: '#8d6e63', surfaceHeight: 28 },
            lab_table: { w: 48, h: 28, col: '#cfd8dc', surfaceHeight: 28 },
            desk: { w: 46, h: 28, col: '#3e2723', surfaceHeight: 28 },
            coffee_table: { w: 30, h: 14, col: '#5d0000', surfaceHeight: 14 },
            nightstand: { w: 18, h: 22, col: '#5d4037', surfaceHeight: 22 },
            meeting_table: { w: 60, h: 28, col: '#3e2723', surfaceHeight: 28 },
            tool_cabinet: { w: 30, h: 36, col: '#d32f2f', surfaceHeight: 36 },
            filing_cabinet: { w: 22, h: 45, col: '#90a4ae', surfaceHeight: 45 },
            crate: { w: 24, h: 24, col: '#8d6e63', surfaceHeight: 24 },
            tv_stand: { w: 40, h: 20, col: '#424242', surfaceHeight: 20 },

            // Itens de Ch√£o
            chair: { w: 16, h: 34, col: '#a1887f' },
            bed: { w: 54, h: 26, col: '#3949ab', wood: '#5d4037' },
            sofa: { w: 56, h: 28, col: '#78909c' }, 
            fridge: { w: 32, h: 62, col: '#b0bec5' },
            stove: { w: 28, h: 32, col: '#eceff1' },
            bookshelf: { w: 36, h: 70, col: '#4e342e' },
            plant: { w: 24, h: 40, col: '#2e7d32' },
            treadmill: { w: 50, h: 30, col: '#616161' },
            server: { w: 24, h: 65, col: '#1a237e' },
            mag_rack: { w: 16, h: 40, col: '#fff' },
            water_cooler: { w: 18, h: 48, col: '#e1f5fe' },
            info_kiosk: { w: 20, h: 50, col: '#00bcd4' },
            waiting_bench: { w: 40, h: 18, col: '#78909c' },
            arcade: { w: 28, h: 60, col: '#e91e63' },
            floor_lamp: { w: 16, h: 60, col: '#fbc02d' },
            painting: { w: 24, h: 32, col: '#fff', wall: true },
            speaker: { w: 18, h: 44, col: '#212121' },
            trash_can: { w: 16, h: 24, col: '#9e9e9e' },
            sink: { w: 30, h: 32, col: '#cfd8dc' },
            vending: { w: 36, h: 65, col: '#b71c1c' },
            wardrobe: { w: 40, h: 65, col: '#4e342e' },
            mirror: { w: 20, h: 50, col: '#e1f5fe' },
            bunk_bed: { w: 54, h: 60, col: '#3949ab', wood: '#5d4037' },
            punching_bag: { w: 16, h: 55, col: '#b71c1c' },
            locker: { w: 24, h: 60, col: '#9e9e9e' },
            bench_press: { w: 40, h: 20, col: '#757575' },
            whiteboard: { w: 40, h: 30, col: '#f5f5f5', wall: true },
            coat_rack: { w: 14, h: 60, col: '#5d4037' },
            garden_bench: { w: 44, h: 22, col: '#8d6e63' },
            fountain: { w: 34, h: 34, col: '#cfd8dc' },
            street_lamp: { w: 12, h: 70, col: '#424242' },
            chem_rack: { w: 24, h: 50, col: '#78909c' },
            safety_shower: { w: 20, h: 65, col: '#fbc02d' },
            robo_arm: { w: 24, h: 40, col: '#ff9800' },
            equations_board: { w: 40, h: 30, col: '#2e7d32', wall: true },
            barrel: { w: 20, h: 30, col: '#5d4037' },
            pallet_jack: { w: 36, h: 20, col: '#fdd835' },
            stool: { w: 12, h: 20, col: '#8d6e63' },
            bush: { w: 24, h: 20, col: '#4caf50' },
            statue: { w: 20, h: 40, col: '#bdbdbd' },
            toilet: { w: 18, h: 32, col: '#ffffff' },
            shower: { w: 32, h: 60, col: '#e0e0e0' },
            bathtub: { w: 48, h: 24, col: '#ffffff' },
            medicine_cabinet: { w: 20, h: 24, col: '#f8f8f8', wall: true },
            laundry_basket: { w: 16, h: 20, col: '#e8e8e8' },
            towel_rack: { w: 20, h: 4, col: '#c0c0c0', wall: true },

            // Gym Items
            dumbbells: { w: 12, h: 8, col: '#424242' },
            medicine_ball: { w: 10, h: 10, col: '#ff5722' },
            resistance_bands: { w: 14, h: 6, col: '#4caf50' },
            foam_roller: { w: 18, h: 8, col: '#2196f3' },
            kettlebell: { w: 8, h: 12, col: '#ff9800' },
            pull_up_bar: { w: 20, h: 4, col: '#757575', wall: true },
            ankle_weights: { w: 12, h: 6, col: '#9c27b0' },
            hand_grips: { w: 6, h: 8, col: '#3f51b5' },
            massage_ball: { w: 6, h: 6, col: '#e91e63' },
            protein_shaker: { w: 6, h: 12, col: '#00bcd4' },

            // Playground Items
            swing: { w: 20, h: 40, col: '#ff5722' },
            slide: { w: 30, h: 30, col: '#2196f3' },
            seesaw: { w: 30, h: 12, col: '#4caf50' },
            dollhouse: { w: 32, h: 28, col: '#ff69b4' },
            sandbox: { w: 24, h: 10, col: '#795548' },
            jungle_gym: { w: 30, h: 30, col: '#f44336' },
            spring_rider: { w: 12, h: 16, col: '#9c27b0' },
            ball_pit: { w: 24, h: 16, col: '#ff5722' },
            teddy_bear: { w: 16, h: 24, col: '#8b4513' },
            tire_swing: { w: 10, h: 30, col: '#4caf50' },
            test_cube: { w: 8, h: 8, col: '#ff0000' },
            piano: { w: 32, h: 24, col: '#2c1810' },
            violin: { w: 6, h: 20, col: '#8d6e63' },
            guitar: { w: 14, h: 24, col: '#1a1a1a' },
            drum_set: { w: 28, h: 20, col: '#212121' },
            saxophone: { w: 8, h: 18, col: '#ffd700' },
            trumpet: { w: 6, h: 16, col: '#ffd700' },
            acoustic_guitar: { w: 12, h: 22, col: '#8d6e63' },
            keyboard: { w: 24, h: 12, col: '#212121' },
            bar_counter: { w: 36, h: 12, col: '#8d6e63' },
            beer_taps: { w: 14, h: 26, col: '#c0c0c0' },
            bottles_rack: { w: 20, h: 16, col: '#8d6e63' },
            jukebox: { w: 20, h: 36, col: '#8B4513' }, // Estilo anos 50 - madeira marrom grande
            pool_table: { w: 28, h: 16, col: '#2e7d32' },
            dart_board: { w: 22, h: 22, col: '#212121', wall: true },
            neon_signs: { w: 34, h: 14, col: '#ff5722', wall: true },
            clothing_rack: { w: 16, h: 20, col: '#8d6e63' },
            cash_register: { w: 12, h: 10, col: '#424242', surface: true },
            mannequins: { w: 6, h: 24, col: '#f5f5f5' },
            fitting_rooms: { w: 20, h: 24, col: '#e0e0e0' },
            shoe_rack: { w: 18, h: 12, col: '#8d6e63' },
            mirror_wall: { w: 24, h: 16, col: '#e8f4f8', wall: true },
            display_window: { w: 28, h: 22, col: '#ffffff' },
            hangers_rack: { w: 14, h: 18, col: '#c0c0c0' },

            // Museum Items
            classical_statue: { w: 16, h: 32, col: '#f5f5f5' },
            ancient_painting: { w: 24, h: 16, col: '#8d6e63', wall: true },
            artifact_display: { w: 20, h: 24, col: '#e0e0e0' },
            marble_bust: { w: 12, h: 20, col: '#fafafa' },
            abstract_sculpture: { w: 18, h: 26, col: '#9c27b0' },
            art_installation: { w: 22, h: 18, col: '#ff5722' },
            decorative_pedestal: { w: 14, h: 8, col: '#795548', surfaceHeight: 8 },
            exhibit_light: { w: 8, h: 6, col: '#424242', wall: true },

            // Itens de Cima
            tv: { w: 32, h: 20, col: '#111', stackable: true },
            computer: { w: 16, h: 14, col: '#eee', stackable: true },
            microscope: { w: 14, h: 20, col: '#fff', stackable: true },
            coffee_machine: { w: 12, h: 16, col: '#3e2723', stackable: true },
            desk_lamp: { w: 10, h: 14, col: '#fdd835', stackable: true },
            microwave: { w: 20, h: 14, col: '#eeeeee', stackable: true },
            printer: { w: 18, h: 12, col: '#e0e0e0', stackable: true },
            box_pile: { w: 24, h: 22, col: '#d7ccc8', stackable: true }
        };

        const PLAYER = { w: 16, h: 32, col: '#00e5ff', head: '#e0f7fa', speed: 5 };

        // --- Estado do Jogo ---
        let camera = { x: 0, y: 0 };
        let player = {
            x: 0,
            y: 0,
            floor: 0,
            state: 'idle',
            targetY: 0,
            // F√≠sica de pulo
            velocityY: 0,
            isJumping: false,
            isOnGround: true,
            jumpPower: 6,
            gravity: 0.4,
            // Sistema de acelera√ß√£o
            speed: 2.5,
            maxSpeed: 5,
            acceleration: 0.3,
            deceleration: 0.2,
            currentSpeed: 0,
            isRunning: false,
            jumpHorizontalSpeed: 0, // Velocidade horizontal armazenada para pulo
            // Sistema de carregar objetos
            isCarrying: false,
            carriedItem: null, // Item sendo carregado
            // Detec√ß√£o de corrida (dois cliques)
            lastKeyTime: { left: 0, right: 0 },
            keyClickCount: { left: 0, right: 0 },
            // Sistema de Dash
            isDashing: false,
            dashTime: 0,
            dashCooldown: 0
        };
        let floors = new Map(); 
        let usedThemesPerFloor = new Map();
        const keys = { left: false, right: false, up: false, down: false };

        // ---------------------------
        // GAMEPAD (Xbox etc.)
        // ---------------------------
        let gamepadIndex = null;

        const gamepadState = {
            prevButtons: [],     // guarda estados anteriores p/ edge-trigger
            axisDeadzone: 0.25,  // ajuste se necess√°rio

            // Dire√ß√µes (mantidas separadas do teclado; setadas POR FRAME)
            keys: { left: false, right: false, up: false, down: false },

            // Estados anteriores p/ edge-trigger
            prevUp: false,
            prevDown: false,
            prevLeft: false,
            prevRight: false,
        };

        // tenta achar um gamepad v√°lido
        function findGamepad() {
            const pads = navigator.getGamepads ? navigator.getGamepads() : [];
            for (let i = 0; i < pads.length; i++) {
                if (pads[i]) return i;
            }
            return null;
        }

        // Detecta transi√ß√£o "solto -> pressionado"
        function buttonPressedNow(pad, btnIndex) {
            const pressed = !!pad.buttons[btnIndex]?.pressed;
            const prev = !!gamepadState.prevButtons[btnIndex];
            // edge: s√≥ quando acabou de pressionar
            return pressed && !prev;
        }

        function updatePrevButtons(pad) {
            gamepadState.prevButtons = pad.buttons.map(b => !!b.pressed);
        }

        // Helper universal para ler D-pad (bot√µes + axes[6]/axes[7])
        function readDpad(pad) {
            // Padr√£o "standard" (Xbox/PS no Chrome geralmente)
            const bUp = !!pad.buttons?.[12]?.pressed;
            const bDown = !!pad.buttons?.[13]?.pressed;
            const bLeft = !!pad.buttons?.[14]?.pressed;
            const bRight = !!pad.buttons?.[15]?.pressed;

            // Fallback comum em controles/adaptadores: axes[6] e axes[7] viram o D-pad
            const ax6 = pad.axes?.[6] ?? 0;
            const ax7 = pad.axes?.[7] ?? 0;

            const aLeft = ax6 < -0.5;
            const aRight = ax6 > 0.5;
            const aUp = ax7 < -0.5;
            const aDown = ax7 > 0.5;

            return {
                up: bUp || aUp,
                down: bDown || aDown,
                left: bLeft || aLeft,
                right: bRight || aRight,
            };
        }

        // Mapeia bot√µes do gamepad em a√ß√µes do jogo
        function handleGamepadActions(pad) {
            const BTN_A = 0;
            const BTN_B = 1;
            const BTN_X = 2;
            const BTN_START = 9; // Bot√£o Start (normalmente pausa)

            // Start => pause/unpause
            if (buttonPressedNow(pad, BTN_START)) {
                togglePause();
            }
// X => interagir
            if (buttonPressedNow(pad, BTN_X)) {
                attemptInteract();
            }

            // A => pular
            if (buttonPressedNow(pad, BTN_A)) {
                attemptJump();
            }

            // B => pegar/soltar
            if (buttonPressedNow(pad, BTN_B)) {
                attemptPickupOrDrop();
            }
        }

        function pollGamepad() {
            // Sempre limpar estado do gamepad por frame (evita ‚Äúandar eterno‚Äù)
            gamepadState.keys.left = false;
            gamepadState.keys.right = false;
            gamepadState.keys.up = false;
            gamepadState.keys.down = false;

            if (gamepadIndex === null) {
                gamepadIndex = findGamepad();
                if (gamepadIndex === null) return;
            }

            const pad = navigator.getGamepads()[gamepadIndex];
            if (!pad) {
                // desconectou
                gamepadIndex = null;
                return;
            }

            // (Opcional) Log r√°pido para confirmar o mapeamento do controle
            if (pad && Math.random() < 0.02) {
                console.log("Gamepad mapping:", pad.mapping, "axes:", pad.axes?.length || 0);
            }

            const now = getGameTime();

            // Dire√ß√µes: dpad (bot√µes + axes[6]/axes[7]) + anal√≥gico esquerdo
            const axX = pad.axes?.[0] ?? 0;
            const axY = pad.axes?.[1] ?? 0;
            const dpad = readDpad(pad);

            const leftAnalog = axX < -gamepadState.axisDeadzone;
            const rightAnalog = axX > gamepadState.axisDeadzone;

            const leftNow = dpad.left || leftAnalog;
            const rightNow = dpad.right || rightAnalog;
            const upNow = dpad.up || (axY < -gamepadState.axisDeadzone);
            const downNow = dpad.down || (axY > gamepadState.axisDeadzone);

            // IMPORTANT√çSSIMO:
            // NUNCA ‚ÄúOR‚Äù com keys.* (teclado). Se voc√™ faz keys.left = keys.left || gamepadLeft,
            // o valor pode ficar preso em true. O gamepad tem que setar estado POR FRAME.
            gamepadState.keys.left = leftNow;
            gamepadState.keys.right = rightNow;
            gamepadState.keys.up = upNow;
            gamepadState.keys.down = downNow;

            // Double-tap para correr via gamepad (edge: solto -> pressionado)
            if (leftNow && !gamepadState.prevLeft) {
                detectDoubleClick('left', now);
                // Primeiro movimento lateral - iniciar invencibilidade
                if (!hasMadeFirstMove && gameMode === 'game') {
                    hasMadeFirstMove = true;
                    playerInvincible = true;
                    playerInvincibilityStart = now;
                    updateProtectionIndicator();
                    console.log('Invencibilidade inicial ativada! Voc√™ tem 1 segundo de prote√ß√£o.');
                }
            }
            if (rightNow && !gamepadState.prevRight) {
                detectDoubleClick('right', now);
                // Primeiro movimento lateral - iniciar invencibilidade
                if (!hasMadeFirstMove && gameMode === 'game') {
                    hasMadeFirstMove = true;
                    playerInvincible = true;
                    playerInvincibilityStart = now;
                    updateProtectionIndicator();
                    console.log('Invencibilidade inicial ativada! Voc√™ tem 1 segundo de prote√ß√£o.');
                }
            }

            gamepadState.prevLeft = leftNow;
            gamepadState.prevRight = rightNow;

            // Edge-trigger para subir/descer (sem spam)
            if (upNow && !gamepadState.prevUp) {
                attemptVerticalMove(1);
            }
            if (downNow && !gamepadState.prevDown) {
                attemptVerticalMove(-1);
            }
            gamepadState.prevUp = upNow;
            gamepadState.prevDown = downNow;

            // A√ß√µes (X/A/B)
            handleGamepadActions(pad);

            updatePrevButtons(pad);
        }

        // Resolve input final (teclado + gamepad)
        function resolveInput() {
            const gp = gamepadState.keys;
            return {
                left:  keys.left  || gp.left,
                right: keys.right || gp.right,
                up:    keys.up    || gp.up,
                down:  keys.down  || gp.down
            };
        }

        // listeners para conectar/desconectar (bom p/ UX)
        window.addEventListener("gamepadconnected", (e) => {
            gamepadIndex = e.gamepad.index;
            console.log("Gamepad conectado:", e.gamepad.id);
        });
        window.addEventListener("gamepaddisconnected", () => {
            console.log("Gamepad desconectado");
            gamepadIndex = null;
        });

        // --- Estado das Intera√ß√µes ---
        let exhibitLightOn = false;
        let exhibitLightAnimation = 0; // 0-1 para controlar intensidade da luz

        // Estado do microsc√≥pio
        let microscopeOn = true; // Come√ßa ligado
        let teddyBearWaving = false;
        let teddyBearAnimation = 0; // 0-1 para controlar anima√ß√£o de acenar
        let dollhouseDoorOpen = false;
        let dollhouseDoorAnimation = 0; // 0-1 para controlar abertura da porta
        let abstractSculptureActive = false;
        let abstractSculptureAnimation = 0; // 0-1 para controlar movimento dos elementos
        let artifactDisplayMode = 0; // 0-3 para diferentes itens na vitrine
        let roboArmActive = false;
        let roboArmAnimation = 0; // 0-1 para controlar movimento do bra√ßo rob√¥
        let serverActive = false;
        let safetyShowerActive = false;
        let chemRackActive = false;
        let chemRackAnimation = 0; // 0-1 para controlar rea√ß√µes qu√≠micas
        let fridgeActive = false;
        let stoveActive = false;
        let microwaveActive = false;
        let coffeeMachineActive = false;
        let sinkActive = false;
        let arcadeActive = false;
        let arcadeAnimation = 0; // 0-1 para anima√ß√£o do Pacman
        let tvActive = false;
        let tvChannel = 0; // 0-3 para diferentes canais
        let vendingActive = false;
        let jukeboxActive = false;

        // Estados das l√¢mpadas (todas come√ßam apagadas)
        let floorLampOn = false;
        let deskLampOn = false;
        let streetLampOn = false;
        let punchingBagSwing = 0; // √Çngulo de balan√ßo do saco de pancada
        let poolTableActive = false;
        let waterCoolerActive = false;
        let treadmillActive = false;
        let dumbbellsActive = false;
        let medicineBallActive = false;

        // Contadores para miss√µes de intera√ß√£o
        let interactionCounts = {
            roboArm: 0,
            server: 0,
            tv: 0,
            microwave: 0,
            coffee: 0,
            vending: 0,
            jukebox: 0,
            treadmill: 0,
            punchingBag: 0,
            sink: 0,
            jumpOverEnemy: 0,
            underEnemyJump: 0
        };

        // --- Sistema de Itens Colet√°veis ---
        let collectibles = []; // Array de itens flutuantes
        let projectiles = []; // Array de proj√©teis (ex: floco de neve)
        let particles = []; // Sistema de part√≠culas para coleta
        let playerScore = 0;
        let collectedItemsCount = 0; // Contador de itens coletados para aumentar delay do inimigo

        // Sistema de Miss√µes
        let missions = {
            jumpOverEnemy: { completed: false, description: "Pular por cima do inimigo 3 vezes" },
            arcade: { completed: false, description: "Ligar um Fliperama" },
            tvToBedroom: { completed: false, description: "Levar uma televis√£o para o quarto" },
            stove: { completed: false, description: "Ligar o fog√£o" },
            fridgeToOffice: { completed: false, description: "Levar uma geladeira para o escrit√≥rio" },
            plantToBathroom: { completed: false, description: "Levar uma planta para o banheiro" },
            coffeeToLab: { completed: false, description: "Levar uma m√°quina de caf√© para o laborat√≥rio" },
            teddyToGarden: { completed: false, description: "Levar um ursinho para o jardim" },
            sofaToGym: { completed: false, description: "Levar um sof√° para a academia" },
            sinkToBedroom: { completed: false, description: "Levar uma pia para o quarto (estranho!)" },
            vendingToMusic: { completed: false, description: "Levar uma m√°quina de snacks para a sala de m√∫sica" },
            bookshelfToKitchen: { completed: false, description: "Levar uma estante de livros para a copa" },
            microscopeToLiving: { completed: false, description: "Levar um microsc√≥pio para a sala" },
            statueToPlayground: { completed: false, description: "Levar uma est√°tua para o parquinho" },
            activateRoboArm: { completed: false, description: "Ativar o bra√ßo rob√≥tico 3 vezes" },
            rebootServers: { completed: false, description: "Reiniciar servidores 5 vezes" },
            channelSurf: { completed: false, description: "Mudar canal da TV 4 vezes" },
            heatFood: { completed: false, description: "Usar o microondas 3 vezes" },
            makeCoffee: { completed: false, description: "Preparar caf√© 3 vezes" },
            buySnacks: { completed: false, description: "Usar m√°quina de snacks 4 vezes" },
            playMusic: { completed: false, description: "Ligar a Jukebox 2 vezes" },
            gymWorkout: { completed: false, description: "Usar a esteira 3 vezes" },
            trainBoxing: { completed: false, description: "Bater no saco de pancada 5 vezes" },
            washHands: { completed: false, description: "Abrir a torneira da pia 3 vezes" },
            underEnemyJump: { completed: false, description: "Passar duas vezes por baixo do inimigo enquanto ele est√° pulando" }
        };

        const TOTAL_MISSIONS = Object.keys(missions).length;

        // Sistema de Miss√µes Sequenciais
        let missionQueue = []; // Fila de miss√µes dispon√≠veis
        let currentMission = null; // Miss√£o ativa atual
        let completedMissionsCount = 0;

        // Inicializar sistema de miss√µes
        // forcedFirstMission (opcional): se informado, essa miss√£o ser√° a primeira da fila (modo teste)
        function initMissionSystem(forcedFirstMission = null) {
            // Resetar estado do jogo
            gameEnded = false;

            // Criar fila de miss√µes dispon√≠veis (todas n√£o completadas)
            missionQueue = Object.keys(missions).filter(key => !missions[key].completed);

            if (forcedFirstMission && missionQueue.includes(forcedFirstMission)) {
                // Coloca a miss√£o escolhida manualmente como primeira da fila (modo teste)
                missionQueue = missionQueue.filter(key => key !== forcedFirstMission);
                const restMissions = shuffleArray(missionQueue);
                missionQueue = [forcedFirstMission, ...restMissions];
            } else {
                // Embaralhar todas as miss√µes ‚Äî inclusive a primeira
                missionQueue = shuffleArray(missionQueue);
            }

            // Selecionar primeira miss√£o
            selectNextMission();

            // Mostrar indicador de prote√ß√£o
            updateProtectionIndicator();
        }

        // Fun√ß√£o auxiliar para embaralhar array
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Selecionar pr√≥xima miss√£o da fila
        function selectNextMission() {
            if (missionQueue.length > 0) {
                currentMission = missionQueue.shift();
                console.log(`Nova miss√£o ativa: ${missions[currentMission].description}`);
            } else {
                currentMission = null;
                console.log('Todas as miss√µes foram completadas!');
            }
            updateMissionsDisplay();
        }

        // Mostrar/ocultar indicador de prote√ß√£o
        function updateProtectionIndicator() {
            const indicator = document.getElementById('protectionIndicator');
            if (indicator) {
                if (gameMode === 'game' && !hasMadeFirstMove) {
                    indicator.style.display = 'block';
                } else {
                    indicator.style.display = 'none';
                }
            }
        }

        // --- Controle do Menu Inicial ---
        function initMainMenu() {
            const gameModeBtn = document.getElementById('gameModeBtn');
            const exploreModeBtn = document.getElementById('exploreModeBtn');
            const mainMenu = document.getElementById('mainMenu');
            const hud = document.querySelector('.hud');
            const missionTestContainer = document.getElementById('missionTestContainer');

            // Construir ferramenta de teste de miss√£o (lista e seletor) dentro do menu
            if (missionTestContainer) {
                const missionEntries = Object.entries(missions);

                const missionOptionsHtml = missionEntries.map(
                    ([key, data]) => `<option value="${key}">${data.description}</option>`
                ).join('');

                const missionListHtml = missionEntries.map(
                    ([key, data]) => `<li><strong>${key}</strong>: ${data.description}</li>`
                ).join('');

                missionTestContainer.innerHTML = `
                    <div style="margin-top: 24px; padding-top: 16px; border-top: 1px solid #555; text-align: left;">
                        <div style="font-weight: bold; margin-bottom: 8px; color: #ffd700;">
                            üß™ Ferramenta de teste de miss√£o
                        </div>
                        <label style="font-size: 0.9rem; display: block; margin-bottom: 6px;">
                            Escolha uma miss√£o espec√≠fica para come√ßar (modo teste):
                        </label>
                        <select id="missionSelect" style="width: 100%; padding: 8px; border-radius: 8px; border: none; margin-bottom: 10px;">
                            ${missionOptionsHtml}
                        </select>
                        <button id="missionTestStartBtn" style="
                            width: 100%;
                            padding: 10px;
                            font-size: 1rem;
                            background: linear-gradient(45deg, #9c27b0, #e040fb);
                            color: white;
                            border: none;
                            border-radius: 8px;
                            cursor: pointer;
                            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
                            font-weight: bold;
                            margin-bottom: 10px;
                        ">
                            üß™ Iniciar em miss√£o selecionada (teste)
                        </button>
                        <details style="font-size: 0.85rem; color: #ddd;">
                            <summary style="cursor: pointer; margin-bottom: 6px;">Ver lista completa de miss√µes</summary>
                            <ul style="margin-top: 8px; padding-left: 18px; max-height: 150px; overflow-y: auto;">
                                ${missionListHtml}
                            </ul>
                        </details>
                    </div>
                `;
            }

            // Adicionar efeitos hover aos bot√µes
            [gameModeBtn, exploreModeBtn].forEach(btn => {
                btn.addEventListener('mouseenter', () => {
                    btn.style.transform = 'translateY(-2px)';
                    btn.style.boxShadow = '0 8px 20px rgba(0,0,0,0.4)';
                });
                btn.addEventListener('mouseleave', () => {
                    btn.style.transform = 'translateY(0)';
                    btn.style.boxShadow = '0 6px 15px rgba(0,0,0,0.3)';
                });
            });

            gameModeBtn.addEventListener('click', () => {
                stopGameLoop(); // Garantir que n√£o h√° loops antigos
                gameMode = 'game';
                gamePaused = false; // Come√ßar sem pause
                mainMenu.style.display = 'none';
                hud.style.display = 'none'; // HUD oculto por padr√£o
                var infoOverlay = document.getElementById('infoOverlay');
                if (infoOverlay) infoOverlay.style.display = 'none';
                document.getElementById('missionsSection').style.display = 'block';
                document.getElementById('missionBottomDisplay').style.display = 'block';
                document.getElementById('exploreModeIndicator').style.display = 'none';
                initMissionSystem(); // Inicializar sistema de miss√µes
                init();
            });

            exploreModeBtn.addEventListener('click', () => {
                stopGameLoop(); // Garantir que n√£o h√° loops antigos
                gameMode = 'explore';
                gamePaused = false; // Come√ßar sem pause
                mainMenu.style.display = 'none';
                hud.style.display = 'none'; // HUD oculto por padr√£o
                var infoOverlay = document.getElementById('infoOverlay');
                if (infoOverlay) infoOverlay.style.display = 'none';
                // Modo explorat√≥rio agora tamb√©m usa o sistema de miss√µes
                document.getElementById('missionsSection').style.display = 'block';
                document.getElementById('missionBottomDisplay').style.display = 'block';
                document.getElementById('exploreModeIndicator').style.display = 'block';
                initMissionSystem(); // Inicializar sistema de miss√µes tamb√©m no modo explorat√≥rio
                init();
            });

            // Clique no bot√£o de teste de miss√£o: inicia o MODO JOGO, mas for√ßando a primeira miss√£o escolhida
            const missionSelect = document.getElementById('missionSelect');
            const missionTestStartBtn = document.getElementById('missionTestStartBtn');

            if (missionSelect && missionTestStartBtn) {
                missionTestStartBtn.addEventListener('click', () => {
                    const selectedMissionKey = missionSelect.value;
                    if (!selectedMissionKey || !missions[selectedMissionKey]) {
                        return;
                    }

                    // Reset b√°sico de status de miss√µes para o teste
                    Object.keys(missions).forEach(key => {
                        missions[key].completed = false;
                    });
                    completedMissionsCount = 0;

                    stopGameLoop(); // Garantir que n√£o h√° loops antigos
                    gameMode = 'game';
                    gamePaused = false; // Come√ßar sem pause
                    mainMenu.style.display = 'none';
                    hud.style.display = 'none'; // HUD oculto por padr√£o
                var infoOverlay = document.getElementById('infoOverlay');
                if (infoOverlay) infoOverlay.style.display = 'none';
                    document.getElementById('missionsSection').style.display = 'block';
                    document.getElementById('missionBottomDisplay').style.display = 'block';
                    document.getElementById('exploreModeIndicator').style.display = 'none';

                    // Inicia o sistema de miss√µes com a miss√£o escolhida como primeira
                    initMissionSystem(selectedMissionKey);
                    init();
                });
            }
        }

        // --- Sistema de Modos de Jogo ---
        let gameMode = null; // 'game' ou 'explore'
        let gameEnded = false; // Controla se o jogo terminou (vit√≥ria ou derrota)
        let gamePaused = false; // Controla se o jogo est√° pausado

        // --- Rel√≥gio do jogo (pausa congela o tempo) ---
        let pausedTimeTotal = 0;      // ms acumulados em pausa
        let pauseStartedAt = null;    // getGameTime() real quando entrou em pausa

        function getGameTime() {
            // Tempo ‚Äúdo jogo‚Äù (n√£o avan√ßa enquanto pausado)
            return Date.now() - pausedTimeTotal;
        }

        function togglePause() {
            if (!gameMode || gameEnded) return;

            const hudEl = document.querySelector('.hud');
            const pauseEl = document.getElementById('pauseIndicator');

            if (!gamePaused) {
                gamePaused = true;
                pauseStartedAt = Date.now(); // real
                document.body.classList.add('paused');

                // Exibir HUD completo durante o pause
                if (hudEl) hudEl.style.display = 'block';
                if (pauseEl) pauseEl.style.display = 'block';
            } else {
                gamePaused = false;

                if (pauseStartedAt !== null) {
                    pausedTimeTotal += (Date.now() - pauseStartedAt);
                    pauseStartedAt = null;
                }

                document.body.classList.remove('paused');

                // Voltar ao padr√£o (HUD escondido) quando retomar
                if (hudEl) hudEl.style.display = 'none';
                if (pauseEl) pauseEl.style.display = 'none';
            }
        }


        // --- Sistema de Controle de Loop (Token System) ---
        let loopToken = 0;
        let rafId = null;
        let isLoopRunning = false;

        // --- Sistema de Vidas e Inimigo ---
        let playerLives = 3;
        let playerInvincible = false;
        let playerInvincibilityStart = 0;
        let playerInvincibilityDuration = 1000; // 1 segundo

        // Sistema de invencibilidade inicial
        let hasMadeFirstMove = false; // Controla se o jogador j√° fez o primeiro movimento lateral
        let gameStartTime = 0;
        let enemy = {
            x: 0,              // Iniciar exatamente na posi√ß√£o inicial do jogador
            y: 0,
            floor: 0,
            state: 'idle',
            isJumping: false,
            // Sistema de replay cinem√°tico
            history: [],        // Buffer de snapshots {x, y, floor, state, timestamp}
            delayTime: 3000    // 1 segundo de atraso
        };

        let purpleEnemy = {
            x: 0,              // Iniciar exatamente na posi√ß√£o inicial do jogador
            y: 0,
            floor: 0,
            state: 'idle',
            isJumping: false,
            // Sistema de replay cinem√°tico
            history: [],        // Buffer de snapshots {x, y, floor, state, timestamp}
            delayTime: 2000    // 1 segundo de atraso
        };
        
        // Vari√°veis para rastrear intera√ß√µes espec√≠ficas com o inimigo
        // - se o jogador j√° pulou sobre o inimigo nesse pulo
        let hasJumpedOverEnemyThisJump = false;
        // - se o jogador j√° passou por baixo do inimigo nesse salto do inimigo
        let hasPassedUnderEnemyThisEnemyJump = false;

        function init() {
            resize();
            window.addEventListener('resize', resize);
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);
            getOrGenerateFloor(0);

            // Definir tempo de in√≠cio do jogo
            gameStartTime = getGameTime();

            // Inicializar barra de vida
            updateHealthBar();

            startGameLoop();
        }

        function attemptInteract() {
            // Verificar objetos interativos (itens colet√°veis s√£o autom√°ticos)
            const currentFloor = floors.get(player.floor);
            if (!currentFloor) return;

            let closestItem = null;
            let closestDistance = 60; // Dist√¢ncia m√°xima para intera√ß√£o

            // Procurar todos os objetos interativos pr√≥ximos
            for (const sector of currentFloor.sectors) {
                for (const item of sector.items) {
                    if (['exhibit_light', 'floor_lamp', 'desk_lamp', 'street_lamp', 'teddy_bear', 'dollhouse', 'abstract_sculpture', 'artifact_display', 'robo_arm', 'server', 'safety_shower', 'chem_rack', 'fridge', 'stove', 'microwave', 'coffee_machine', 'sink', 'arcade', 'tv', 'vending', 'jukebox', 'pool_table', 'water_cooler', 'treadmill', 'dumbbells', 'medicine_ball', 'punching_bag', 'microscope'].includes(item.type)) {
                        const distance = Math.abs(player.x - item.x);
                        if (distance < closestDistance) {
                            closestItem = item;
                            closestDistance = distance;
                        }
                    }
                }
            }

            // Interagir com o objeto mais pr√≥ximo
            if (closestItem) {
                switch (closestItem.type) {
                    case 'exhibit_light':
                        toggleExhibitLight();
                        break;
                    case 'teddy_bear':
                        toggleTeddyWave();
                        break;
                    case 'dollhouse':
                        toggleDollhouseDoor();
                        break;
                    case 'abstract_sculpture':
                        toggleAbstractSculpture();
                        break;
                    case 'artifact_display':
                        cycleArtifactDisplay();
                        break;
                    case 'robo_arm':
                        toggleRoboArm();
                        break;
                    case 'server':
                        toggleServer();
                        break;
                    case 'safety_shower':
                        toggleSafetyShower();
                        break;
                    case 'chem_rack':
                        toggleChemRack();
                        break;
                    case 'fridge':
                        toggleFridge();
                        break;
                    case 'stove':
                        toggleStove();
                        break;
                    case 'microwave':
                        toggleMicrowave();
                        break;
                    case 'coffee_machine':
                        toggleCoffeeMachine();
                        break;
                    case 'sink':
                        toggleSink();
                        break;
                    case 'arcade':
                        toggleArcade();
                        break;
                    case 'tv':
                        toggleTV();
                        break;
                    case 'vending':
                        toggleVending();
                        break;
                    case 'jukebox':
                        toggleJukebox();
                        break;
                    case 'pool_table':
                        togglePoolTable();
                        break;
                    case 'punching_bag':
                        togglePunchingBag();
                        break;
                    case 'water_cooler':
                        toggleWaterCooler();
                        break;
                    case 'treadmill':
                        toggleTreadmill();
                        break;
                    case 'dumbbells':
                        toggleDumbbells();
                        break;
                    case 'medicine_ball':
                        toggleMedicineBall();
                        break;
                    case 'microscope':
                        toggleMicroscope();
                        break;
                    case 'floor_lamp':
                        toggleFloorLamp();
                        break;
                    case 'desk_lamp':
                        toggleDeskLamp();
                        break;
                    case 'street_lamp':
                        toggleStreetLamp();
                        break;
                    case 'exhibit_light':
                        toggleExhibitLight();
                        break;
                }
            }
        }

        function attemptJump() {
            if (player.isOnGround && !player.isJumping) {
                // Calcular altura do pulo baseada na velocidade atual
                // Velocidade m√°xima = 5, altura base = 6
                // Quando parado: altura = 6
                // Quando na velocidade m√°xima: altura = 9
                const speedRatio = Math.abs(player.currentSpeed) / player.maxSpeed; // 0 a 1
                const dynamicJumpPower = player.jumpPower + (speedRatio * 3); // B√¥nus m√°ximo de 3

                player.velocityY = -dynamicJumpPower; // Pulo para cima (negativo)
                player.isJumping = true;
                player.isOnGround = false;
            }
        }

        function detectDoubleClick(direction, currentTime) {
            const timeDiff = currentTime - player.lastKeyTime[direction];

            if (timeDiff < 300) { // 300ms para considerar double click
                player.keyClickCount[direction]++;
                if (player.keyClickCount[direction] >= 2) {
                    player.isRunning = true;
                    player.keyClickCount[direction] = 0;
                }
            } else {
                player.keyClickCount[direction] = 1;
            }

            player.lastKeyTime[direction] = currentTime;
        }

        function attemptPickupOrDrop() {
            if (player.isCarrying) {
                // Soltar o objeto carregado
                dropCarriedItem();
            } else {
                // Tentar pegar um objeto pr√≥ximo
                pickupNearbyItem();
            }
        }

        function attemptDash() {
            const now = getGameTime();
            if (!player.isDashing && now > player.dashCooldown) {
                player.isDashing = true;
                player.dashTime = now + 200; // Dash dura 200ms
                player.dashCooldown = now + 1000; // Cooldown de 1 segundo
                
                // Impulso na dire√ß√£o atual
                const dashDirection = player.currentSpeed >= 0 ? 1 : -1;
                player.currentSpeed = dashDirection * 15;
                
                // Part√≠culas de rastro
                for(let i=0; i<5; i++) {
                    particles.push({
                        x: player.x, y: player.y - 16,
                        vx: -dashDirection * (2 + Math.random() * 2),
                        vy: (Math.random() - 0.5) * 2,
                        life: 20, maxLife: 20,
                        color: '#ffffff',
                        size: 3
                    });
                }
                console.log("Dash executado!");
            }
        }

        function pickupNearbyItem() {
            const currentFloor = floors.get(player.floor);
            if (!currentFloor) return;

            let closestItem = null;
            let closestDistance = 40; // Dist√¢ncia m√°xima para pegar

            // Procurar objetos pr√≥ximos que podem ser pegos
            for (const sector of currentFloor.sectors) {
                for (const item of sector.items) {
                    // Itens que podem ser pegos (praticamente todos os objetos m√≥veis/interativos)
                    const pickableItems = [
                        // Parque infantil
                        'teddy_bear', 'dollhouse', 'hopscotch', 'tire_swing', 'ball_pit',
                        // Museu
                        'classic_statue', 'ancient_painting', 'artifact_display', 'marble_bust',
                        'decorative_pedestal', 'exhibit_light', 'abstract_sculpture', 'art_installation',
                        // Copa
                        'fridge', 'stove', 'microwave', 'coffee_machine', 'sink',
                        // Entretenimento
                        'arcade', 'tv', 'vending', 'jukebox', 'pool_table',
                        // Academia
                        'water_cooler', 'treadmill', 'dumbbells', 'medicine_ball', 'bench_press',
                        'weight_machine', 'exercise_bike', 'treadmill', 'rowing_machine', 'elliptical',
                        // Banheiro
                        'toilet', 'sink_bathroom', 'shower', 'bathtub', 'mirror', 'towel_rack',
                        // Escrit√≥rio
                        'desk', 'chair', 'computer', 'printer', 'bookshelf', 'filing_cabinet',
                        // Laborat√≥rio
                        'robo_arm', 'server', 'safety_shower', 'chem_rack', 'microscope', 'beaker',
                        // Jardim
                        'bench', 'flower_pot', 'garden_gnome', 'watering_can', 'lawn_mower',
                        // Quarto
                        'bed', 'nightstand', 'lamp', 'dresser', 'wardrobe',
                        // Sala de estar
                        'sofa', 'coffee_table', 'tv_stand', 'bookcase', 'armchair',
                        // Bar
                        'bar_counter', 'bar_stool', 'cash_register', 'beer_tap', 'wine_rack',
                        // Loja de roupas
                        'mannequin', 'display_window', 'fitting_room', 'cash_register_clothing', 'clothing_rack',
                        // Recep√ß√£o
                        'reception_desk', 'waiting_chair', 'plant', 'magazine_rack', 'water_fountain',
                        // Armazenamento
                        'storage_shelf', 'crate', 'pallet', 'toolbox', 'ladder',
                        // Sala de m√∫sica
                        'piano', 'violin', 'guitar', 'drum_set', 'saxophone', 'trumpet', 'acoustic_guitar', 'keyboard',
                        // Objetos gerais e mobili√°rio
                        'table', 'lab_table', 'meeting_table', 'tool_cabinet', 'tv_stand', 'bed', 'sofa', 'plant',
                        'mag_rack', 'info_kiosk', 'waiting_bench', 'floor_lamp', 'painting', 'speaker', 'trash_can',
                        'bunk_bed', 'locker', 'whiteboard', 'coat_rack', 'garden_bench', 'fountain', 'street_lamp',
                        'equations_board', 'barrel', 'pallet_jack', 'stool', 'bush', 'statue', 'medicine_cabinet',
                        'laundry_basket', 'resistance_bands', 'foam_roller', 'kettlebell', 'pull_up_bar',
                        'ankle_weights', 'hand_grips', 'massage_ball', 'protein_shaker', 'swing', 'slide', 'seesaw',
                        'sandbox', 'jungle_gym', 'spring_rider', 'test_cube', 'stool', 'beer_taps', 'bottles_rack',
                        'dart_board', 'neon_signs', 'shoe_rack', 'mirror_wall', 'hangers_rack', 'classical_statue',
                        'desk_lamp', 'box_pile'
                    ];

                    if (pickableItems.includes(item.type)) {
                        const distance = Math.abs(player.x - item.x);
                        if (distance < closestDistance) {
                            closestItem = item;
                            closestDistance = distance;
                        }
                    }
                }
            }

            if (closestItem) {
            // Pegar o item
            player.isCarrying = true;
            player.carriedItem = {
                ...closestItem,
                originalSector: {
                    ...currentFloor.sectors.find(sector =>
                        sector.items.includes(closestItem)
                    ),
                    floorIndex: player.floor // Armazenar o andar original
                }
            };

                // Remover o item do setor
                const sector = player.carriedItem.originalSector;
                const itemIndex = sector.items.indexOf(closestItem);
                if (itemIndex > -1) {
                    sector.items.splice(itemIndex, 1);
                }

                console.log(`Pegou ${closestItem.type}!`);
            }
        }

        function dropCarriedItem() {
            if (!player.isCarrying || !player.carriedItem) return;

            const currentFloor = floors.get(player.floor);
            if (!currentFloor) return;

            // Helpers para setor e clamp
            function getSectorAtX(floorData, x) {
                return floorData.sectors.find(s => x >= s.startX && x <= s.endX) || null;
            }
            function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

            // Encontrar setor correto baseado na posi√ß√£o X do player
            let targetSector = getSectorAtX(currentFloor, player.x);
            if (!targetSector) {
                // Fallback: setor mais pr√≥ximo do centro
                targetSector = currentFloor.sectors.reduce((closest, sector) => {
                    const cd = Math.abs(player.x - (sector.startX + sector.endX)/2);
                    const bd = Math.abs(player.x - (closest.startX + closest.endX)/2);
                    return cd < bd ? sector : closest;
                });
            }

            // Clamp dropX dentro dos limites do setor com margem
            const margin = 20;
            let dropX = clamp(player.x, targetSector.startX + margin, targetSector.endX - margin);

            // FIX PRINCIPAL: n√£o compensar por diferen√ßa de andar - yOff √© local ao andar
            const adjustedYOff = (player.carriedItem.yOff || 0);

            // Calcular Y render estimado para debug
            const estimatedRenderY = (-player.floor * FLOOR_HEIGHT) - (SPECS[player.carriedItem.type]?.h || 0) - adjustedYOff;

            // Log detalhado para debug
            console.log('[DROP]', {
                type: player.carriedItem.type,
                playerFloor: player.floor,
                originalFloor: player.carriedItem.originalSector?.floorIndex,
                yOff: player.carriedItem.yOff,
                adjustedYOff,
                dropX,
                sector: targetSector.theme,
                sectorRange: [targetSector.startX, targetSector.endX],
                estimatedRenderY,
                floorDifference: (-player.floor * FLOOR_HEIGHT) - (-(player.carriedItem.originalSector?.floorIndex || 0) * FLOOR_HEIGHT)
            });

            // Evitar carregar lixo/estado interno pro mundo
            const { originalSector, ...cleanItem } = player.carriedItem;

            targetSector.items.push({
                ...cleanItem,
                x: dropX,
                yOff: adjustedYOff
            });

            console.log(`Soltou ${player.carriedItem.type} no setor ${targetSector.theme}!`);

            // Limpar estado de carregamento
            player.isCarrying = false;
            player.carriedItem = null;

            // Verificar miss√µes ap√≥s soltar item
            checkMissions();
        }

        // Fun√ß√£o auxiliar para verificar se um item est√° em um setor espec√≠fico
        function checkItemInSector(itemType, sectorTheme) {
            let found = false;
            floors.forEach(floor => {
                floor.sectors.forEach(sector => {
                    if (sector.theme === sectorTheme) {
                        sector.items.forEach(item => {
                            if (item.type === itemType) {
                                found = true;
                            }
                        });
                    }
                });
            });
            return found;
        }

        // Sistema de Miss√µes Sequenciais
        function checkMissions() {
            if (!currentMission) return; // Nenhuma miss√£o ativa

            let missionCompleted = false;

            // Verificar a miss√£o atual
            switch (currentMission) {
                case 'jumpOverEnemy':
                    if (interactionCounts.jumpOverEnemy >= 3) {
                        missions.jumpOverEnemy.completed = true;
                        missionCompleted = true;
                        console.log('Miss√£o completada: Pulou sobre o inimigo 3 vezes!');
                    }
                    break;
                case 'arcade':
                    if (!missions.arcade.completed && arcadeActive) {
                        missions.arcade.completed = true;
                        missionCompleted = true;
                        console.log('Miss√£o completada: Fliperama ligado!');
                    }
                    break;

                case 'tvToBedroom':
                    // Verificar se h√° uma TV em algum setor bedroom
                    let tvFoundInBedroom = false;
                    floors.forEach(floor => {
                        floor.sectors.forEach(sector => {
                            if (sector.theme === 'bedroom') {
                                sector.items.forEach(item => {
                                    if (item.type === 'tv') {
                                        tvFoundInBedroom = true;
                                    }
                                });
                            }
                        });
                    });

                    if (!missions.tvToBedroom.completed && tvFoundInBedroom) {
                        missions.tvToBedroom.completed = true;
                        missionCompleted = true;
                        console.log('Miss√£o completada: TV levada para o quarto!');
                    }
                    break;

                case 'stove':
                    if (!missions.stove.completed && stoveActive) {
                        missions.stove.completed = true;
                        missionCompleted = true;
                        console.log('Miss√£o completada: Fog√£o ligado!');
                    }
                    break;
                case 'fridgeToOffice':
                    if (checkItemInSector('fridge', 'office')) {
                        missions.fridgeToOffice.completed = true;
                        missionCompleted = true;
                    }
                    break;
                case 'plantToBathroom':
                    if (checkItemInSector('plant', 'bathroom')) {
                        missions.plantToBathroom.completed = true;
                        missionCompleted = true;
                    }
                    break;
                case 'coffeeToLab':
                    if (checkItemInSector('coffee_machine', 'lab')) {
                        missions.coffeeToLab.completed = true;
                        missionCompleted = true;
                    }
                    break;
                case 'teddyToGarden':
                    if (checkItemInSector('teddy_bear', 'garden')) {
                        missions.teddyToGarden.completed = true;
                        missionCompleted = true;
                    }
                    break;
                case 'sofaToGym':
                    if (checkItemInSector('sofa', 'gym')) {
                        missions.sofaToGym.completed = true;
                        missionCompleted = true;
                    }
                    break;
                case 'sinkToBedroom':
                    if (checkItemInSector('sink', 'bedroom')) {
                        missions.sinkToBedroom.completed = true;
                        missionCompleted = true;
                    }
                    break;
                case 'vendingToMusic':
                    if (checkItemInSector('vending', 'music_room')) {
                        missions.vendingToMusic.completed = true;
                        missionCompleted = true;
                    }
                    break;
                case 'bookshelfToKitchen':
                    if (checkItemInSector('bookshelf', 'kitchen')) {
                        missions.bookshelfToKitchen.completed = true;
                        missionCompleted = true;
                    }
                    break;
                case 'microscopeToLiving':
                    if (checkItemInSector('microscope', 'living')) {
                        missions.microscopeToLiving.completed = true;
                        missionCompleted = true;
                    }
                    break;
                case 'statueToPlayground':
                    if (checkItemInSector('statue', 'playground')) {
                        missions.statueToPlayground.completed = true;
                        missionCompleted = true;
                    }
                    break;
                case 'activateRoboArm':
                    if (interactionCounts.roboArm >= 3) {
                        missions.activateRoboArm.completed = true;
                        missionCompleted = true;
                    }
                    break;
                case 'rebootServers':
                    if (interactionCounts.server >= 5) {
                        missions.rebootServers.completed = true;
                        missionCompleted = true;
                    }
                    break;
                case 'channelSurf':
                    if (interactionCounts.tv >= 4) {
                        missions.channelSurf.completed = true;
                        missionCompleted = true;
                    }
                    break;
                case 'heatFood':
                    if (interactionCounts.microwave >= 3) {
                        missions.heatFood.completed = true;
                        missionCompleted = true;
                    }
                    break;
                case 'makeCoffee':
                    if (interactionCounts.coffee >= 3) {
                        missions.makeCoffee.completed = true;
                        missionCompleted = true;
                    }
                    break;
                case 'buySnacks':
                    if (interactionCounts.vending >= 4) {
                        missions.buySnacks.completed = true;
                        missionCompleted = true;
                    }
                    break;
                case 'playMusic':
                    if (interactionCounts.jukebox >= 2) {
                        missions.playMusic.completed = true;
                        missionCompleted = true;
                    }
                    break;
                case 'gymWorkout':
                    if (interactionCounts.treadmill >= 3) {
                        missions.gymWorkout.completed = true;
                        missionCompleted = true;
                    }
                    break;
                case 'trainBoxing':
                    if (interactionCounts.punchingBag >= 5) {
                        missions.trainBoxing.completed = true;
                        missionCompleted = true;
                    }
                    break;
                case 'washHands':
                    if (interactionCounts.sink >= 3) {
                        missions.washHands.completed = true;
                        missionCompleted = true;
                    }
                    break;
                case 'underEnemyJump':
                    if (interactionCounts.underEnemyJump >= 2) {
                        missions.underEnemyJump.completed = true;
                        missionCompleted = true;
                    }
                    break;
            }

            // Se miss√£o foi completada, avan√ßar para a pr√≥xima
            if (missionCompleted) {
                completedMissionsCount++;
                selectNextMission();

                // Resetar contadores de intera√ß√£o com inimigos
                interactionCounts.jumpOverEnemy = 0;
                interactionCounts.underEnemyJump = 0;

                // Verificar se todas as miss√µes foram completadas
                if (completedMissionsCount >= TOTAL_MISSIONS) {
                    gameVictory();
                }
            }
        }

        // Fun√ß√£o para detectar o setor atual do jogador
        function getCurrentSector() {
            const currentFloor = floors.get(player.floor);
            if (!currentFloor) return null;

            return currentFloor.sectors.find(sector => player.x >= sector.startX && player.x <= sector.endX) || null;
        }

        // Fun√ß√£o para detectar objetos pr√≥ximos ao jogador
        function getNearbyObjects() {
            const currentFloor = floors.get(player.floor);
            if (!currentFloor) return [];

            const nearbyObjects = [];
            const maxDistance = 80; // Dist√¢ncia m√°xima para considerar "pr√≥ximo"

            for (const sector of currentFloor.sectors) {
                for (const item of sector.items) {
                    const distance = Math.abs(player.x - item.x);
                    if (distance <= maxDistance) {
                        nearbyObjects.push({
                            name: getItemDisplayName(item.type),
                            distance: distance
                        });
                    }
                }
            }

            // Ordenar por dist√¢ncia (mais pr√≥ximos primeiro) e limitar a 2 objetos
            return nearbyObjects
                .sort((a, b) => a.distance - b.distance)
                .slice(0, 2);
        }

        // Fun√ß√£o auxiliar para obter nome display√°vel do item
        function getItemDisplayName(itemType) {
            const nameMap = {
                'teddy_bear': 'Urso de Pel√∫cia',
                'dollhouse': 'Casa de Boneca',
                'hopscotch': 'Amarelinha',
                'tire_swing': 'Balan√ßo de Pneu',
                'ball_pit': 'Piscina de Bolas',
                'classic_statue': 'Est√°tua Cl√°ssica',
                'ancient_painting': 'Pintura Antiga',
                'artifact_display': 'Display de Artefato',
                'marble_bust': 'Busto de M√°rmore',
                'decorative_pedestal': 'Pedestal Decorativo',
                'exhibit_light': 'Luz de Exposi√ß√£o',
                'abstract_sculpture': 'Escultura Abstrata',
                'art_installation': 'Instala√ß√£o de Arte',
                'robo_arm': 'Bra√ßo Rob√≥tico',
                'server': 'Servidor',
                'safety_shower': 'Chuveiro de Seguran√ßa',
                'chem_rack': 'Prateleira de Qu√≠mica',
                'microscope': 'Microsc√≥pio',
                'beaker': 'B√©quer',
                'flower_pot': 'Vaso de Flor',
                'bench': 'Banco',
                'garden_gnome': 'Gnomo de Jardim',
                'watering_can': 'Regador',
                'lawn_mower': 'Cortador de Grama',
                'bed': 'Cama',
                'nightstand': 'Criado-Mudo',
                'lamp': 'L√¢mpada',
                'dresser': 'C√¥moda',
                'wardrobe': 'Guarda-Roupa',
                'coat_rack': 'Cabideiro',
                'chair': 'Cadeira',
                'desk': 'Escrit√≥rio',
                'bookshelf': 'Estante',
                'computer': 'Computador',
                'sofa': 'Sof√°',
                'tv': 'TV',
                'coffee_table': 'Mesa de Centro',
                'fridge': 'Geladeira',
                'stove': 'Fog√£o',
                'microwave': 'Microondas',
                'sink': 'Pia',
                'kitchen_cabinet': 'Arm√°rio da Cozinha',
                'dining_table': 'Mesa de Jantar',
                'arcade': 'Fliperama',
                'vending': 'M√°quina de Vendas',
                'jukebox': 'Jukebox',
                'pool_table': 'Mesa de Sinuca',
                'water_cooler': 'Bebedouro',
                'treadmill': 'Esteira',
                'dumbbells': 'Halteres',
                'medicine_ball': 'Bola Medicinal',
                'punching_bag': 'Saco de Pancada',
                'shower': 'Chuveiro',
                'toilet': 'Banheiro',
                'bathtub': 'Banheira',
                'mirror': 'Espelho',
                'shoe_rack': 'Prateleira de Sapatos',
                'clothing_rack': 'Arara de Roupas',
                'fitting_room': 'Provador',
                'cash_register': 'Caixa Registradora',
                'display_window': 'Vitrine',
                'mannequin': 'Maneco'
            };

            return nameMap[itemType] || itemType.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        }

        function updateMissionsDisplay() {
            const missionDisplay = document.getElementById('currentMission');

            if (missionDisplay) {
                if (currentMission) {
                    const mission = missions[currentMission];
                    const status = mission.completed ? '‚úÖ' : 'üéØ';
                    let description = mission.description;
                    
                    // Mostrar progresso para miss√£o de pular sobre o inimigo
                    if (currentMission === 'jumpOverEnemy' && !mission.completed) {
                        description = `${mission.description} (${interactionCounts.jumpOverEnemy}/3)`;
                    }
                    
                    // Mostrar progresso para miss√£o de passar por baixo do inimigo
                    if (currentMission === 'underEnemyJump' && !mission.completed) {
                        description = `${mission.description} (${interactionCounts.underEnemyJump}/2)`;
                    }
                    
                    missionDisplay.innerHTML = `${status} ${description}`;
                    missionDisplay.style.color = mission.completed ? '#4CAF50' : '#ffd700';
                } else {
                    missionDisplay.innerHTML = 'üéâ Todas as miss√µes completadas!';
                    missionDisplay.style.color = '#4CAF50';
                }
            }

            // Atualizar contador de progresso
            const progressElement = document.getElementById('missionProgress');
            if (progressElement) {
                progressElement.textContent = `${completedMissionsCount}/${TOTAL_MISSIONS}`;
            }
        }

        function gameVictory() {
            console.log('PARAB√âNS! Voc√™ venceu o jogo completando todas as miss√µes!');
            gameEnded = true; // Parar toda a l√≥gica do jogo

            // Calcular estat√≠sticas finais
            const totalTime = (getGameTime() - gameStartTime) / 1000;
            const minutes = Math.floor(totalTime / 60);
            const seconds = Math.floor(totalTime % 60);
            const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;

            // Criar tela de vit√≥ria aprimorada
            const victoryDiv = document.createElement('div');
            victoryDiv.id = 'victoryScreen';
            victoryDiv.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                z-index: 10000;
                color: white;
                font-family: Arial, sans-serif;
                text-align: center;
                overflow-y: auto;
            `;

            victoryDiv.innerHTML = `
                <div style="background: rgba(0,0,0,0.8); padding: 40px; border-radius: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); max-width: 600px; width: 90%;">
                    <div style="font-size: 4rem; color: #ffd700; margin-bottom: 20px; text-shadow: 2px 2px 4px #000;">
                        üèÜ VIT√ìRIA TOTAL! üèÜ
                    </div>

                    <div style="font-size: 1.8rem; margin-bottom: 15px; color: #4CAF50; font-weight: bold;">
                        üéâ Parab√©ns! Voc√™ completou todas as miss√µes! üéâ
                    </div>

                    <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px; margin: 20px 0;">
                        <div style="font-size: 1.4rem; margin-bottom: 15px; color: #ffd700;">
                            üìä Estat√≠sticas Finais:
                        </div>
                        <div style="font-size: 1.2rem; line-height: 1.8;">
                            <div>‚è±Ô∏è <strong>Tempo Total:</strong> ${timeString}</div>
                            <div>üéØ <strong>Miss√µes Completadas:</strong> ${completedMissionsCount}/10</div>
                            <div>üí∞ <strong>Pontua√ß√£o Final:</strong> ${playerScore} pontos</div>
                            <div>üè¢ <strong>Andar Alcan√ßado:</strong> ${player.floor}</div>
                        </div>
                    </div>

                    <div style="background: rgba(76, 175, 80, 0.2); padding: 20px; border-radius: 10px; margin: 20px 0; border: 2px solid #4CAF50;">
                        <div style="font-size: 1.3rem; margin-bottom: 15px; color: #4CAF50; font-weight: bold;">
                            ‚úÖ Miss√µes Conclu√≠das:
                        </div>
                        <div style="font-size: 1.1rem; line-height: 1.6; text-align: left; max-width: 400px; margin: 0 auto;">
                            ${Object.keys(missions).filter(k => missions[k].completed).map(k => `<div style="margin-bottom: 8px;">‚úîÔ∏è ${missions[k].description}</div>`).join('')}
                        </div>
                    </div>

                    <div style="margin: 30px 0 20px 0;">
                        <button id="victoryRestartButton" style="
                            padding: 18px 35px;
                            font-size: 1.3rem;
                            background: linear-gradient(45deg, #ffd700, #ffb300);
                            color: #000;
                            border: none;
                            border-radius: 10px;
                            cursor: pointer;
                            box-shadow: 0 6px 15px rgba(0,0,0,0.4);
                            font-weight: bold;
                            transition: all 0.3s ease;
                        ">üéÆ Jogar Novamente</button>
                    </div>

                    <div style="font-size: 0.9rem; color: #ccc; margin-top: 20px;">
                        Obrigado por jogar SkyTower Ultimate!
                    </div>
                </div>
            `;

            document.body.appendChild(victoryDiv);

            // Adicionar efeito hover ao bot√£o
            const restartBtn = document.getElementById('victoryRestartButton');
            if (restartBtn) {
                restartBtn.addEventListener('mouseenter', () => {
                    restartBtn.style.transform = 'translateY(-2px)';
                    restartBtn.style.boxShadow = '0 8px 20px rgba(0,0,0,0.5)';
                });
                restartBtn.addEventListener('mouseleave', () => {
                    restartBtn.style.transform = 'translateY(0)';
                    restartBtn.style.boxShadow = '0 6px 15px rgba(0,0,0,0.4)';
                });
            }

            // Adicionar evento de clique no bot√£o de restart (mostra morte por 2s, volta ao menu)
            document.getElementById('victoryRestartButton').addEventListener('click', function() {
                // Remover tela de vit√≥ria
                const victoryScreen = document.getElementById('victoryScreen');
                if (victoryScreen) {
                    victoryScreen.remove();
                }

                // Resetar estado do jogo
                gameEnded = false;

                // Mostrar tela de morte por 2 segundos
                showDeathScreen();
            });
        }

        // Mostrar tela de morte tempor√°ria e voltar ao menu
        function showDeathScreen() {
            // Criar tela de morte (sem bot√£o, apenas visual)
            const deathDiv = document.createElement('div');
            deathDiv.id = 'deathScreen';
            deathDiv.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(139, 0, 0, 0.9);
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                z-index: 10000;
                color: white;
                font-family: Arial, sans-serif;
                text-align: center;
            `;

            deathDiv.innerHTML = `
                <div style="font-size: 6rem; margin-bottom: 20px; text-shadow: 4px 4px 8px #000;">üíÄ</div>
                <div style="font-size: 3rem; color: #ff0000; margin-bottom: 20px; text-shadow: 2px 2px 4px #000;">MORREU!</div>
                <div style="font-size: 1.5rem; margin-bottom: 20px;">Ap√≥s a vit√≥ria, voc√™ sucumbiu ao cansa√ßo...</div>
                <div style="font-size: 1.2rem;">Retornando ao menu inicial...</div>
            `;

            document.body.appendChild(deathDiv);

            // Ap√≥s 2 segundos, voltar ao menu inicial com reset completo
            setTimeout(() => {
                completeGameReset();
            }, 2000);
        }

        // Sistema de Controle de Loop (Token System)
        function startGameLoop() {
            // Primeiro parar qualquer loop antigo
            stopGameLoop();

            isLoopRunning = true;
            loopToken++;

            const myToken = loopToken;

            function frame() {
                // Se loop foi parado ou token mudou (loop antigo), parar execu√ß√£o
                if (!isLoopRunning || myToken !== loopToken) {
                    return;
                }

                // Enquanto pausado, n√£o roda update() (congela inimigos, contagens e f√≠sica),
                // mas ainda checa START para retomar.
                if (gamePaused) {
                    pollGamepad(); // permite despausar no controle
                    draw();        // redesenha o estado congelado
                    rafId = requestAnimationFrame(frame);
                    return;
                }

                update();
                draw();
                rafId = requestAnimationFrame(frame);

                // Debug: verificar se h√° apenas 1 loop ativo
                console.log("loop tick", myToken);
            }

            rafId = requestAnimationFrame(frame);
        }

        function stopGameLoop() {
            isLoopRunning = false;
            loopToken++; // Invalida qualquer loop antigo

            if (rafId !== null) {
                cancelAnimationFrame(rafId);
                rafId = null;
            }
        }

        // Reset completo do jogo - volta ao estado inicial
        function completeGameReset() {
            console.log('Executando reset completo do jogo...');

            // Parar o loop do jogo usando o sistema de tokens
            stopGameLoop();

            // Remover event listeners antigos para evitar duplicatas
            window.removeEventListener('resize', resize);
            window.removeEventListener('keydown', onKeyDown);
            window.removeEventListener('keyup', onKeyUp);

            // Remover todas as telas sobrepostas
            const screens = ['gameOverScreen', 'victoryScreen', 'deathScreen'];
            screens.forEach(screenId => {
                const screen = document.getElementById(screenId);
                if (screen) {
                    screen.remove();
                }
            });

            // Resetar todas as vari√°veis globais
            gameMode = null;
            gameEnded = false;
            gamePaused = false;
            hasMadeFirstMove = false;
            gameStartTime = 0;

            // Resetar jogador completamente
            playerLives = 3;
            playerScore = 0;
            collectedItemsCount = 0;

            // Resetar todas as propriedades do player
            player.x = 0;
            player.y = 0;
            player.floor = 0;
            player.state = 'idle';
            player.targetY = 0;
            player.velocityY = 0;
            player.isJumping = false;
            player.isOnGround = true;
            player.speed = 2.5;
            player.maxSpeed = 5;
            player.acceleration = 0.3;
            player.deceleration = 0.2;
            player.currentSpeed = 0;
            player.isRunning = false;
            player.jumpHorizontalSpeed = 0;
            player.isCarrying = false;
            player.carriedItem = null;
            player.lastKeyTime = { left: 0, right: 0 };
            player.keyClickCount = { left: 0, right: 0 };

            // Resetar invencibilidade
            playerInvincible = false;
            playerInvincibilityStart = 0;
            hasMadeFirstMove = false;

            // Resetar inimigos
            enemy.x = 0;
            enemy.y = 0;
            enemy.floor = 0;
            enemy.state = 'idle';
            enemy.history = [];
            enemy.isJumping = false;

            purpleEnemy.x = 0;
            purpleEnemy.y = 0;
            purpleEnemy.floor = 0;
            purpleEnemy.state = 'idle';
            purpleEnemy.history = [];
            purpleEnemy.isJumping = false;

            // Resetar miss√µes
            missions.jumpOverEnemy.completed = false;
            missions.arcade.completed = false;
            missions.tvToBedroom.completed = false;
            missions.stove.completed = false;
            missionQueue = [];
            currentMission = null;
            completedMissionsCount = 0;

            // Resetar objetos interativos
            arcadeActive = false;
            tvActive = false;
            stoveActive = false;
            
            // Resetar contadores de intera√ß√£o
            Object.keys(interactionCounts).forEach(key => interactionCounts[key] = 0);
            hasJumpedOverEnemyThisJump = false;

            // Resetar arrays de entidades
            collectibles = [];
            particles = [];

            // Resetar estado das teclas
            keys.left = false;
            keys.right = false;
            keys.up = false;
            keys.down = false;

            // Limpar mapa de andares
            floors.clear();

            // Esconder HUD e mostrar menu inicial
            const mainMenu = document.getElementById('mainMenu');
            const hud = document.querySelector('.hud');
            if (mainMenu && hud) {
                mainMenu.style.display = 'flex';
                hud.style.display = 'none';
                var infoOverlay = document.getElementById('infoOverlay');
                if (infoOverlay) infoOverlay.style.display = 'none';
                document.getElementById('missionBottomDisplay').style.display = 'block';
                document.getElementById('exploreModeIndicator').style.display = 'none';
            }

            // Re-inicializar menu
            initMainMenu();

            console.log('Reset completo conclu√≠do - jogo pronto para novo in√≠cio!');
        }

        function collectItem(collectible) {
            exhibitLightOn = !exhibitLightOn;
        }

        function toggleTeddyWave() {
            teddyBearWaving = !teddyBearWaving;
            if (teddyBearWaving) {
                teddyBearAnimation = 0; // Reinicia anima√ß√£o
            }
        }

        function toggleDollhouseDoor() {
            dollhouseDoorOpen = !dollhouseDoorOpen;
            dollhouseDoorAnimation = 0; // Reinicia anima√ß√£o
        }

        function toggleAbstractSculpture() {
            abstractSculptureActive = !abstractSculptureActive;
            if (abstractSculptureActive) {
                abstractSculptureAnimation = 0; // Reinicia anima√ß√£o
            }
        }

        function cycleArtifactDisplay() {
            artifactDisplayMode = (artifactDisplayMode + 1) % 4; // Cicla entre 0-3
        }

        function toggleRoboArm() {
            roboArmActive = !roboArmActive;
            if (roboArmActive) {
                roboArmAnimation = 0;
                interactionCounts.roboArm++;
                checkMissions();
            }
        }

        function toggleServer() {
            serverActive = !serverActive;
            if (serverActive) {
                interactionCounts.server++;
                checkMissions();
            }
        }

        function toggleSafetyShower() {
            safetyShowerActive = !safetyShowerActive;
        }

        function toggleChemRack() {
            chemRackActive = !chemRackActive;
            if (chemRackActive) {
                chemRackAnimation = 0;
            }
        }

        function toggleFridge() {
            fridgeActive = !fridgeActive;
        }

        function toggleStove() {
            stoveActive = !stoveActive;
            // Verificar miss√µes ap√≥s intera√ß√£o com fog√£o
            checkMissions();
        }

        function toggleMicrowave() {
            microwaveActive = !microwaveActive;
            if (microwaveActive) {
                interactionCounts.microwave++;
                checkMissions();
            }
        }

        function toggleCoffeeMachine() {
            coffeeMachineActive = !coffeeMachineActive;
            if (coffeeMachineActive) {
                interactionCounts.coffee++;
                checkMissions();
            }
        }

        function toggleSink() {
            sinkActive = !sinkActive;
            if (sinkActive) {
                interactionCounts.sink++;
                checkMissions();
            }
        }

        function toggleArcade() {
            arcadeActive = !arcadeActive;
            if (arcadeActive) {
                arcadeAnimation = 0;
            }
            // Verificar miss√µes ap√≥s intera√ß√£o com arcade
            checkMissions();
        }

        function toggleTV() {
            tvActive = !tvActive;
            if (tvActive) {
                tvChannel = (tvChannel + 1) % 4; // Cicla pelos canais
                interactionCounts.tv++;
                checkMissions();
            }
        }

        function toggleVending() {
            vendingActive = !vendingActive;
            if (vendingActive) {
                interactionCounts.vending++;
                checkMissions();
            }
        }

        function toggleJukebox() {
            jukeboxActive = !jukeboxActive;
            if (jukeboxActive) {
                interactionCounts.jukebox++;
                checkMissions();
            }
        }

        function togglePoolTable() {
            poolTableActive = !poolTableActive;
        }

        function togglePunchingBag() {
            // Inicia o balan√ßo do saco
            punchingBagSwing = 0.5; // √Çngulo inicial de balan√ßo
            interactionCounts.punchingBag++;
            checkMissions();
        }

        function toggleWaterCooler() {
            waterCoolerActive = !waterCoolerActive;
        }

        function toggleTreadmill() {
            treadmillActive = !treadmillActive;
            if (treadmillActive) {
                interactionCounts.treadmill++;
                checkMissions();
            }
        }

        function toggleDumbbells() {
            dumbbellsActive = !dumbbellsActive;
        }

        function toggleMedicineBall() {
            medicineBallActive = !medicineBallActive;
        }

        function toggleMicroscope() {
            microscopeOn = !microscopeOn;
            console.log(`Microsc√≥pio ${microscopeOn ? 'ligado' : 'desligado'}`);
        }

        function toggleFloorLamp() {
            floorLampOn = !floorLampOn;
            console.log(`Lumin√°ria de piso ${floorLampOn ? 'ligada' : 'desligada'}`);
        }

        function toggleDeskLamp() {
            deskLampOn = !deskLampOn;
            console.log(`Lumin√°ria de mesa ${deskLampOn ? 'ligada' : 'desligada'}`);
        }

        function toggleStreetLamp() {
            streetLampOn = !streetLampOn;
            console.log(`Poste de luz ${streetLampOn ? 'ligado' : 'desligado'}`);
        }

        function toggleExhibitLight() {
            exhibitLightOn = !exhibitLightOn;
            console.log(`Lumin√°ria de exposi√ß√£o ${exhibitLightOn ? 'ligada' : 'desligada'}`);
        }

        // --- Sistema de Pontua√ß√£o ---
        function collectItem(collectible) {
            let points = 0;
            switch (collectible.type) {
                case 'üå∂Ô∏è': points = 10; break;
                case 'üé©': points = 25; break;
                case 'üéµ': points = 15; break;
                case 'üé§': points = 20; break;
                case 'üé∏': points = 30; break;
                case '‚ùÑÔ∏è': 
                    points = 50; 
                    shootSnowflake();
                    break;
            }

            playerScore += points;
            collectedItemsCount++; // Incrementar contador de itens coletados

            // Criar part√≠culas de coleta
            createCollectParticles(collectible.x, collectible.y, collectible.type);

            // Efeito visual de coleta
            console.log(`Coletou ${collectible.type} por ${points} pontos!`);
        }

        // --- NOVO SISTEMA DE REPLAY CINEM√ÅTICO ---

        function recordPlayerState() {
            const now = getGameTime();

            // Grava o estado exato (Posi√ß√£o absoluta)
            enemy.history.push({
                x: player.x,
                y: player.y,
                floor: player.floor,
                state: player.state,
                isJumping: player.isJumping, // Visual apenas
                timestamp: now
            });

            // Grava o estado invertido para o inimigo roxo (mesmo delay)
            purpleEnemy.history.push({
                x: -player.x,  // Posi√ß√£o X invertida
                y: player.y,
                floor: player.floor,
                state: player.state,
                isJumping: player.isJumping, // Visual apenas
                timestamp: now
            });

            // Limpeza de buffer (Evita vazamento de mem√≥ria)
            // Se assumirmos 60fps, 3s = 180 frames. Manter buffer de seguran√ßa.
            if (enemy.history.length > 500) {
                enemy.history.shift();
            }
            if (purpleEnemy.history.length > 500) {
                purpleEnemy.history.shift();
            }
        }

        function updateEnemy() {
            // Se o jogo terminou, n√£o atualizar inimigo
            if (gameEnded) return;

            const now = getGameTime();

            // Calcular delay din√¢mico (diminui 2% por segundo, aumenta 5% por item coletado)
            const elapsedSeconds = (now - gameStartTime) / 3000;
            const dynamicDelayTime = enemy.delayTime * Math.pow(0.95, elapsedSeconds) * Math.pow(1.15, collectedItemsCount);

            const targetTime = now - dynamicDelayTime;

            // Se n√£o houver hist√≥rico suficiente ainda, o inimigo fica parado no spawn
            if (enemy.history.length === 0) return;

            // Encontrar o frame mais pr√≥ximo do tempo alvo (targetTime)
            // Otimiza√ß√£o: Procurar de tr√°s para frente ou assumir index linear
            let bestFrame = enemy.history[0];

            for (let i = 0; i < enemy.history.length; i++) {
                const frame = enemy.history[i];
                // Se encontrarmos um frame futuro ao target, o anterior √© o mais pr√≥ximo
                if (frame.timestamp > targetTime) {
                    // Interpola√ß√£o simples: pega o anterior (ou o atual se for o primeiro)
                    bestFrame = (i > 0) ? enemy.history[i - 1] : frame;
                    break;
                }
                // Se chegarmos ao fim e todos s√£o passados, pega o √∫ltimo
                bestFrame = frame;
            }

            // APLICAR ESTADO (Cinem√°tica Pura - Sem F√≠sica)
            // O inimigo n√£o "tenta" se mover, ele √© for√ßado para a posi√ß√£o antiga do player
            if (bestFrame) {
                enemy.x = bestFrame.x;
                enemy.y = bestFrame.y;
                enemy.floor = bestFrame.floor;
                enemy.state = bestFrame.state;
                enemy.isJumping = bestFrame.isJumping;
            }

            // Sempre que o inimigo retornar ao ch√£o, liberamos um novo "ciclo" de detec√ß√£o
            if (!enemy.isJumping) {
                hasPassedUnderEnemyThisEnemyJump = false;
            }

            // Verificar colis√£o continua igual
            checkEnemyPlayerCollision();
        }


        function checkEnemyPlayerCollision() {
            // Verificar colis√£o com o inimigo vermelho
            checkCollisionWithEnemy(enemy);

            // Verificar colis√£o com o inimigo roxo
            checkCollisionWithEnemy(purpleEnemy);
        }

        function checkCollisionWithEnemy(enemyObj) {
            const dx = player.x - enemyObj.x;
            const dy = player.y - enemyObj.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // Verificar se o jogador est√° no mesmo andar que o inimigo
            const sameFloor = player.floor === enemyObj.floor;

            const horizontalDistance = Math.abs(player.x - enemyObj.x);
            const playerRelativeY = player.y - (-player.floor * FLOOR_HEIGHT);
            const enemyRelativeY = enemyObj.y - (-enemyObj.floor * FLOOR_HEIGHT);

            // Verificar se o jogador pulou sobre o inimigo
            if (sameFloor && player.isJumping && !hasJumpedOverEnemyThisJump) {
                // Jogador acima do inimigo e pr√≥ximo horizontalmente
                if (playerRelativeY < enemyRelativeY - 10 && horizontalDistance < 30 && player.velocityY <= 0) {
                    interactionCounts.jumpOverEnemy++;
                    hasJumpedOverEnemyThisJump = true;
                    console.log(`Pulou sobre o inimigo! Total: ${interactionCounts.jumpOverEnemy}/3`);
                    updateMissionsDisplay(); // Atualizar display em tempo real
                }
            }

            // Verificar se o jogador passou POR BAIXO do inimigo enquanto o inimigo est√° pulando
            // Condi√ß√µes: mesmo andar, inimigo pulando, jogador no ch√£o, ainda n√£o contou neste pulo
            if (sameFloor && enemyObj.isJumping && player.isOnGround && !player.isJumping && !hasPassedUnderEnemyThisEnemyJump) {
                // Usar posi√ß√µes absolutas para compara√ß√£o mais confi√°vel
                const playerAbsoluteY = player.y;
                const enemyAbsoluteY = enemyObj.y;

                // Jogador abaixo do inimigo e pr√≥ximo horizontalmente
                // Toler√¢ncia: jogador precisa estar pelo menos 3 pixels abaixo do inimigo
                // e dentro de 50 pixels horizontalmente (bem tolerante)
                const isPlayerBelow = playerAbsoluteY > enemyAbsoluteY + 3;
                const isHorizontallyClose = horizontalDistance < 50;

                if (isPlayerBelow && isHorizontallyClose) {
                    interactionCounts.underEnemyJump++;
                    hasPassedUnderEnemyThisEnemyJump = true;
                    console.log(`‚úÖ Passou por baixo do inimigo em um pulo! Total: ${interactionCounts.underEnemyJump}/2`);
                    console.log(`   Debug: playerY=${playerAbsoluteY.toFixed(1)}, enemyY=${enemyAbsoluteY.toFixed(1)}, diff=${(playerAbsoluteY - enemyAbsoluteY).toFixed(1)}, hDist=${horizontalDistance.toFixed(1)}`);
                    updateMissionsDisplay();
                    checkMissions(); // Verificar se a miss√£o foi completada
                }
            }

            // Resetar flag quando o jogador pousar no ch√£o
            if (player.isOnGround && !player.isJumping) {
                hasJumpedOverEnemyThisJump = false;
            }

            if (distance < 20) { // Dist√¢ncia de colis√£o
                takeDamage();
            }
        }

        function updatePurpleEnemy() {
            // Se o jogo terminou, n√£o atualizar inimigo
            if (gameEnded) return;

            const now = getGameTime();

            // Delay fixo de 1 segundo para o inimigo roxo
            const dynamicDelayTime = 2000;

            const targetTime = now - dynamicDelayTime;

            // Se n√£o houver hist√≥rico suficiente ainda, o inimigo fica parado no spawn
            if (purpleEnemy.history.length === 0) return;

            // Encontrar o frame mais pr√≥ximo do tempo alvo (targetTime)
            // Otimiza√ß√£o: Procurar de tr√°s para frente ou assumir index linear
            let bestFrame = purpleEnemy.history[0];

            for (let i = 0; i < purpleEnemy.history.length; i++) {
                const frame = purpleEnemy.history[i];
                // Se encontrarmos um frame futuro ao target, o anterior √© o mais pr√≥ximo
                if (frame.timestamp > targetTime) {
                    // Interpola√ß√£o simples: pega o anterior (ou o atual se for o primeiro)
                    bestFrame = (i > 0) ? purpleEnemy.history[i - 1] : frame;
                    break;
                }
                // Se chegarmos ao fim e todos s√£o passados, pega o √∫ltimo
                bestFrame = frame;
            }

            // APLICAR ESTADO (Cinem√°tica Pura - Sem F√≠sica)
            // O inimigo roxo usa as coordenadas invertidas diretamente do hist√≥rico
            if (bestFrame) {
                purpleEnemy.x = bestFrame.x;
                purpleEnemy.y = bestFrame.y;
                purpleEnemy.floor = bestFrame.floor;
                purpleEnemy.state = bestFrame.state;
                purpleEnemy.isJumping = bestFrame.isJumping;

                // Sistema de "ch√£o" do inimigo (simulado)
                purpleEnemy.isOnGround = !purpleEnemy.isJumping;
            }
        }

        function takeDamage() {
            // Se o jogo terminou ou est√° no modo explorat√≥rio, n√£o permitir dano
            if (gameEnded || gameMode === 'explore') return;

            // Verificar se o jogador est√° invenc√≠vel
            if (playerInvincible) {
                return; // N√£o tomar dano se estiver invenc√≠vel
            }

            // Verificar se o jogador ainda n√£o fez o primeiro movimento (modo jogo)
            if (gameMode === 'game' && !hasMadeFirstMove) {
                console.log('Protegido! Fa√ßa seu primeiro movimento para iniciar o jogo.');
                return; // N√£o tomar dano at√© fazer o primeiro movimento
            }

            playerLives--;
            console.log(`Dano recebido! Vidas restantes: ${playerLives}`);

            // Ativar invencibilidade
            playerInvincible = true;
            playerInvincibilityStart = getGameTime();

            // Atualizar barra de vida visual
            updateHealthBar();

            // Criar part√≠culas de dano
            createDamageParticles(player.x, player.y);

            if (playerLives <= 0) {
                gameOver();
            }
        }

        function updateHealthBar() {
            const healthBarElement = document.getElementById('healthBar');
            if (healthBarElement) {
                const hearts = '‚ù§Ô∏è'.repeat(playerLives);
                const emptyHearts = 'üíî'.repeat(3 - playerLives);
                healthBarElement.innerHTML = hearts + emptyHearts;
            }
        }

        function updateEnemyDelayDisplay() {
            const delayElement = document.getElementById('enemyDelay');
            if (delayElement) {
                if (gameMode === 'explore') {
                    delayElement.style.display = 'none';
                } else {
                    const elapsedSeconds = (getGameTime() - gameStartTime) / 1000;
                    const currentDelay = enemy.delayTime * Math.pow(0.95, elapsedSeconds) * Math.pow(1.15, collectedItemsCount);
                    const delayInSeconds = currentDelay / 1000;
                    delayElement.innerHTML = `Delay: ${delayInSeconds.toFixed(4).replace('.', ',')}s`;
                    delayElement.style.display = 'inline-block';
                }
            }
        }

        function updateInvincibility() {
            if (playerInvincible) {
                const currentTime = getGameTime();
                const elapsedTime = currentTime - playerInvincibilityStart;

                if (elapsedTime >= playerInvincibilityDuration) {
                    // Tempo de invencibilidade acabou
                    playerInvincible = false;
                }
            }
        }

        function createDamageParticles(x, y) {
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6 - 2,
                    life: 30,
                    maxLife: 30,
                    color: '#ff0000',
                    size: 3 + Math.random() * 2
                });
            }
        }

        function gameOver() {
            console.log('GAME OVER!');

            // Criar tela de game over
            const gameOverDiv = document.createElement('div');
            gameOverDiv.id = 'gameOverScreen';
            gameOverDiv.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                z-index: 10000;
                color: white;
                font-family: Arial, sans-serif;
                text-align: center;
            `;

            gameOverDiv.innerHTML = `
                <div style="font-size: 4rem; color: #ff0000; margin-bottom: 20px; text-shadow: 2px 2px 4px #000;">üíÄ GAME OVER üíÄ</div>
                <div style="font-size: 1.5rem; margin-bottom: 30px;">O perseguidor te alcan√ßou!</div>
                <div style="font-size: 1.2rem; margin-bottom: 40px;">Pontua√ß√£o Final: ${playerScore}</div>
                <button id="restartButton" style="
                    padding: 15px 30px;
                    font-size: 1.2rem;
                    background: #ff0000;
                    color: white;
                    border: none;
                    border-radius: 5px;
                    cursor: pointer;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                ">Reiniciar Jogo</button>
            `;

            document.body.appendChild(gameOverDiv);

            // Adicionar evento de clique no bot√£o de restart (volta ao menu inicial com reset completo)
            document.getElementById('restartButton').addEventListener('click', function() {
                // Reset completo do jogo - parar tudo e voltar ao in√≠cio
                completeGameReset();
            });
        }

        function restartGame() {
            // Reset do jogo
            playerLives = 3;
            playerScore = 0;
            collectedItemsCount = 0;

            // Reset das miss√µes
            missions.jumpOverEnemy.completed = false;
            missions.arcade.completed = false;
            missions.tvToBedroom.completed = false;
            missions.stove.completed = false;

            // Reset do sistema de miss√µes sequenciais
            missionQueue = [];
            currentMission = null;
            completedMissionsCount = 0;

            // Reset dos estados dos objetos
            arcadeActive = false;
            tvActive = false;
            stoveActive = false;
            microscopeOn = true; // Microsc√≥pio come√ßa ligado
            player.x = 0;
            player.y = 0;
            player.floor = 0;
            player.state = 'idle';
            player.currentSpeed = 0;
            player.isJumping = false;
            player.isOnGround = true;

            // Reset de invencibilidade
            playerInvincible = false;
            playerInvincibilityStart = 0;

            // Reset do sistema de primeiro movimento
            hasMadeFirstMove = false;

            // Reset do tempo de jogo
            gameStartTime = getGameTime();

            // Reset dos inimigos
            enemy.x = 0;
            enemy.y = 0;
            enemy.floor = 0;
            enemy.state = 'idle';
            enemy.history = [];
            enemy.isJumping = false;

            purpleEnemy.x = 0;
            purpleEnemy.y = 0;
            purpleEnemy.floor = 0;
            purpleEnemy.state = 'idle';
            purpleEnemy.history = [];
            purpleEnemy.isJumping = false;

            // Reset dos colet√°veis (opcional - pode manter ou resetar)
            // collectibles = []; // Descomente se quiser resetar os itens

            // Atualizar barra de vida
            updateHealthBar();

            // Atualizar display das miss√µes
            updateMissionsDisplay();

            // Resetar exibi√ß√£o da miss√£o na parte inferior
            if (gameMode === 'game') {
                document.getElementById('missionBottomDisplay').style.display = 'block';
            }

            // Remover tela de game over
            const gameOverScreen = document.getElementById('gameOverScreen');
            if (gameOverScreen) {
                gameOverScreen.remove();
            }

            console.log('Jogo reiniciado!');
        }

        function createCollectParticles(x, y, itemType) {
            // Criar 8-12 part√≠culas coloridas
            const particleCount = 8 + Math.floor(Math.random() * 5);
            const colors = ['#ffff00', '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7', '#fdcb6e', '#e17055'];

            for (let i = 0; i < particleCount; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 8, // Velocidade horizontal aleat√≥ria
                    vy: (Math.random() - 0.5) * 8, // Velocidade vertical aleat√≥ria
                    life: 60, // Dura√ß√£o em frames (1 segundo a 60fps)
                    maxLife: 60,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    size: 2 + Math.random() * 3
                });
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];

                // Atualizar posi√ß√£o
                particle.x += particle.vx;
                particle.y += particle.vy;

                // Aplicar leve gravidade
                particle.vy += 0.1;

                // Reduzir velocidade (fric√ß√£o)
                particle.vx *= 0.98;
                particle.vy *= 0.98;

                // Reduzir vida
                particle.life--;

                // Remover part√≠cula morta
                if (particle.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function checkCollectibleCollisions() {
            for (let i = collectibles.length - 1; i >= 0; i--) {
                const collectible = collectibles[i];
                if (!collectible.collected) {
                    // Calcular dist√¢ncia entre jogador e item
                    const dx = player.x - collectible.x;
                    const dy = player.y - collectible.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < 25) { // Dist√¢ncia de coleta reduzida
                        collectItem(collectible);
                        collectibles.splice(i, 1); // Remover da lista
                    }
                }
            }
        }


        function resize() {
            viewW = window.innerWidth;
            viewH = window.innerHeight;

            DPR = window.devicePixelRatio || 1;
            // evita buffers gigantes em alguns devices
            DPR = Math.min(DPR, 3);

            // mant√©m o canvas com tamanho visual correto
            canvas.style.width = viewW + 'px';
            canvas.style.height = viewH + 'px';

            // buffer interno em device pixels (n√≠tido)
            canvas.width = Math.round(viewW * DPR);
            canvas.height = Math.round(viewH * DPR);

            // desenhar usando coordenadas em CSS pixels
            ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
            ctx.imageSmoothingEnabled = false;
        }

        function onKeyDown(e) {
            const currentTime = getGameTime();

            // Controle de pause (tecla Enter)
            if (e.code === 'Enter') {
                togglePause();
                e.preventDefault();
                return;
            }
if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
                keys.left = true;
                detectDoubleClick('left', currentTime);
                // Primeiro movimento lateral - iniciar invencibilidade
                if (!hasMadeFirstMove && gameMode === 'game') {
                    hasMadeFirstMove = true;
                    playerInvincible = true;
                    playerInvincibilityStart = currentTime;
                    updateProtectionIndicator(); // Ocultar indicador
                    console.log('Invencibilidade inicial ativada! Voc√™ tem 1 segundo de prote√ß√£o.');
                }
            }
            if (e.code === 'ArrowRight' || e.code === 'KeyD') {
                keys.right = true;
                detectDoubleClick('right', currentTime);
                // Primeiro movimento lateral - iniciar invencibilidade
                if (!hasMadeFirstMove && gameMode === 'game') {
                    hasMadeFirstMove = true;
                    playerInvincible = true;
                    playerInvincibilityStart = currentTime;
                    updateProtectionIndicator(); // Ocultar indicador
                    console.log('Invencibilidade inicial ativada! Voc√™ tem 1 segundo de prote√ß√£o.');
                }
            }
            // UP = apenas subir andar (escadas/elevador). N√ÉO pula mais.
            if (e.code === 'ArrowUp' || e.code === 'KeyW') {
                keys.up = true;

                const inElevator = Math.abs(player.x - ELEVATOR_X) < ELEVATOR_WIDTH / 2;
                const inStairs = Math.abs(player.x - STAIRS_X) < STAIRS_WIDTH / 2;

                if (inElevator || inStairs) {
                    attemptVerticalMove(1);
                }
            }
            // DOWN = descer andar (escadas/elevador)
            if (e.code === 'ArrowDown' || e.code === 'KeyS') {
                keys.down = true;

                const inElevator = Math.abs(player.x - ELEVATOR_X) < ELEVATOR_WIDTH / 2;
                const inStairs = Math.abs(player.x - STAIRS_X) < STAIRS_WIDTH / 2;

                if (inElevator || inStairs) {
                    attemptVerticalMove(-1);
                }
            }
            // X = interagir
            if (e.code === 'KeyX') {
                attemptInteract();
            }
            // Z = pular
            if (e.code === 'KeyZ') {
                attemptJump();
            }
            // C = pegar/soltar
            if (e.code === 'KeyC') {
                attemptPickupOrDrop();
            }
            if (e.code === 'Space') {
                attemptDash();
            }
        }

        function onKeyUp(e) {
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
            if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
            if (e.code === 'ArrowUp' || e.code === 'KeyW') keys.up = false;
            if (e.code === 'ArrowDown' || e.code === 'KeyS') keys.down = false;

            // Resetar corrida quando teclas s√£o soltas
            if (!keys.left && !keys.right) {
                player.isRunning = false;
            }
        }

        function attemptVerticalMove(direction) {
            if (player.state !== 'idle') return;
            const inElevator = Math.abs(player.x - ELEVATOR_X) < ELEVATOR_WIDTH / 2;
            const inStairs = Math.abs(player.x - STAIRS_X) < STAIRS_WIDTH / 2;
            if (inElevator || inStairs) {
                const nextFloor = player.floor + direction;
                player.floor = nextFloor;
                player.targetY = -nextFloor * FLOOR_HEIGHT;
                player.state = 'moving_v';
                getOrGenerateFloor(nextFloor);
            }
        }

        function shootSnowflake() {
            // Atirar em dire√ß√£o ao inimigo
            const dx = enemy.x - player.x;
            const dy = (enemy.y - enemy.floor * FLOOR_HEIGHT) - (player.y - player.floor * FLOOR_HEIGHT);
            const angle = Math.atan2(dy, dx);
            const speed = 8;

            projectiles.push({
                x: player.x,
                y: player.y,
                floor: player.floor,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                type: 'snowflake',
                life: 120 // frames
            });
            console.log("Floco de neve disparado!");
        }

        function updateProjectiles() {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;

                // Verificar colis√£o com o inimigo
                const dx = p.x - enemy.x;
                const dy = p.y - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 20) {
                    // S√≥ aplica se for o proj√©til do floco de neve
                    if (p.type === 'snowflake') {
                        const now = getGameTime();
                        const elapsedSeconds = (now - gameStartTime) / 1000;

                        const scale =
                            Math.pow(0.95, elapsedSeconds) *
                            Math.pow(1.15, collectedItemsCount);

                        // Queremos +1s REAL no delay din√¢mico atual
                        enemy.delayTime += 500 / scale;

                        console.log("Inimigo atingido! Delay din√¢mico aumentado em +1s (real).");
                    }
                    
                    // Part√≠culas de impacto azul
                    for(let j=0; j<10; j++) {
                        particles.push({
                            x: p.x, y: p.y,
                            vx: (Math.random() - 0.5) * 4,
                            vy: (Math.random() - 0.5) * 4,
                            life: 30, maxLife: 30,
                            color: '#00e5ff',
                            size: 2 + Math.random() * 3
                        });
                    }
                    
                    projectiles.splice(i, 1);
                    continue;
                }

                if (p.life <= 0) {
                    projectiles.splice(i, 1);
                }
            }
        }

        function update() {
            // Se o jogo terminou ou est√° pausado, n√£o atualizar
            if (gameEnded || gamePaused) return;

            // Poll do gamepad (a cada frame)
            pollGamepad();
            const input = resolveInput();

            // Sistema de acelera√ß√£o e corrida
            let targetSpeed = 0;
            let maxSpeed = player.speed;

            if (player.isRunning) {
                maxSpeed = player.maxSpeed;
            }

            // Atualizar estado de Dash
            const now = getGameTime();
            if (player.isDashing) {
                if (now > player.dashTime) {
                    player.isDashing = false;
                } else {
                    // Durante o dash, manter velocidade alta
                    targetSpeed = player.currentSpeed;
                }
            }

            // S√≥ permitir controle de dire√ß√£o quando no ch√£o
            if (player.isOnGround) {
                if (input.left) {
                    targetSpeed = -maxSpeed;
                } else if (input.right) {
                    targetSpeed = maxSpeed;
                }
            }

            // Acelera√ß√£o/desacelera√ß√£o suave
            if (targetSpeed !== 0) {
                if (Math.abs(player.currentSpeed - targetSpeed) < player.acceleration) {
                    player.currentSpeed = targetSpeed;
                } else if (player.currentSpeed < targetSpeed) {
                    player.currentSpeed += player.acceleration;
                } else {
                    player.currentSpeed -= player.acceleration;
                }
            } else {
                // Desacelera√ß√£o quando n√£o h√° input
                if (Math.abs(player.currentSpeed) < player.deceleration) {
                    player.currentSpeed = 0;
                } else if (player.currentSpeed > 0) {
                    player.currentSpeed -= player.deceleration;
                } else {
                    player.currentSpeed += player.deceleration;
                }
            }

            // Resetar estado de corrida se n√£o estiver se movendo
            if (Math.abs(player.currentSpeed) < 0.1) {
                player.isRunning = false;
            }

            // Aplicar movimento horizontal
            if (player.state === 'idle') {
                if (player.isOnGround) {
                    // Movimento normal no ch√£o
                    player.x += player.currentSpeed;
                    // Armazenar velocidade para o pulo
                    player.jumpHorizontalSpeed = player.currentSpeed;

                } else if (player.isJumping) {
                    // Usar velocidade armazenada durante pulo (in√©rcia pura)
                    player.x += player.jumpHorizontalSpeed;
                }

                // Limitar movimento dentro dos limites do pr√©dio
                const limit = (BUILDING_WIDTH / 2) - 20;
                if (player.x < -limit) player.x = -limit;
                if (player.x > limit) player.x = limit;
            }

            // F√≠sica de pulo
            if (player.isJumping || !player.isOnGround) {
                // Aplicar gravidade
                player.velocityY += player.gravity;
                player.y += player.velocityY;

                // Verificar colis√£o com o ch√£o
                const currentFloorY = -player.floor * FLOOR_HEIGHT;
                if (player.y >= currentFloorY) {
                    player.y = currentFloorY;
                    player.velocityY = 0;
                    player.isJumping = false;
                    player.isOnGround = true;
                }
            } else if (player.state === 'idle') {
                // Manter jogador no ch√£o quando n√£o est√° pulando
                const currentFloorY = -player.floor * FLOOR_HEIGHT;
                player.y = currentFloorY;
                player.isOnGround = true;
            }
            if (player.state === 'moving_v') {
                const dy = player.targetY - player.y;
                player.y += dy * 0.15;
                if (Math.abs(dy) < 1) {
                    player.y = player.targetY;
                    player.state = 'idle';
                }
            }
            camera.y += (player.y - camera.y) * 0.1;
            camera.x += (player.x - camera.x) * 0.12; // camera segue o player no eixo X

            // Atualizar sistema de part√≠culas
            updateParticles();

            // Atualizar proj√©teis
            updateProjectiles();

            // Verificar colis√µes autom√°ticas com itens colet√°veis
            checkCollectibleCollisions();

            // Atualizar estado de invencibilidade
            updateInvincibility();

            // Grava√ß√£o de estado do jogador (frame-by-frame)
            recordPlayerState();

            // Atualizar inimigos
            updateEnemy();
            updatePurpleEnemy();

            document.getElementById('floorDisplay').innerText = player.floor;

            // Atualizar barra de vida
            updateHealthBar();

            // Atualizar display do delay do inimigo
            updateEnemyDelayDisplay();

            const currentFloorData = floors.get(player.floor);
            if (currentFloorData) {
                const currentSector = getCurrentSector();
                const nearbyObjects = getNearbyObjects();

                let displayText = '';

                // Mostrar objetos pr√≥ximos acima do nome do setor
                if (nearbyObjects.length > 0) {
                    const objectNames = nearbyObjects.map(obj => obj.name);
                    displayText += objectNames.join(', ') + '<br>';
                }

                // Mostrar nome do setor atual
                if (currentSector) {
                    displayText += ROOM_THEMES[currentSector.theme].label;
                } else {
                    displayText += 'Corredor';
                }

                document.getElementById('roomDisplay').innerHTML = displayText;
                const totalItems = currentFloorData.sectors.reduce((sum, s) => sum + s.items.length, 0);
                document.getElementById('objCount').innerText = totalItems;
            }

            // Atualizar display da pontua√ß√£o
            document.getElementById('scoreDisplay').innerText = playerScore;

            // Atualizar anima√ß√µes interativas
            if (teddyBearWaving) {
                teddyBearAnimation += 0.02; // Progresso da anima√ß√£o
                if (teddyBearAnimation >= 1) {
                    teddyBearWaving = false; // Termina a anima√ß√£o
                    teddyBearAnimation = 0;
                }
            }

            // Anima√ß√£o da porta da casa de boneca
            const targetDollhouseDoorAnimation = dollhouseDoorOpen ? 1 : 0;
            dollhouseDoorAnimation += (targetDollhouseDoorAnimation - dollhouseDoorAnimation) * 0.1;

            // Anima√ß√£o da escultura abstrata
            if (abstractSculptureActive) {
                abstractSculptureAnimation += 0.015; // Progresso cont√≠nuo
                if (abstractSculptureAnimation >= 1) {
                    abstractSculptureAnimation = 0; // Loop infinito
                }
            }

            // Anima√ß√£o do bra√ßo rob√¥
            if (roboArmActive) {
                roboArmAnimation += 0.02;
                if (roboArmAnimation >= 1) {
                    roboArmAnimation = 0; // Loop
                }
            }

            // Anima√ß√£o do rack qu√≠mico
            if (chemRackActive) {
                chemRackAnimation += 0.015;
                if (chemRackAnimation >= 1) {
                    chemRackAnimation = 0; // Loop
                }
            }

            // Anima√ß√£o do fliperama
            if (arcadeActive) {
                arcadeAnimation += 0.03;
                if (arcadeAnimation >= 1) {
                    arcadeAnimation = 0; // Loop
                }
            }


        }

        function getOrGenerateFloor(index) {
            if (floors.has(index)) return floors.get(index);

            if (!usedThemesPerFloor.has(index)) {
                usedThemesPerFloor.set(index, new Set());
            }
            const usedThemesThisFloor = usedThemesPerFloor.get(index);

            // Coletar temas usados no andar logo abaixo (andar anterior) - PRIORIDADE M√ÅXIMA
            const usedThemesBelow = new Set();
            const belowFloorIndex = index - 1;
            if (usedThemesPerFloor.has(belowFloorIndex)) {
                usedThemesPerFloor.get(belowFloorIndex).forEach(theme => usedThemesBelow.add(theme));
            }

            // Tamb√©m verificar andar 2 abaixo para padr√µes mais amplos
            const usedThemesTwoBelow = new Set();
            const twoBelowFloorIndex = index - 2;
            if (usedThemesPerFloor.has(twoBelowFloorIndex)) {
                usedThemesPerFloor.get(twoBelowFloorIndex).forEach(theme => usedThemesTwoBelow.add(theme));
            }

            const startX = ELEVATOR_X + (ELEVATOR_WIDTH/2) + 10;
            const endX = STAIRS_X - (STAIRS_WIDTH/2) - 10;
            const totalWidth = endX - startX;
            const numSectors = (Math.random() > 0.6 || Math.abs(index) < 2) ? 2 : 3;
            const sectors = [];
            const sectorWidth = totalWidth / numSectors;

            for (let i = 0; i < numSectors; i++) {
                let themeKey;
                if (index === 0 && i === 0) {
                    themeKey = 'reception';
                } else {
                    // SISTEMA DE DISTRIBUI√á√ÉO EQUILIBRADA - TODOS OS SETORES COM FREQU√äNCIA IGUAL

                    // 1. DEFINIR TEMAS DISPON√çVEIS POR TIPO DE ANDAR
                    let allThemes;
                    if (index < 0) {
                        allThemes = ['storage', 'lab', 'gym', 'bathroom', 'playground', 'music_room', 'bar', 'clothing_store', 'museum'];
                    } else {
                        allThemes = ['reception', 'living', 'kitchen', 'bedroom', 'gym', 'office', 'garden', 'lab', 'bathroom', 'playground', 'music_room', 'bar', 'clothing_store', 'museum'];
                    }

                    // 2. FILTRAR TEMAS QUE RESPEITAM ANTI-REPETI√á√ÉO
                    let validThemes = allThemes.filter(theme => {
                        // NUNCA repetir no mesmo andar
                        if (usedThemesThisFloor.has(theme)) return false;

                        // NUNCA repetir no andar logo abaixo
                        if (usedThemesBelow.has(theme)) return false;

                        // Reception s√≥ no t√©rreo
                        if (theme === 'reception' && index > 0) return false;

                        return true;
                    });

                    // 3. SE N√ÉO H√Å TEMAS V√ÅLIDOS, RELAXAR RESTRI√á√ÉO DO ANDAR ABAIXO
                    if (validThemes.length === 0) {
                        validThemes = allThemes.filter(theme => {
                            if (usedThemesThisFloor.has(theme)) return false;
                            if (theme === 'reception' && index > 0) return false;
                            return true;
                        });
                    }

                    // 4. √öLTIMO RECURSO: QUALQUER TEMA DISPON√çVEL
                    if (validThemes.length === 0) {
                        validThemes = allThemes.filter(theme => {
                            if (usedThemesThisFloor.has(theme)) return false;
                            if (theme === 'reception' && index !== 0) return false;
                            return true;
                        });
                    }

                    // 5. SISTEMA DE FREQU√äNCIA EQUILIBRADA
                    if (validThemes.length > 1) {
                        // Contar frequ√™ncia atual de cada tema v√°lido
                        const frequencyCount = {};
                        validThemes.forEach(theme => frequencyCount[theme] = 0);

                        // Contar apari√ß√µes em todos os andares j√° gerados
                        for (const [floorIdx, floorData] of floors) {
                            if (floorData && floorData.sectors) {
                                floorData.sectors.forEach(sector => {
                                    if (validThemes.includes(sector.theme)) {
                                        frequencyCount[sector.theme]++;
                                    }
                                });
                            }
                        }

                        // Calcular score baseado na frequ√™ncia (menos frequente = melhor score)
                        const themeScores = validThemes.map(theme => ({
                            theme,
                            frequency: frequencyCount[theme],
                            score: -frequencyCount[theme] // Negativo para que menor frequ√™ncia = maior score
                        }));

                        // Ordenar por score (menor frequ√™ncia primeiro)
                        themeScores.sort((a, b) => b.score - a.score);

                        // Pegar os temas com menor frequ√™ncia (top 40% ou pelo menos 2)
                        const bestCandidates = themeScores.slice(0, Math.max(2, Math.ceil(themeScores.length * 0.4)));

                        // Escolher aleatoriamente entre os melhores candidatos
                        themeKey = bestCandidates[Math.floor(Math.random() * bestCandidates.length)].theme;
                    } else if (validThemes.length === 1) {
                        themeKey = validThemes[0];
                    } else {
                        // Fallback de emerg√™ncia
                        themeKey = index < 0 ? 'storage' : 'living';
                    }
                }

                usedThemesThisFloor.add(themeKey);

                const sStart = startX + (i * sectorWidth);
                const sEnd = startX + ((i + 1) * sectorWidth);
                const items = generateFurnitureForSector(themeKey, sStart + 10, sEnd - 10);
                const sectorSeed = Math.random() * 10000;

                sectors.push({
                    theme: themeKey,
                    items: items,
                    startX: sStart,
                    endX: sEnd,
                    width: sectorWidth,
                    seed: sectorSeed
                });
            }

            // Gerar itens colet√°veis flutuantes aleat√≥rios
            const numCollectibles = Math.floor(Math.random() * 3) + 1; // 1-3 itens por andar
            for (let i = 0; i < numCollectibles; i++) {
                const collectibleTypes = ['üå∂Ô∏è', 'üé©', 'üéµ', 'üé§', 'üé∏', '‚ùÑÔ∏è'];
                const randomType = collectibleTypes[Math.floor(Math.random() * collectibleTypes.length)];
                const randomX = startX + Math.random() * totalWidth;
                const randomY = -index * FLOOR_HEIGHT - 50 - Math.random() * 100; // Altura vari√°vel

                collectibles.push({
                    type: randomType,
                    x: randomX,
                    y: randomY,
                    collected: false,
                    floatOffset: Math.random() * Math.PI * 2 // Para anima√ß√£o flutuante
                });
            }

            const floorData = { sectors: sectors, index: index };
            floors.set(index, floorData);
            return floorData;
        }

        function generateFurnitureForSector(theme, startX, endX) {
            const items = [];
            let cx = startX;
            const add = (type, x, yOff=0) => items.push({ type, x, yOff });

            const tabletops = {
                reception: ['computer', 'coffee_machine', 'desk_lamp'],
                living: ['coffee_machine', 'tv'], 
                bedroom: ['desk_lamp'],
                kitchen: ['microwave', 'coffee_machine'],
                lab: ['microscope', 'computer'],
                office: ['computer', 'printer', 'desk_lamp'],
                storage: ['box_pile'],
                gym: ['water_cooler'] 
            };

            const map = {
                reception: ['desk', 'chair', 'plant', 'sofa', 'water_cooler', 'info_kiosk', 'waiting_bench'],
                living: ['plant', 'tv_stand', 'sofa', 'bookshelf', 'arcade', 'floor_lamp', 'coffee_table', 'painting', 'speaker'],
                bedroom: ['bed', 'desk', 'chair', 'nightstand', 'wardrobe', 'mirror', 'bunk_bed'],
                kitchen: ['fridge', 'stove', 'table', 'chair', 'trash_can', 'sink', 'vending', 'stool'],
                gym: ['treadmill', 'weights', 'punching_bag', 'locker', 'bench_press', 'water_cooler', 'dumbbells', 'medicine_ball', 'resistance_bands', 'foam_roller', 'kettlebell', 'pull_up_bar', 'ankle_weights', 'hand_grips', 'massage_ball', 'protein_shaker'],
                lab: ['server', 'lab_table', 'chem_rack', 'safety_shower', 'robo_arm', 'equations_board'], 
                office: ['desk', 'chair', 'filing_cabinet', 'whiteboard', 'meeting_table', 'coat_rack', 'water_cooler', 'bookshelf'],
                garden: ['plant', 'garden_bench', 'fountain', 'bush', 'statue', 'street_lamp'],
                bathroom: ['toilet', 'sink', 'shower', 'bathtub', 'medicine_cabinet', 'laundry_basket', 'towel_rack'],
                playground: ['swing', 'slide', 'seesaw', 'dollhouse', 'sandbox', 'jungle_gym', 'spring_rider', 'ball_pit', 'teddy_bear', 'tire_swing'],
                music_room: ['piano', 'violin', 'guitar', 'drum_set', 'saxophone', 'trumpet', 'acoustic_guitar', 'keyboard', 'desk', 'meeting_table'],
                bar: ['bar_counter', 'stool', 'beer_taps', 'bottles_rack', 'jukebox', 'pool_table', 'dart_board', 'neon_signs'],
                clothing_store: ['desk', 'clothing_rack', 'cash_register', 'mannequins', 'fitting_rooms', 'shoe_rack', 'mirror_wall', 'display_window', 'hangers_rack'],
                museum: ['classical_statue', 'ancient_painting', 'artifact_display', 'marble_bust', 'abstract_sculpture', 'art_installation', 'decorative_pedestal', 'exhibit_light'],
                storage: ['box_pile', 'barrel', 'crate', 'pallet_jack', 'tool_cabinet', 'bookshelf']
            };

            const assets = [...(map[theme] || map['storage'])];
            const possibleTops = tabletops[theme] || [];
            const usedObjects = new Set();
            const supports = [];

            // Refinamento: Garantir que superf√≠cies apare√ßam se houver itens de topo poss√≠veis
            if (possibleTops.length > 0) {
                const surfaceTypes = assets.filter(a => SPECS[a] && SPECS[a].surfaceHeight);
                if (surfaceTypes.length > 0) {
                    // Injetar superf√≠cies no in√≠cio para garantir que sejam processadas
                    for (let i = 0; i < 2; i++) {
                        assets.unshift(surfaceTypes[i % surfaceTypes.length]);
                    }
                }
            }

            // Fase 1: Gerar m√≥veis base e coletar suportes
            let baseCount = 0; // Contador de m√≥veis base colocados
            while (cx < endX - 20) {
                const availableAssets = assets.filter(asset => !usedObjects.has(asset));
                if (availableAssets.length === 0 && usedObjects.size > 0) {
                     usedObjects.clear();
                     continue;
                } else if (availableAssets.length === 0) {
                    break;
                }

                // Sele√ß√£o fit-aware: filtra apenas os que cabem
                const fitAssets = availableAssets.filter(a => {
                    const sp = SPECS[a];
                    return sp && (cx + sp.w < endX);
                });

                if (fitAssets.length === 0) break;

                // Sele√ß√£o ponderada por raridade (compensa itens eleg√≠veis em poucos temas)
                const type = weightedPickBase(fitAssets);
                usedObjects.add(type);
                const spec = SPECS[type];

                const centerX = cx + spec.w / 2;
                add(type, centerX);
                baseCount++; // Incrementa contador de m√≥veis base
                baseCounts[type] = (baseCounts[type] || 0) + 1; // Incrementa contador global para pondera√ß√£o

                if (type === 'tv_stand') {
                    add('tv', centerX, spec.surfaceHeight);
                }
                else if (type === 'bar_counter' && Math.random() > 0.6) {
                    add('cash_register', centerX, spec.surfaceHeight || 12);
                }

                if (spec.surfaceHeight) {
                    supports.push({ x: centerX, yOff: spec.surfaceHeight });
                }

                cx += spec.w + 20 + (Math.random() * 20);
            }

            // Fase 2: Colocar tops proporcionalmente
            if (possibleTops.length > 0 && supports.length > 0) {
                // F√≥rmula matem√°tica para proporcionalidade real
                // K = min(S, max(1, round((N * T) / A)))
                // Onde: N = baseCount, A = assets.length, T = possibleTops.length, S = supports.length
                const A = assets.length;
                const T = possibleTops.length;
                const S = supports.length;

                const K = Math.min(
                    S,
                    Math.max(1, Math.round((baseCount * T) / A))
                );

                // Pegar K suportes distintos
                const shuffled = supports.sort(() => Math.random() - 0.5);
                const chosenSupports = shuffled.slice(0, K);

                for (const s of chosenSupports) {
                    const topType = weightedPick(possibleTops);
                    topCounts[topType] = (topCounts[topType] || 0) + 1; // Incrementa contador global para pondera√ß√£o
                    if (topType !== 'tv') {
                        add(topType, s.x, s.yOff);
                    }
                }
            }

            // Special logic for clothing_store: place cash_register on bar_counter
            if (theme === 'clothing_store') {
                const barCounterIndex = items.findIndex(item => item.type === 'bar_counter');
                const cashRegisterIndex = items.findIndex(item => item.type === 'cash_register');

                if (barCounterIndex !== -1 && cashRegisterIndex !== -1) {
                    // Remove the cash_register from its current position
                    const cashRegister = items.splice(cashRegisterIndex, 1)[0];
                    // Place it on top of the bar_counter
                    const barCounter = items[barCounterIndex];
                    cashRegister.x = barCounter.x;
                    cashRegister.yOff = SPECS['bar_counter'].surfaceHeight || SPECS['bar_counter'].h;
                    // Add it back to items
                    items.push(cashRegister);
                }
            }

            return items;
        }

        // --- Helpers de Renderiza√ß√£o ---

        function drawRoundRect(x, y, w, h, radius, col) {
            const screenX = (CW() / 2) + x - camera.x;
            const screenY = (CH() / 2) + y - camera.y;
            if (screenY > CH() + 100 || screenY + h < -100) return;

            ctx.fillStyle = col;
            ctx.beginPath();
            if (typeof ctx.roundRect === 'function') {
                ctx.roundRect(screenX, screenY, w, h, radius);
            } else {
                ctx.rect(screenX, screenY, w, h);
            }
            ctx.fill();
        }

        function drawRect(x, y, w, h, col) {
            drawRoundRect(x, y, w, h, 0, col);
        }

        function drawCircle(x, y, r, col) {
            const screenX = (CW() / 2) + x - camera.x;
            const screenY = (CH() / 2) + y - camera.y;
            ctx.fillStyle = col;
            ctx.beginPath();
            ctx.arc(screenX, screenY, r, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawHeart(x, y, size, col, alpha = 1) {
            const screenX = (CW() / 2) + x - camera.x;
            const screenY = (CH() / 2) + y - camera.y;

            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.fillStyle = col;

            const s = size;
            // Cora√ß√£o simples por curvas (baseado em bezier), centrado em (screenX, screenY)
            ctx.beginPath();
            ctx.moveTo(screenX, screenY + s * 0.3);
            ctx.bezierCurveTo(screenX - s, screenY - s * 0.5, screenX - s * 0.8, screenY - s * 1.2, screenX, screenY - s * 0.55);
            ctx.bezierCurveTo(screenX + s * 0.8, screenY - s * 1.2, screenX + s, screenY - s * 0.5, screenX, screenY + s * 0.3);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }



        function drawEllipse(x, y, rx, ry, col) {
            const screenX = (CW() / 2) + x - camera.x;
            const screenY = (CH() / 2) + y - camera.y;
            ctx.fillStyle = col;
            ctx.beginPath();
            ctx.ellipse(screenX, screenY, rx, ry, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawTriangle(x1, y1, x2, y2, x3, y3, col) {
            const sx1 = (CW() / 2) + x1 - camera.x;
            const sy1 = (CH() / 2) + y1 - camera.y;
            const sx2 = (CW() / 2) + x2 - camera.x;
            const sy2 = (CH() / 2) + y2 - camera.y;
            const sx3 = (CW() / 2) + x3 - camera.x;
            const sy3 = (CH() / 2) + y3 - camera.y;
            ctx.fillStyle = col;
            ctx.beginPath();
            ctx.moveTo(sx1, sy1);
            ctx.lineTo(sx2, sy2);
            ctx.lineTo(sx3, sy3);
            ctx.closePath();
            ctx.fill();
        }

        function drawLine(x1, y1, x2, y2, width, col) {
            const sx1 = (CW() / 2) + x1 - camera.x;
            const sy1 = (CH() / 2) + y1 - camera.y;
            const sx2 = (CW() / 2) + x2 - camera.x;
            const sy2 = (CH() / 2) + y2 - camera.y;
            ctx.strokeStyle = col;
            ctx.lineWidth = width;
            ctx.beginPath();
            ctx.moveTo(sx1, sy1);
            ctx.lineTo(sx2, sy2);
            ctx.stroke();
        }

        function drawText(txt, x, y, size, col, align = 'center') {
            const screenX = (CW() / 2) + x - camera.x;
            const screenY = (CH() / 2) + y - camera.y;
            ctx.fillStyle = col;
            ctx.font = `bold ${size}px Consolas`;
            ctx.textAlign = align;
            ctx.fillText(txt, screenX, screenY);
        }

        function pseudoRandom(seed) {
            var x = Math.sin(seed++) * 10000;
            return x - Math.floor(x);
        }

        // --- Renderiza√ß√£o de Itens Detalhados ---

        function drawDetailedItem(item, floorY, seed) {
            const s = SPECS[item.type];
            if (!s) return;
            
            let y = floorY - s.h - (item.yOff || 0);
            if (s.wall) y -= 30;
            if (item.type === 'punching_bag') y = floorY - 90;

            const cx = item.x;
            const left = cx - s.w/2;
            const right = cx + s.w/2;
            const time = getGameTime();

            // Coordenadas de tela para formas complexas
            const sx = (CW() / 2) + left - camera.x;
            const sy = (CH() / 2) + y - camera.y;
            const scx = (CW() / 2) + cx - camera.x;

            switch(item.type) {
                // === OBJETOS REFINADOS ===

                case 'bookshelf': // Biblioteca Detalhada
                    // Estrutura principal da estante
                    drawRect(left, y, s.w, s.h, '#8d6e63'); // Madeira escura base

                    // Prateleiras horizontais (5 prateleiras)
                    const shelfHeight = Math.floor(s.h / 6);
                    for(let shelf = 1; shelf <= 5; shelf++) {
                        const shelfY = y + shelf * shelfHeight;
                        drawRect(left + 2, shelfY - 1, s.w - 4, 3, '#5d4037'); // Prateleira mais escura

                        // Livros em cada prateleira (3-5 livros por prateleira)
                        const booksCount = 3 + Math.floor(pseudoRandom(seed + shelf) * 3);
                        const bookWidth = (s.w - 8) / booksCount;

                        for(let book = 0; book < booksCount; book++) {
                            const bookX = left + 4 + book * bookWidth;
                            const bookW = bookWidth - 1;
                            const bookH = shelfHeight - 6;

                            // Varia√ß√£o de cores dos livros baseada na posi√ß√£o
                            const bookSeed = seed + shelf * 10 + book;
                            const bookHue = (pseudoRandom(bookSeed) * 360) % 360;

                            // Cores realistas de livros: vermelho, azul, verde, amarelo, roxo, etc.
                            const bookColors = [
                                '#d32f2f', '#1976d2', '#388e3c', '#f57c00', '#7b1fa2',
                                '#0288d1', '#689f38', '#f4511e', '#8e24aa', '#0097a7',
                                '#558b2f', '#e64a19', '#6a1b9a', '#00796b', '#ff6f00'
                            ];
                            const bookCol = bookColors[Math.floor(pseudoRandom(bookSeed) * bookColors.length)];

                            // Livro com lombada
                            drawRect(bookX, shelfY + 2, bookW, bookH, bookCol);

                            // Lombada mais escura
                            drawRect(bookX + bookW - 2, shelfY + 2, 2, bookH, `rgba(0,0,0,0.3)`);

                            // Reflexo na capa (brilho sutil)
                            drawRect(bookX + 1, shelfY + 3, bookW - 2, 1, `rgba(255,255,255,0.4)`);

                            // Algumas varia√ß√µes: livros com t√≠tulos ou detalhes
                            if (pseudoRandom(bookSeed + 1) > 0.7) {
                                // Livro com "t√≠tulo" (linha horizontal)
                                drawRect(bookX + 2, shelfY + 4 + bookH * 0.3, bookW - 4, 1, `rgba(255,255,255,0.6)`);
                            }

                            if (pseudoRandom(bookSeed + 2) > 0.8) {
                                // Livro mais grosso
                                drawRect(bookX - 1, shelfY + 2, bookW + 2, bookH, bookCol);
                                drawRect(bookX, shelfY + 3, bookW, 1, `rgba(255,255,255,0.3)`);
                            }
                        }
                    }

                    // Suportes verticais laterais (pilares)
                    drawRect(left, y, 4, s.h, '#5d4037'); // Pilar esquerdo
                    drawRect(right - 4, y, 4, s.h, '#5d4037'); // Pilar direito

                    // Detalhes nos pilares (pregos ou refor√ßos)
                    for(let i = 0; i < 6; i++) {
                        const pegY = y + 8 + i * 10;
                        if (pegY < y + s.h - 5) {
                            drawCircle(left + 2, pegY, 1, '#212121'); // Pino esquerdo
                            drawCircle(right - 2, pegY, 1, '#212121'); // Pino direito
                        }
                    }

                    // Base inferior refor√ßada
                    drawRect(left - 2, y + s.h - 4, s.w + 4, 6, '#4e342e');

                    // Sombras nas prateleiras inferiores
                    for(let shelf = 2; shelf <= 5; shelf++) {
                        const shadowY = y + shelf * shelfHeight + 2;
                        drawRect(left + 4, shadowY, s.w - 8, 1, 'rgba(0,0,0,0.2)');
                    }

                    // Decora√ß√£o: alguns livros "saindo" da prateleira
                    if (pseudoRandom(seed) > 0.6) {
                        // Livro saindo na segunda prateleira
                        const shelf2Y = y + 2 * shelfHeight;
                        drawRect(left + 6, shelf2Y - 3, 8, shelfHeight, '#1976d2');
                        drawRect(left + 12, shelf2Y - 2, 2, shelfHeight - 4, '#0d47a1');
                        drawRect(left + 7, shelf2Y - 1, 6, 1, 'rgba(255,255,255,0.5)');
                    }

                    // Indicador visual de interatividade (piscando sutil)
                    const blinkBook = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx, y + 5, 0.8, `rgba(139, 69, 19, ${blinkBook})`);
                    break;

                case 'weights': // Halteres Grandes (barra + discos)
                    // Barra principal de metal
                    drawRect(cx - 12, y + 8, 24, 2, '#c0c0c0');
                    drawRect(cx - 11, y + 9, 22, 0.5, '#e0e0e0'); // Reflexo

                    // Discos de peso (m√∫ltiplas camadas)
                    const discColors = ['#ff5722', '#2196f3', '#4caf50', '#ff9800'];

                    // Lado esquerdo
                    for(let i = 0; i < 4; i++) {
                        const discSize = 3 - i * 0.3;
                        const discX = cx - 8 - i * 1.5;
                        drawCircle(discX, y + 9, discSize, discColors[i % discColors.length]);
                        drawCircle(discX, y + 9, discSize - 0.5, '#333'); // Centro
                    }

                    // Lado direito
                    for(let i = 0; i < 4; i++) {
                        const discSize = 3 - i * 0.3;
                        const discX = cx + 8 + i * 1.5;
                        drawCircle(discX, y + 9, discSize, discColors[i % discColors.length]);
                        drawCircle(discX, y + 9, discSize - 0.5, '#333'); // Centro
                    }

                    // Parafusos de fixa√ß√£o
                    drawCircle(cx - 12, y + 9, 0.8, '#666');
                    drawCircle(cx + 12, y + 9, 0.8, '#666');

                    // Suportes/base
                    drawRect(cx - 2, y + 11, 4, 3, '#8d6e63');
                    drawRect(cx - 1, y + 12, 2, 2, '#a1887f');

                    // Etiqueta de peso
                    drawRect(cx - 3, y + 7, 6, 1, '#fff');
                    drawText('100kg', cx - 2.5, y + 8, 0.8, '#000');

                    // Sombras
                    drawEllipse(cx, y + 15, 14, 1, 'rgba(0,0,0,0.3)');
                    break;

                case 'resistance_bands': // Faixas El√°sticas de Resist√™ncia
                    // Rolos de faixas el√°sticas empilhados
                    const bandColors = ['#f44336', '#2196f3', '#4caf50', '#ff9800', '#9c27b0'];

                    for(let i = 0; i < 5; i++) {
                        const rollY = y + i * 2;
                        const rollHeight = Math.max(1, 3 - i * 0.3);
                        drawRoundRect(cx - 6, rollY, 12, rollHeight, 1, bandColors[i % bandColors.length]);

                        // Centro do rolo (mais escuro)
                        drawRoundRect(cx - 4, rollY + 0.5, 8, rollHeight - 1, 0.5, bandColors[i % bandColors.length] + '80');
                    }

                    // Suporte de armazenamento
                    drawRect(cx - 8, y - 1, 16, 1, '#8d6e63');
                    drawRect(cx - 7, y - 2, 14, 1, '#a1887f');

                    // Etiqueta
                    drawRect(cx - 4, y + 11, 8, 1, '#fff');
                    drawText('5-50lbs', cx - 3.5, y + 12, 0.7, '#000');
                    break;

                case 'foam_roller': // Rolo de Espuma para Massagem
                    // Cilindro principal de espuma
                    drawRoundRect(cx - 8, y + 4, 16, 6, 3, '#e1f5fe');

                    // Textura da espuma (linhas onduladas)
                    for(let i = 0; i < 8; i++) {
                        const waveOffset = Math.sin(i * 0.8) * 0.5;
                        drawRect(cx - 7 + i * 1.8, y + 5 + waveOffset, 1.5, 1, '#b3e5fc');
                    }

                    // Capas nas extremidades (pl√°stico azul)
                    drawRoundRect(cx - 10, y + 4, 3, 6, 1.5, '#2196f3');
                    drawRoundRect(cx + 7, y + 4, 3, 6, 1.5, '#2196f3');

                    // An√©is de refor√ßo
                    drawCircle(cx - 8.5, y + 7, 0.3, '#1976d2');
                    drawCircle(cx + 8.5, y + 7, 0.3, '#1976d2');

                    // Base/suporte
                    drawRect(cx - 2, y + 10, 4, 2, '#8d6e63');

                    // Etiqueta de tamanho
                    drawRect(cx - 3, y + 2, 6, 1, '#fff');
                    drawText('36"', cx - 2, y + 3, 0.8, '#000');
                    break;

                case 'ankle_weights': // Pesos de Tornozelo
                    // Par de pesos conectados por correia
                    for(let side = 0; side < 2; side++) {
                        const sideX = cx + (side === 0 ? -6 : 2);
                        // Corpo do peso
                        drawRoundRect(sideX, y + 4, 6, 8, 1, '#424242');
                        drawRoundRect(sideX + 1, y + 5, 4, 6, 0.5, '#616161');

                        // Correias de velcro
                        drawRect(sideX - 1, y + 2, 8, 1, '#000');
                        drawRect(sideX - 1, y + 3, 8, 0.5, '#ff5722');

                        // Fivela
                        drawRect(sideX + 2, y + 1, 2, 2, '#c0c0c0');
                        drawRect(sideX + 2.5, y + 1.5, 1, 1, '#666');
                    }

                    // Correia conectora
                    drawRect(cx - 4, y + 6, 8, 1, '#000');

                    // Etiqueta de peso
                    drawRect(cx - 3, y + 13, 6, 1, '#fff');
                    drawText('5lbs', cx - 2, y + 14, 0.8, '#000');
                    break;

                case 'hand_grips': // Aperto de M√£o (Hand Grippers)
                    // Par de aparelhos de aperto
                    for(let hand = 0; hand < 2; hand++) {
                        const handX = cx + (hand === 0 ? -4 : 2);

                        // Al√ßas (metal)
                        drawRoundRect(handX, y + 3, 3, 8, 0.5, '#c0c0c0');
                        drawRoundRect(handX + 2, y + 3, 3, 8, 0.5, '#c0c0c0');

                        // Mola central
                        drawRect(handX + 1.5, y + 4, 2, 6, '#666');
                        for(let spring = 0; spring < 4; spring++) {
                            drawRect(handX + 1.5, y + 5 + spring * 1.2, 2, 0.3, '#999');
                        }

                        // Alavanca de ajuste
                        drawRect(handX - 1, y + 6, 1, 3, '#ff5722');
                        drawCircle(handX - 0.5, y + 7.5, 0.3, '#666');
                    }

                    // Etiqueta de resist√™ncia
                    drawRect(cx - 3, y + 12, 6, 1, '#fff');
                    drawText('100lbs', cx - 2.5, y + 13, 0.7, '#000');
                    break;

                case 'massage_ball': // Bola de Massagem
                    // Bola esf√©rica com texturas
                    drawCircle(cx, y + 5, 4, '#ff5722');

                    // Texturas pontiagudas (n√≥dulos)
                    for(let i = 0; i < 12; i++) {
                        const angle = (i * Math.PI * 2) / 12;
                        const spikeX = cx + Math.cos(angle) * 3.5;
                        const spikeY = y + 5 + Math.sin(angle) * 3.5;
                        drawCircle(spikeX, spikeY, 0.4, '#d84315');
                    }

                    // Centro macio
                    drawCircle(cx, y + 5, 2, '#ff8a65');

                    // Base pequena
                    drawRect(cx - 1, y + 9, 2, 1, '#8d6e63');

                    // Etiqueta de tamanho
                    drawRect(cx - 2, y + 1, 4, 0.8, '#fff');
                    drawText('8cm', cx - 1.5, y + 2, 0.6, '#000');
                    break;

                case 'protein_shaker': // Shaker de Prote√≠na
                    // Corpo cil√≠ndrico do shaker
                    drawRoundRect(cx - 3, y, 6, 12, 1, '#c0c0c0');
                    drawRoundRect(cx - 2.5, y + 0.5, 5, 11, 0.8, '#e0e0e0');

                    // Tampa com rosca
                    drawRoundRect(cx - 3.5, y - 1, 7, 2, 1.5, '#424242');

                    // Tampa da tampa (para misturar)
                    drawCircle(cx, y - 2, 1.5, '#666');
                    drawCircle(cx, y - 2, 0.8, '#999');

                    // Janela de medi√ß√£o
                    drawRect(cx - 2, y + 2, 4, 6, '#b3e5fc');
                    drawRect(cx - 1.5, y + 2.5, 3, 5, '#e1f5fe');

                    // Marcas de medi√ß√£o
                    for(let mark = 0; mark < 5; mark++) {
                        drawRect(cx - 1, y + 3 + mark * 1, 2, 0.2, '#000');
                    }

                    // Conte√∫do (l√≠quido)
                    drawRect(cx - 1.5, y + 7, 3, 2, 'rgba(255, 193, 7, 0.7)');

                    // Base
                    drawRoundRect(cx - 2, y + 12, 4, 1, 0.5, '#8d6e63');

                    // Etiqueta
                    drawRect(cx - 2.5, y + 4, 5, 0.8, '#fff');
                    drawText('32oz', cx - 2, y + 5, 0.6, '#000');
                    break;

                case 'box_pile': // Caixas Empilhadas
                    drawRect(left, y + 10, s.w, s.h - 10, '#d7ccc8'); 
                    drawRect(left, y + 10, s.w, 1, '#a1887f'); 
                    drawLine(left, y + 10, right, y + s.h, 1, 'rgba(0,0,0,0.1)'); 
                    drawRect(left + 4, y + s.h - 8, 6, 4, '#fff');
                    drawRect(left + 2, y, s.w - 4, 10, '#d7ccc8');
                    drawRect(left + 2, y + 5, s.w - 4, 1, '#a1887f'); 
                    break;

                case 'server': // Servidor com anima√ß√µes avan√ßadas
                    drawRoundRect(left, y, s.w, s.h, 2, '#1a1a1d');

                    if (serverActive) {
                        // Ventoinhas girando
                    for(let i=0; i<2; i++) {
                        const fanX = left + 6 + i * 12;
                        const fanY = y + 8;
                        const fanAngle = time / 100 + i * Math.PI;

                        ctx.strokeStyle = '#666';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        // P√°s da ventoinha
                        for(let j=0; j<4; j++) {
                            const angle = fanAngle + (j * Math.PI / 2);
                            ctx.moveTo(fanX, fanY);
                            ctx.lineTo(fanX + Math.cos(angle) * 4, fanY + Math.sin(angle) * 4);
                        }
                        ctx.stroke();
                        // Centro da ventoinha
                        drawCircle(fanX, fanY, 1, '#999');
                    }

                    // Linhas de dados e LEDs
                    for(let i=0; i<10; i++) {
                        const ry = y + 4 + (i * 6);
                        drawRect(left + 2, ry, s.w - 4, 1, '#333');

                        // LEDs de status com diferentes padr√µes de piscar
                        const ledPattern1 = Math.floor((time / (80 + i*30))) % 3;
                        const ledPattern2 = Math.floor((time / (120 + i*40))) % 2;

                        if(ledPattern1 === 0) drawRect(right - 6, ry, 2, 2, '#00e676'); // Verde
                        else if(ledPattern1 === 1) drawRect(right - 6, ry, 2, 2, '#2196f3'); // Azul
                        else drawRect(right - 6, ry, 2, 2, '#ff9800'); // Laranja

                        if(ledPattern2 === 1) drawRect(right - 10, ry, 2, 2, '#e91e63'); // Rosa para erro/atividade
                    }

                    // Dados "fluindo" visualmente
                    for(let i=0; i<5; i++) {
                        const dataY = y + 10 + Math.sin(time / 200 + i) * 20;
                        const dataX = left + 4 + (time / 50 + i * 50) % (s.w - 8);
                        drawCircle(dataX, dataY, 0.5, `hsl(${(time / 20 + i * 60) % 360}, 70%, 60%)`);
                    }

                        // LED de energia pulsante
                        const powerIntensity = Math.sin(time / 300) * 0.3 + 0.7;
                        drawCircle(cx, y + s.h - 3, 2, `rgba(255, 255, 255, ${powerIntensity})`);
                    } else {
                        // Estado inativo - LEDs fixos
                        for(let i=0; i<10; i++) {
                            const ry = y + 4 + (i * 6);
                            drawRect(left + 2, ry, s.w - 4, 1, '#333');
                            drawRect(right - 6, ry, 2, 2, '#666'); // LEDs acinzentados
                        }
                        // LED de energia fraco
                        drawCircle(cx, y + s.h - 3, 2, 'rgba(255, 255, 255, 0.3)');
                    }

                    // Indicador visual de interatividade
                    const blinkServer = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx + 8, y + s.h - 2, 0.8, `rgba(100, 255, 100, ${blinkServer})`);
                    break;

                case 'chem_rack': // Reagentes com anima√ß√µes qu√≠micas
                    drawRoundRect(left, y, s.w, s.h, 2, '#cfd8dc');
                    drawRect(left + 2, y + 15, s.w - 4, 2, '#90a4ae');
                    drawRect(left + 2, y + 35, s.w - 4, 2, '#90a4ae');
                    
                    if (chemRackActive) {
                        // Reagente roxo com borbulhas
                    ctx.fillStyle = `rgba(224, 64, 251, ${0.6 + Math.sin(time / 300) * 0.2})`;
                    ctx.beginPath();
                    const f1x = scx - 6; const f1y = sy + 35;
                    ctx.moveTo(f1x, f1y); 
                    ctx.lineTo(f1x + 8, f1y); 
                    ctx.lineTo(f1x + 4, f1y - 10);
                    ctx.fill();
                    
                    // Borbulhas no reagente roxo
                    for(let i=0; i<3; i++) {
                        const bubbleY = f1y - 2 - (time / 100 + i * 50) % 8;
                        if(bubbleY > f1y - 8) {
                            drawCircle(f1x + 2 + Math.sin(time / 200 + i) * 2, bubbleY, 0.8, 'rgba(255, 255, 255, 0.7)');
                        }
                    }

                    // Reagente azul com movimento
                    const bluePulse = Math.sin(time / 400) * 0.3 + 0.7;
                    ctx.fillStyle = `rgba(0, 229, 255, ${0.6 * bluePulse})`;
                    ctx.beginPath();
                    ctx.arc(scx + 6, sy + 32, 4 * bluePulse, 0, Math.PI*2);
                    ctx.fill();

                    // Tubo conectado ao reagente azul
                    drawRect(cx + 5, y + 25, 2, 6, `rgba(0, 229, 255, ${0.6 * bluePulse})`);

                    // Tubos de ensaio com cores vibrantes
                    const tubeColors = ['lime', 'yellow', 'red'];
                    for(let i=0; i<3; i++) {
                        const tubeX = left + 6 + i * 4;
                        const liquidHeight = 8 + Math.sin(time / (200 + i * 100)) * 2;
                        drawRect(tubeX, y + 5, 2, 10, '#e0e0e0'); // Tubo de vidro
                        drawRect(tubeX, y + 5 + (10 - liquidHeight), 2, liquidHeight, tubeColors[i]);

                        // Brilho no l√≠quido
                        const shineY = y + 5 + (10 - liquidHeight) + Math.sin(time / 150 + i) * liquidHeight * 0.5;
                        drawRect(tubeX, shineY, 2, 1, 'rgba(255, 255, 255, 0.6)');
                    }

                    // Vapor/vaporiza√ß√£o dos reagentes
                    for(let i=0; i<6; i++) {
                        const vaporX = cx + Math.sin(time / 300 + i) * 8;
                        const vaporY = y + 2 - (time / 80 + i * 20) % 15;
                        const vaporAlpha = Math.max(0, (y + 2 - vaporY) / 15);
                        drawCircle(vaporX, vaporY, 0.5, `rgba(150, 150, 200, ${vaporAlpha * 0.4})`);
                    }

                        // Indicador de atividade qu√≠mica (piscando)
                        const chemActivity = Math.sin(time / 250) > 0 ? 1 : 0.3;
                        drawCircle(cx, y + 2, 1, `rgba(255, 165, 0, ${chemActivity})`);
                    } else {
                        // Estado inativo - reagentes est√°ticos
                        ctx.fillStyle = 'rgba(224, 64, 251, 0.6)';
                        ctx.beginPath();
                        const f1xInactive = scx - 6; const f1yInactive = sy + 35;
                        ctx.moveTo(f1xInactive, f1yInactive);
                        ctx.lineTo(f1xInactive + 8, f1yInactive);
                        ctx.lineTo(f1xInactive + 4, f1yInactive - 8);
                        ctx.fill();

                        ctx.fillStyle = 'rgba(0, 229, 255, 0.6)';
                        ctx.beginPath();
                        ctx.arc(scx + 6, sy + 32, 3, 0, Math.PI*2);
                        ctx.fill();
                        drawRect(cx + 5, y + 25, 2, 6, 'rgba(0, 229, 255, 0.6)');

                        drawRect(left + 6, y + 5, 2, 8, 'lime');
                        drawRect(left + 10, y + 5, 2, 8, 'yellow');
                        drawRect(left + 14, y + 5, 2, 8, 'red');

                        drawCircle(cx, y + 2, 1, 'rgba(255, 165, 0, 0.3)');
                    }

                    // Indicador visual de interatividade
                    const blinkChem = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx + 10, y + 2, 0.8, `rgba(255, 100, 255, ${blinkChem})`);
                    break;

                case 'pallet_jack': // Paleteira
                    drawRect(left, y + s.h - 4, s.w - 8, 4, '#fdd835'); 
                    drawCircle(left + 4, y + s.h, 2, '#000'); 
                    drawRect(right - 10, y + s.h - 10, 10, 8, '#fdd835');
                    drawCircle(right - 5, y + s.h, 3, '#000'); 
                    drawLine(right - 5, y + s.h - 10, right - 5, y, 2, '#212121');
                    drawRect(right - 8, y, 6, 2, '#212121'); 
                    break;

                case 'lab_table': // Mesa Laborat√≥rio
                    drawRect(left, y, s.w, 4, '#cfd8dc'); 
                    drawRect(left + 4, y + 4, 2, s.h - 4, '#90a4ae');
                    drawRect(right - 6, y + 4, 2, s.h - 4, '#90a4ae');
                    drawRect(left + 4, y + s.h - 6, s.w - 10, 2, '#90a4ae');
                    break;

                case 'punching_bag': // Saco de Boxe
                    // Aplica o balan√ßo ao saco
                    const bagSwingOffset = Math.sin(punchingBagSwing) * 3;
                    const bagX = left + 4 + bagSwingOffset;

                    drawRoundRect(bagX, y, 8, s.h, 4, '#b71c1c');
                    drawRect(bagX, y + 4, 8, 4, '#000');

                    // Corrente com leve curvatura devido ao balan√ßo
                    const chainSwing = Math.sin(punchingBagSwing) * 0.5;
                    drawLine(cx, y - 20, cx + chainSwing, y, 1, '#bdbdbd');

                    // Reduz gradualmente o balan√ßo
                    punchingBagSwing *= 0.95;
                    break;

                case 'crate': // Engradado
                    drawRect(left, y, s.w, s.h, '#8d6e63');
                    drawRect(left, y, s.w, 2, '#5d4037');
                    drawRect(left, y + s.h - 2, s.w, 2, '#5d4037');
                    drawRect(left, y, 2, s.h, '#5d4037');
                    drawRect(right - 2, y, 2, s.h, '#5d4037');
                    drawLine(left, y, right, y + s.h, 1, '#5d4037');
                    drawLine(right, y, left, y + s.h, 1, '#5d4037');
                    break;

                case 'locker': // Arm√°rio Academia
                    drawRoundRect(left, y, s.w, s.h, 2, '#757575'); 
                    drawLine(cx, y + 2, cx, y + s.h - 2, 1, '#424242');
                    for(let i=0; i<3; i++) {
                        drawRect(left + 4, y + 6 + (i*2), (s.w/2) - 6, 1, '#424242');
                        drawRect(cx + 2, y + 6 + (i*2), (s.w/2) - 6, 1, '#424242');
                    }
                    drawRect(cx - 4, y + s.h/2, 2, 4, '#000');
                    drawRect(right - 4, y + s.h/2, 2, 4, '#000');
                    break;

                case 'nightstand': // Criado Mudo
                    drawRect(left, y, s.w, s.h, '#5d4037');
                    drawRect(left + 2, y + 2, s.w - 4, (s.h/2) - 2, '#8d6e63');
                    drawCircle(cx, y + (s.h/4) + 1, 1, '#ffd700'); 
                    drawRect(left + 2, y + (s.h/2) + 2, s.w - 4, (s.h/2) - 4, '#3e2723'); 
                    break;

                case 'mirror': // Espelho Oval
                    drawEllipse(cx, y + s.h/2, s.w/2, s.h/2, '#90a4ae');
                    drawEllipse(cx, y + s.h/2, (s.w/2)-2, (s.h/2)-2, '#e1f5fe');
                    drawLine(left + 8, y + 10, left + 12, y + 16, 1, 'rgba(255,255,255,0.6)');
                    break;

                case 'stool': // Banqueta Copa
                    drawEllipse(cx, y + 2, s.w/2, 3, s.col);
                    drawRect(cx - 2, y + 4, 4, s.h - 6, '#bdbdbd');
                    drawEllipse(cx, y + s.h, 6, 2, '#bdbdbd');
                    break;

                case 'table': // Mesa Copa (Madeira)
                    drawRect(left, y, s.w, 4, s.col);
                    drawRect(left + 2, y + 4, 4, s.h - 4, '#5d4037');
                    drawRect(right - 6, y + 4, 4, s.h - 4, '#5d4037');
                    break;

                case 'plant': // Plantas Procedurais
                    const plantType = Math.floor(pseudoRandom(seed) * 3);
                    drawRoundRect(cx - 6, floorY - 10, 12, 10, 2, '#e64a19'); 
                    
                    if (plantType === 0) { // Cacto
                        drawRoundRect(cx - 4, y, 8, 30, 4, '#2e7d32');
                        drawRoundRect(cx - 8, y + 10, 4, 10, 2, '#2e7d32'); 
                        drawRoundRect(cx + 4, y + 5, 4, 12, 2, '#2e7d32'); 
                    } else if (plantType === 1) { // Samambaia
                        ctx.fillStyle = '#4caf50';
                        for(let i=0; i<8; i++) {
                            const px = cx + Math.cos(i) * 12;
                            const py = y + 10 + Math.sin(i) * 10;
                            ctx.beginPath();
                            ctx.moveTo(scx, sy + 30); 
                            ctx.quadraticCurveTo(scx + (px-cx)*2, sy, (CW() / 2)+px-camera.x, (CH() / 2)+py-camera.y);
                            ctx.strokeStyle = '#388e3c';
                            ctx.lineWidth = 2;
                            ctx.stroke();
                        }
                    } else { // Arbusto Redondo
                        ctx.fillStyle = '#66bb6a';
                        drawCircle(cx, y + 20, 10, null);
                        drawCircle(cx - 5, y + 25, 8, null);
                        drawCircle(cx + 5, y + 15, 8, null);
                    }
                    break;

                // === ACADEMIA (Novos itens) ===
                case 'dumbbells':
                    if (dumbbellsActive) {
                        // Anima√ß√£o de halteres sendo usados em exerc√≠cio
                        const liftPhase = Math.sin(time / 600) * 0.5 + 0.5; // 0-1

                        // Pessoa levantando halteres
                        const personY = y - 8 + liftPhase * 6;

                        // Bra√ßos da pessoa
                        drawRect(cx - 8, personY + 2, 2, 6, '#8d6e63'); // Bra√ßo esquerdo
                        drawRect(cx + 6, personY + 2, 2, 6, '#8d6e63'); // Bra√ßo direito

                        // Halteres sendo levantados
                        const dumbbell1Y = personY + 8 - liftPhase * 4;
                        const dumbbell2Y = personY + 8 - liftPhase * 4;

                        // Halter 1 (direito)
                        drawRect(cx + 5, dumbbell1Y, 3, 4, '#757575');
                        drawRect(cx + 5.5, dumbbell1Y + 1, 1, 2, '#616161');
                        drawCircle(cx + 4, dumbbell1Y + 2.5, 0.8, '#c0c0c0');
                        drawCircle(cx + 7, dumbbell1Y + 2.5, 0.8, '#c0c0c0');

                        // Halter 2 (esquerdo)
                        drawRect(cx - 8, dumbbell2Y, 3, 4, '#757575');
                        drawRect(cx - 7.5, dumbbell2Y + 1, 1, 2, '#616161');
                        drawCircle(cx - 9, dumbbell2Y + 2.5, 0.8, '#c0c0c0');
                        drawCircle(cx - 6, dumbbell2Y + 2.5, 0.8, '#c0c0c0');

                        // Corpo da pessoa
                        drawRect(cx - 3, personY, 6, 8, '#333');
                        drawCircle(cx, personY - 2, 2, '#666');

                        // Pernas
                        drawRect(cx - 2, personY + 8, 2, 4, '#333');
                        drawRect(cx + 1, personY + 8, 2, 4, '#333');

                        // Suor/energia emanando
                        for(let i = 0; i < 3; i++) {
                            const sweatY = personY - 4 - (time / 150 + i * 50) % 8;
                            if(sweatY > personY - 10) {
                                drawCircle(cx + Math.sin(time / 200 + i) * 4, sweatY, 0.5, `rgba(200, 220, 255, ${(personY + 4 - sweatY) / 8})`);
                            }
                        }
                    } else {
                        // Estado inativo - halteres empilhados
                        // Haltere 1 (base) - mais detalhado
                        drawRect(cx - 5, y + 6, 4, 5, s.col); // Corpo principal
                        drawRect(cx - 6, y + 7, 1, 3, '#424242'); // Pegada
                        drawCircle(cx - 7, y + 8.5, 1, '#silver'); // Peso esquerdo
                        drawCircle(cx - 3, y + 8.5, 1, '#silver'); // Peso direito
                        // Marcas de peso
                        drawRect(cx - 5.5, y + 7.5, 0.5, 2, '#gold');
                        // Haltere 2 (meio)
                        drawRect(cx - 2, y + 4, 4, 5, s.col);
                        drawRect(cx - 3, y + 5, 1, 3, '#424242');
                        drawCircle(cx - 4, y + 6.5, 1, '#silver');
                        drawCircle(cx, y + 6.5, 1, '#silver');
                        drawRect(cx - 2.5, y + 5.5, 0.5, 2, '#gold');
                        // Haltere 3 (topo) - mais leve
                        drawRect(cx + 1, y + 2, 3, 4, '#757575'); // Corpo menor
                        drawRect(cx, y + 3, 1, 2, '#616161'); // Pegada menor
                        drawCircle(cx - 0.5, y + 4.5, 0.8, '#c0c0c0'); // Pesos menores
                        drawCircle(cx + 2.5, y + 4.5, 0.8, '#c0c0c0');
                        // Reflexos met√°licos
                        drawRect(cx - 4.5, y + 6.5, 0.5, 4, 'rgba(192, 192, 192, 0.6)');
                        drawRect(cx - 1.5, y + 4.5, 0.5, 4, 'rgba(192, 192, 192, 0.6)');
                        drawRect(cx + 0.5, y + 2.5, 0.5, 3, 'rgba(192, 192, 192, 0.6)');
                        // Sombras
                        drawRect(cx - 6, y + 11, 10, 1, 'rgba(0, 0, 0, 0.3)');
                    }

                    // Indicador visual de interatividade
                    const blinkDumb = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx, y, 0.8, `rgba(150, 75, 0, ${blinkDumb})`);
                    break;

                case 'bench_press':
                    // Base s√≥lida de metal
                    drawRect(left, y + 14, s.w, 6, '#424242');
                    drawRect(left + 2, y + 16, s.w - 4, 2, '#616161');
                    // P√©s ajust√°veis com detalhes
                    drawRect(left + 4, y + 18, 3, 6, '#757575');
                    drawRect(right - 7, y + 18, 3, 6, '#757575');
                    drawCircle(left + 5.5, y + 20, 1, '#silver'); // Rodinhas
                    drawCircle(right - 5.5, y + 20, 1, '#silver');
                    // Estrutura do banco
                    drawRect(left + 2, y + 12, s.w - 4, 4, '#424242');
                    // Almofadas do banco
                    drawRect(left + 4, y + 10, s.w - 8, 3, '#2e7d32'); // Parte inferior
                    drawRect(left + 4, y + 8, s.w - 8, 3, '#4caf50'); // Parte superior
                    // Costuras nas almofadas
                    for(let i = 0; i < 6; i++) {
                        drawRect(left + 6 + i*4, y + 9, 2, 1, '#1b5e20');
                    }
                    // Suportes da barra com refor√ßos
                    drawRect(left + 12, y, 4, 16, '#757575');
                    drawRect(right - 16, y, 4, 16, '#757575');
                    // Detalhes dos suportes
                    drawRect(left + 13, y + 2, 2, 12, '#616161');
                    drawRect(right - 15, y + 2, 2, 12, '#616161');
                    // Barra de halterofilismo
                    drawRect(left + 14, y + 4, 20, 3, '#c0c0c0');
                    drawRect(left + 15, y + 5, 18, 1, '#e0e0e0');
                    // Bloqueadores de seguran√ßa
                    drawRect(left + 12, y + 6, 6, 2, '#ff5722');
                    drawRect(right - 18, y + 6, 6, 2, '#ff5722');
                    // Anilhas pesadas
                    drawCircle(left + 10, y + 5.5, 5, '#212121');
                    drawCircle(left + 14, y + 5.5, 4, '#424242');
                    drawCircle(left + 18, y + 5.5, 3.5, '#616161');
                    drawCircle(left + 22, y + 5.5, 3, '#757575');
                    drawCircle(left + 26, y + 5.5, 2.5, '#8d8d8d');
                    drawCircle(left + 30, y + 5.5, 2, '#a0a0a0');
                    // Marcas nas anilhas
                    drawRect(left + 9, y + 4.5, 2, 2, '#gold');
                    drawRect(left + 29, y + 4.5, 2, 2, '#gold');
                    // Reflexos met√°licos
                    drawRect(left + 15, y + 4, 18, 0.5, 'rgba(192, 192, 192, 0.7)');
                    // Sombras
                    drawRect(left, y + 20, s.w, 2, 'rgba(0, 0, 0, 0.4)');
                    break;

                case 'medicine_ball':
                    if (medicineBallActive) {
                        // Anima√ß√£o de bola sendo usada em exerc√≠cio (slam ball)
                        const slamPhase = Math.sin(time / 500) * 0.5 + 0.5; // 0-1

                        // Bola sendo arremessada para cima e baixo
                        const ballY = y + 5 - slamPhase * 8;
                        const ballSquish = 1 + slamPhase * 0.3; // Bola fica achatada quando bate

                        // Bola deformada durante o impacto
                        ctx.fillStyle = s.col;
                        ctx.beginPath();
                        ctx.ellipse(scx, sy + ballY, 5, 5 * ballSquish, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Costuras deformadas
                        drawLine(cx - 4, ballY - 2, cx + 4, ballY + 2, 2, '#d84315');
                        drawLine(cx, ballY - 4, cx, ballY + 4, 2, '#bf360c');

                        // Textura de couro deformada
                        for(let i = 0; i < 8; i++) {
                            const angle = (i * Math.PI * 2) / 8;
                            const texX = cx + Math.cos(angle) * 4;
                            const texY = ballY + Math.sin(angle) * 4 * ballSquish;
                            drawCircle(texX, texY, 0.5, '#bf360c');
                        }

                        // Painel central deformado
                        ctx.beginPath();
                        ctx.ellipse(scx, sy + ballY, 2, 2 * ballSquish, 0, 0, Math.PI * 2);
                        ctx.fillStyle = '#ff5722';
                        ctx.fill();
                        drawText('10', cx - 1, ballY, 1.5, '#fff');

                        // Efeito de impacto quando bate no ch√£o
                        if(slamPhase < 0.2) {
                            // Ondas de choque
                            for(let ring = 1; ring <= 3; ring++) {
                                const ringRadius = (time / 10 + ring * 20) % 30;
                                if(ringRadius < 20) {
                                    ctx.strokeStyle = `rgba(139, 69, 19, ${1 - ringRadius/20})`;
                                    ctx.lineWidth = 1;
                                    ctx.beginPath();
                                    ctx.arc(scx, sy + y + 13, ringRadius, 0, Math.PI * 2);
                                    ctx.stroke();
                                }
                            }

                            // Poeira
                            for(let i = 0; i < 5; i++) {
                                const dustX = cx + Math.sin(time / 100 + i) * 8;
                                const dustY = y + 10 + Math.cos(time / 150 + i) * 4;
                                drawCircle(dustX, dustY, 0.3, `rgba(139, 69, 19, 0.6)`);
                            }
                        }

                        // Pessoa arremessando a bola
                        const personX = cx - 8;
                        const personArmAngle = slamPhase * Math.PI / 4; // Bra√ßo segue o movimento

                        // Corpo da pessoa
                        drawRect(personX - 2, y + 2, 4, 8, '#333');
                        drawCircle(personX, y, 2, '#666');

                        // Bra√ßo arremessando
                        const armEndX = personX + Math.cos(personArmAngle) * 6;
                        const armEndY = y + 4 + Math.sin(personArmAngle) * 6;
                        drawLine(personX, y + 4, armEndX, armEndY, 2, '#8d6e63');

                        // Pernas
                        drawRect(personX - 1, y + 10, 2, 4, '#333');
                    } else {
                        // Estado inativo - bola est√°tica
                        ctx.fillStyle = s.col;
                        ctx.beginPath();
                        ctx.arc(scx, sy + 5, 5, 0, Math.PI * 2);
                        ctx.fill();
                        // Costuras em relevo (linhas grossas)
                        drawLine(cx - 4, y + 2, cx + 4, y + 8, 2, '#d84315');
                        drawLine(cx, y, cx, y + 10, 2, '#bf360c');
                        drawLine(cx - 3, y + 1, cx + 3, y + 9, 1, '#d84315');
                        // Textura de couro
                        for(let i = 0; i < 8; i++) {
                            const angle = (i * Math.PI * 2) / 8;
                            const texX = scx + Math.cos(angle) * 4;
                            const texY = sy + 5 + Math.sin(angle) * 4;
                            drawCircle(texX, texY, 0.5, '#bf360c');
                        }
                        // Painel central
                        drawCircle(cx, y + 5, 2, '#ff5722');
                        drawText('10', cx - 1, y + 6, 2, '#fff');
                        // Revestimento de couro adicional
                        ctx.strokeStyle = '#a62800';
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        ctx.arc(scx, sy + 5, 4.5, 0, Math.PI * 2);
                        ctx.stroke();
                        // Brilho na superf√≠cie
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                        ctx.beginPath();
                        ctx.arc(scx - 2, sy + 3, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                        // Sombra sutil
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                        ctx.beginPath();
                        ctx.arc(scx, sy + 8, 4, 0, Math.PI);
                        ctx.fill();
                    }

                    // Indicador visual de interatividade
                    const blinkBall = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx, y - 1, 0.8, `rgba(255, 100, 100, ${blinkBall})`);
                    break;

                case 'kettlebell':
                    // Corpo principal do kettlebell
                    drawEllipse(cx, y + 6, 3, 4, s.col);
                    drawRect(cx - 2, y + 2, 4, 8, s.col);
                    // Al√ßa ergon√¥mica
                    drawEllipse(cx, y, 3, 2, '#424242');
                    drawRect(cx - 3, y - 1, 6, 3, '#424242');
                    // Detalhes da al√ßa
                    drawRect(cx - 2.5, y, 5, 1, '#616161');
                    // Base arredondada
                    drawEllipse(cx, y + 12, 3.5, 2, s.col);
                    // Marca de peso
                    drawRect(cx - 1, y + 4, 2, 1, '#gold');
                    drawText('16', cx - 1.5, y + 5.5, 1.5, '#gold');
                    // Textura met√°lica
                    drawEllipse(cx, y + 6, 2.5, 3.5, 'rgba(255, 255, 255, 0.1)');
                    // Sombras
                    drawEllipse(cx, y + 13, 3, 1, 'rgba(0, 0, 0, 0.3)');
                    // Revestimento de borracha na base
                    drawEllipse(cx, y + 12, 3, 1.5, '#212121');
                    break;

                case 'pull_up_bar':
                    // Barra principal de a√ßo
                    drawRect(cx - s.w/2, y + 3, s.w, 3, s.col);
                    drawRect(cx - s.w/2 + 1, y + 4, s.w - 2, 1, '#e0e0e0');
                    // Suportes verticais refor√ßados
                    drawRect(cx - s.w/2, y, 4, 10, s.col);
                    drawRect(cx + s.w/2 - 4, y, 4, 10, s.col);
                    // Detalhes dos suportes
                    drawRect(cx - s.w/2 + 1, y + 1, 2, 8, '#c0c0c0');
                    drawRect(cx + s.w/2 - 3, y + 1, 2, 8, '#c0c0c0');
                    // Parafusos de fixa√ß√£o
                    drawCircle(cx - s.w/2 + 2, y + 2, 0.8, '#silver');
                    drawCircle(cx - s.w/2 + 2, y + 6, 0.8, '#silver');
                    drawCircle(cx + s.w/2 - 2, y + 2, 0.8, '#silver');
                    drawCircle(cx + s.w/2 - 2, y + 6, 0.8, '#silver');
                    // Placa de identifica√ß√£o
                    drawRect(cx - 3, y + 1, 6, 2, '#212121');
                    drawText('PULL', cx - 2.5, y + 2.5, 1.5, '#fff');
                    // Revestimento anti-derrapante na barra
                    for(let i = 0; i < s.w - 4; i += 2) {
                        drawRect(cx - s.w/2 + 2 + i, y + 3, 1, 3, '#424242');
                    }
                    // Sombras das paredes
                    drawRect(cx - s.w/2 - 1, y, 1, 10, 'rgba(0, 0, 0, 0.3)');
                    drawRect(cx + s.w/2, y, 1, 10, 'rgba(0, 0, 0, 0.3)');
                    break;

                // === PARQUINHO (Novos Itens) ===
                case 'swing':
                    // Estrutura principal de metal
                    drawRect(cx - 2, y, 4, s.h, '#424242');
                    // Barras transversais refor√ßadas
                    drawRect(cx - 10, y + 6, 20, 3, '#616161');
                    drawRect(cx - 8, y + 12, 16, 2, '#757575');
                    // Correntes grossas com elos vis√≠veis
                    for(let i = 0; i < 6; i++) {
                        drawRect(cx - 7, y + 15 + i*3, 2, 2, '#212121');
                        drawRect(cx + 5, y + 15 + i*3, 2, 2, '#212121');
                    }
                    // Assento de madeira com textura
                    drawRect(cx - 6, y + s.h - 6, 12, 3, s.col);
                    drawRect(cx - 5, y + s.h - 5, 10, 1, '#8d6e63');
                    // Correntes de seguran√ßa
                    drawLine(cx - 6, y + s.h - 6, cx - 8, y + 14, 1, '#666');
                    drawLine(cx + 6, y + s.h - 6, cx + 8, y + 14, 1, '#666');
                    // Movimento sutil animado
                    const swingOffset = Math.sin(getGameTime() / 1000) * 3;
                    drawRect(cx - 6 + swingOffset, y + s.h - 6, 12, 3, s.col);
                    // Sombras no ch√£o
                    drawEllipse(cx + swingOffset, y + s.h + 2, 8, 2, 'rgba(0, 0, 0, 0.2)');
                    break;

                case 'slide':
                    // Estrutura met√°lica principal
                    drawRect(cx - 2, y, 4, s.h, '#616161');
                    // Plataforma superior com corrim√£o
                    drawRect(cx - 12, y, 24, 5, '#757575');
                    drawRect(cx - 14, y - 2, 2, 7, '#c0c0c0');
                    drawRect(cx + 12, y - 2, 2, 7, '#c0c0c0');
                    drawRect(cx - 12, y - 2, 24, 2, '#c0c0c0');
                    // Escorregador curvo com detalhes
                    ctx.fillStyle = s.col;
                    ctx.beginPath();
                    ctx.moveTo(sx - 8, sy + 5);
                    ctx.quadraticCurveTo(sx, sy + 18, sx + 8, sy + s.h);
                    ctx.lineTo(sx - 8, sy + s.h);
                    ctx.closePath();
                    ctx.fill();
                    // Laterais refor√ßadas
                    ctx.strokeStyle = '#4caf50';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(sx - 8, sy + 5);
                    ctx.quadraticCurveTo(sx, sy + 18, sx + 8, sy + s.h);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(sx - 8, sy + s.h);
                    ctx.quadraticCurveTo(sx, sy + 18, sx + 8, sy + s.h);
                    ctx.stroke();
                    // Degraus de acesso
                    for(let i = 0; i < 4; i++) {
                        drawRect(cx - 10, y + 8 + i*4, 20, 2, '#8d6e63');
                        drawRect(cx - 10, y + 10 + i*4, 20, 1, '#a1887f');
                    }
                    // Corrim√£o lateral
                    drawLine(cx - 12, y, cx - 12, y + 12, 2, '#c0c0c0');
                    drawLine(cx + 12, y, cx + 12, y + 12, 2, '#c0c0c0');
                    // Sombras
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                    ctx.beginPath();
                    ctx.moveTo(sx - 8, sy + s.h + 2);
                    ctx.quadraticCurveTo(sx, sy + 20, sx + 8, sy + s.h + 2);
                    ctx.lineTo(sx - 8, sy + s.h + 2);
                    ctx.fill();
                    break;

                case 'seesaw': // Gangorra Melhorada com Mais Detalhes
                    // Base de concreto refor√ßada com mais detalhes
                    drawRect(cx - 22, y + 10, 44, 8, '#8d6e63'); // Base maior
                    drawRect(cx - 20, y + 12, 40, 4, '#a1887f'); // Revestimento superior
                    drawRect(cx - 18, y + 14, 36, 2, '#795548'); // Detalhe de concreto

                    // Suportes met√°licos robustos com refor√ßos
                    drawRect(cx - 20, y, 6, 18, '#424242'); // Suporte esquerdo mais largo
                    drawRect(cx + 14, y, 6, 18, '#424242'); // Suporte direito mais largo

                    // Detalhes dos suportes
                    drawRect(cx - 19, y + 1, 4, 16, '#616161'); // Interior mais claro
                    drawRect(cx + 15, y + 1, 4, 16, '#616161'); // Interior mais claro

                    // Parafusos e refor√ßos
                    for(let i = 0; i < 3; i++) {
                        const boltY = y + 3 + i * 4;
                        drawCircle(cx - 17, boltY, 0.8, '#silver'); // Parafusos esquerdo
                        drawCircle(cx + 17, boltY, 0.8, '#silver'); // Parafusos direito
                        drawRect(cx - 17.5, boltY - 0.5, 1, 1, '#666'); // Porca
                        drawRect(cx + 16.5, boltY - 0.5, 1, 1, '#666'); // Porca
                    }

                    // Eixo central com rolamento
                    drawRect(cx - 3, y + 8, 6, 6, '#c0c0c0'); // Mancal maior
                    drawRect(cx - 2, y + 9, 4, 4, '#e0e0e0'); // Interior
                    drawCircle(cx, y + 11, 2.5, '#silver'); // Rolamento exterior
                    drawCircle(cx, y + 11, 1.5, '#c0c0c0'); // Rolamento interior

                    // Pranchas de madeira com textura aprimorada
                    // Prancha esquerda
                    drawRect(cx - 18, y + 6, 16, 5, s.col);
                    drawRect(cx - 17, y + 7, 14, 3, '#8d6e63');
                    // Prancha direita
                    drawRect(cx, y + 6, 16, 5, s.col);
                    drawRect(cx + 1, y + 7, 14, 3, '#8d6e63');

                    // Textura de madeira mais detalhada
                    for(let i = 0; i < 8; i++) {
                        const grainY = y + 7.5 + i * 0.4;
                        if (i % 2 === 0) {
                            drawRect(cx - 17, grainY, 14, 0.2, '#a1887f'); // V√™nulas escuras
                            drawRect(cx + 1, grainY, 14, 0.2, '#a1887f');
                        } else {
                            drawRect(cx - 17, grainY, 14, 0.1, '#795548'); // V√™nulas mais escuras
                            drawRect(cx + 1, grainY, 14, 0.1, '#795548');
                        }
                    }

                    // Apoios para m√£os (pegadores)
                    drawRect(cx - 4, y + 8, 2, 3, '#666'); // Pegador esquerdo
                    drawRect(cx - 3, y + 9, 1, 1, '#c0c0c0');
                    drawRect(cx + 2, y + 8, 2, 3, '#666'); // Pegador direito
                    drawRect(cx + 2, y + 9, 1, 1, '#c0c0c0');

                    // Movimento animado mais suave
                    const seesawAngle = Math.sin(getGameTime() / 1200) * 0.12; // √Çngulo menor
                    ctx.save();
                    ctx.translate(scx, sy + 11);
                    ctx.rotate(seesawAngle);

                    // Pranchas animadas com detalhes
                    drawRect(-18, -5, 16, 5, s.col);
                    drawRect(0, -5, 16, 5, s.col);
                    // Adicionar pegadores nas pranchas animadas
                    drawRect(-4, -3, 2, 3, '#666');
                    drawRect(2, -3, 2, 3, '#666');

                    ctx.restore();

                    // Sombras din√¢micas mais realistas
                    const shadowOffset = seesawAngle * 25;
                    drawEllipse(cx - 10 + shadowOffset, y + 20, 12, 4, 'rgba(0, 0, 0, 0.25)');
                    drawEllipse(cx + 6 + shadowOffset, y + 20, 12, 4, 'rgba(0, 0, 0, 0.25)');

                    // Placas de seguran√ßa nas bases
                    drawRect(cx - 22, y + 18, 4, 2, '#ff5722'); // Aviso vermelho esquerdo
                    drawRect(cx + 18, y + 18, 4, 2, '#ff5722'); // Aviso vermelho direito
                    drawText('!', cx - 20, y + 19, 0.8, '#fff');
                    drawText('!', cx + 20, y + 19, 0.8, '#fff');

                    break;

                case 'dollhouse':
                    // Casa de boneca grande e detalhada (sem telhado)
                    // Base/funda√ß√£o
                    drawRect(left + 2, y + s.h - 4, s.w - 4, 4, '#8d6e63');
                    // Parede frontal principal (agora ocupa toda a altura dispon√≠vel)
                    drawRect(left + 2, y, s.w - 4, s.h - 4, s.col);
                    // Janelas com molduras
                    drawRect(cx - 12, y + 4, 8, 6, '#87ceeb'); // Janela esquerda
                    drawRect(cx - 11, y + 5, 6, 1, '#fff'); // Moldura interna
                    drawRect(cx - 11, y + 8, 6, 1, '#fff'); // Moldura interna
                    drawRect(cx + 4, y + 4, 8, 6, '#87ceeb'); // Janela direita
                    drawRect(cx + 5, y + 5, 6, 1, '#fff'); // Moldura interna
                    drawRect(cx + 5, y + 8, 6, 1, '#fff'); // Moldura interna
                    // Porta frontal (com anima√ß√£o de abertura)
                    const doorOffset = dollhouseDoorAnimation * 3; // Porta se abre para a direita
                    drawRect(cx - 2 + doorOffset, y + 12, 4, 10, '#654321');
                    // Ma√ßaneta da porta
                    drawCircle(cx + 1 + doorOffset, y + 17, 0.5, '#daa520');

                    // Detalhes decorativos na parede
                    drawCircle(cx - 10, y + 2, 1, '#ffd700'); // Estrela decorativa
                    drawCircle(cx + 10, y + 2, 1, '#ffd700');

                    // Luz nas janelas quando a porta est√° aberta
                    if (dollhouseDoorOpen) {
                        drawRect(cx - 11, y + 5, 4, 4, 'rgba(255, 255, 0, 0.6)'); // Janela esquerda iluminada
                        drawRect(cx + 5, y + 5, 4, 4, 'rgba(255, 255, 0, 0.6)'); // Janela direita iluminada
                    }

                    // Jardim frontal simples
                    drawRect(left, y + s.h - 2, s.w, 2, '#4caf50');
                    drawCircle(cx - 6, y + s.h - 1, 1, '#ff69b4'); // Flor
                    drawCircle(cx + 6, y + s.h - 1, 1, '#ff69b4');

                    // Indicador visual de interatividade
                    const blinkHouse = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx, y + 6, 0.8, `rgba(255, 192, 203, ${blinkHouse})`);
                    break;

                case 'sandbox':
                    // Bordas refor√ßadas de madeira
                    drawRect(left, y, s.w, 4, '#8d6e63');
                    drawRect(left, y + s.h - 4, s.w, 4, '#8d6e63');
                    drawRect(left, y, 4, s.h, '#8d6e63');
                    drawRect(right - 4, y, 4, s.h, '#8d6e63');
                    // Cantos refor√ßados
                    drawRect(left, y, 6, 6, '#a1887f');
                    drawRect(right - 6, y, 6, 6, '#a1887f');
                    drawRect(left, y + s.h - 6, 6, 6, '#a1887f');
                    drawRect(right - 6, y + s.h - 6, 6, 6, '#a1887f');
                    // Areia com textura realista
                    drawRect(left + 4, y + 4, s.w - 8, s.h - 8, s.col);
                    // Gr√£os de areia individuais
                    for(let i = 0; i < 25; i++) {
                        const sandX = left + 6 + Math.random() * (s.w - 12);
                        const sandY = y + 6 + Math.random() * (s.h - 12);
                        const size = 0.5 + Math.random() * 1.5;
                        drawCircle(sandX, sandY, size, '#a1887f');
                    }
                    // P√° e balde decorativos
                    drawRect(cx - 10, y + 2, 4, 8, '#8d6e63');
                    drawRect(cx - 12, y, 2, 4, '#8d6e63'); // Cabo da p√°
                    drawRect(cx + 6, y + 4, 6, 6, '#ff5722'); // Balde
                    drawRect(cx + 5, y + 2, 8, 2, '#c62828'); // Cabo do balde
                    // Sombras na areia
                    drawEllipse(cx - 8, y + s.h - 2, 6, 2, 'rgba(0, 0, 0, 0.3)');
                    drawEllipse(cx + 8, y + s.h - 2, 4, 1.5, 'rgba(0, 0, 0, 0.3)');
                    break;

                case 'jungle_gym':
                    // Estrutura complexa de tubos met√°licos
                    drawRect(cx - 1, y, 2, s.h, '#c62828');
                    // Barras horizontais em diferentes alturas
                    drawRect(cx - 18, y + 8, 36, 4, '#d32f2f');
                    drawRect(cx - 15, y + 20, 30, 4, '#d32f2f');
                    drawRect(cx - 12, y + 32, 24, 4, '#d32f2f');
                    // Barras verticais conectando
                    drawRect(cx - 18, y, 4, s.h, '#c62828');
                    drawRect(cx + 14, y, 4, s.h, '#c62828');
                    drawRect(cx - 8, y + 12, 4, 20, '#e53935');
                    drawRect(cx + 4, y + 12, 4, 20, '#e53935');
                    // Escada com degraus
                    for(let i = 0; i < 8; i++) {
                        drawRect(cx - 14, y + 8 + i*4, 12, 2, '#f44336');
                    }
                    // Argolas para escalar
                    for(let i = 0; i < 4; i++) {
                        drawCircle(cx - 6, y + 16 + i*6, 2, '#ff5722');
                        drawCircle(cx + 6, y + 16 + i*6, 2, '#ff5722');
                    }
                    // Escorregador espiral
                    ctx.strokeStyle = '#2196f3';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(scx + 14, sy + 20, 8, Math.PI/2, Math.PI * 2.5);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(scx + 14, sy + 28, 6, Math.PI/2, Math.PI * 2.5);
                    ctx.stroke();
                    // Plataforma de observa√ß√£o
                    drawRect(cx + 6, y + 36, 12, 3, '#e53935');
                    // Sombras complexas
                    drawRect(cx - 20, y + s.h + 2, 40, 3, 'rgba(0, 0, 0, 0.2)');
                    break;

                case 'spring_rider':
                    // Base circular com molas
                    drawEllipse(cx, y + 14, 10, 4, '#616161');
                    // Molas helicoidais
                    for(let i = 0; i < 5; i++) {
                        const springX = cx - 8 + i*4;
                        for(let j = 0; j < 4; j++) {
                            drawCircle(springX + Math.sin(j * 1.5) * 1, y + 8 + j*1.5, 0.8, '#424242');
                        }
                    }
                    // Brinquedo (cavalo) com crina
                    drawRect(cx - 6, y, 12, 10, s.col);
                    // Cabe√ßa com detalhes
                    drawCircle(cx, y - 3, 4, s.col);
                    drawCircle(cx - 1, y - 5, 1, s.col); // Orelha esquerda
                    drawCircle(cx + 1, y - 5, 1, s.col); // Orelha direita
                    // Olhos
                    drawCircle(cx - 1.5, y - 3, 0.8, '#fff');
                    drawCircle(cx + 1.5, y - 3, 0.8, '#fff');
                    drawCircle(cx - 1.5, y - 3, 0.3, '#000');
                    drawCircle(cx + 1.5, y - 3, 0.3, '#000');
                    // Crina ondulada
                    for(let i = 0; i < 5; i++) {
                        drawRect(cx - 5 + i*2, y - 6, 1, 3 + Math.sin(i) * 1, '#ffeb3b');
                    }
                    // Rabo
                    drawRect(cx + 6, y + 2, 1, 6, '#ffeb3b');
                    // Movimento bouncing
                    const bounceOffset = Math.sin(getGameTime() / 800) * 2;
                    drawRect(cx - 6, y + bounceOffset, 12, 10, s.col);
                    drawCircle(cx, y - 3 + bounceOffset, 4, s.col);
                    // Sombra din√¢mica
                    drawEllipse(cx, y + 18 + bounceOffset*0.5, 10, 3, 'rgba(0, 0, 0, 0.2)');
                    break;

                case 'ball_pit':
                    // Estrutura de conten√ß√£o
                    drawRect(left, y, s.w, 4, '#8d6e63');
                    drawRect(left, y + s.h - 4, s.w, 4, '#8d6e63');
                    drawRect(left, y, 4, s.h, '#8d6e63');
                    drawRect(right - 4, y, 4, s.h, '#8d6e63');
                    // Rede de prote√ß√£o superior
                    drawRect(left + 2, y, s.w - 4, 2, '#c0c0c0');
                    for(let i = 0; i < 6; i++) {
                        drawLine(left + 4 + i*4, y, left + 4 + i*4, y + 8, 1, '#c0c0c0');
                    }
                    // Bolas coloridas em camadas
                    const ballColors = ['#ff5722', '#2196f3', '#4caf50', '#ff9800', '#9c27b0', '#ffeb3b', '#e91e63'];
                    for(let layer = 0; layer < 4; layer++) {
                        for(let i = 0; i < 8 + layer*2; i++) {
                            const ballX = left + 6 + Math.random() * (s.w - 12);
                            const ballY = y + 8 + layer*3 + Math.random() * 3;
                            const ballSize = 1.5 + Math.random() * 1;
                            const ballCol = ballColors[Math.floor(Math.random() * ballColors.length)];
                            drawCircle(ballX, ballY, ballSize, ballCol);
                            // Brilho nas bolas
                            drawCircle(ballX - 0.5, ballY - 0.5, ballSize * 0.3, 'rgba(255, 255, 255, 0.6)');
                        }
                    }
                    // Sombras das bolas
                    drawEllipse(cx, y + s.h - 2, s.w/2 - 4, 2, 'rgba(0, 0, 0, 0.15)');
                    break;

                case 'teddy_bear':
                    // Ursinho de pel√∫cia grande e fofinho com anima√ß√£o de acenar
                    // Corpo arredondado
                    drawEllipse(cx, y + 16, 6, 8, s.col);
                    // Cabe√ßa grande e redonda
                    drawCircle(cx, y + 4, 7, s.col);
                    // Olhos grandes e expressivos
                    drawCircle(cx - 2, y + 2, 1.5, '#fff');
                    drawCircle(cx + 2, y + 2, 1.5, '#fff');
                    drawCircle(cx - 2, y + 2, 0.8, '#000');
                    drawCircle(cx + 2, y + 2, 0.8, '#000');
                    // Nariz pequeno e fofo
                    drawCircle(cx, y + 5, 0.8, '#ff69b4');
                    // Boca sorridente
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(scx, sy + 6, 2, 0, Math.PI);
                    ctx.stroke();
                    // Orelhas peludas
                    drawCircle(cx - 5, y - 1, 3, s.col);
                    drawCircle(cx + 5, y - 1, 3, s.col);
                    drawCircle(cx - 5, y - 1, 2, '#daa520'); // Interior das orelhas
                    drawCircle(cx + 5, y - 1, 2, '#daa520');

                    // Bra√ßos fofos (com anima√ß√£o de acenar)
                    drawEllipse(cx - 8, y + 12, 3, 5, s.col); // Bra√ßo esquerdo sempre parado

                    if (teddyBearWaving) {
                        // Anima√ß√£o de acenar - bra√ßo direito se move
                        const waveOffsetX = Math.sin(teddyBearAnimation * Math.PI * 4) * 3;
                        const waveOffsetY = Math.sin(teddyBearAnimation * Math.PI * 2) * 2;
                        drawEllipse(cx + 8 + waveOffsetX, y + 12 + waveOffsetY, 3, 5, s.col);

                        // Cora√ß√£o flutuante quando acenando
                        if (teddyBearAnimation < 0.8) {
                            const heartY = y - 2 - teddyBearAnimation * 20;
                            drawCircle(cx + 10, heartY, 1.5, '#ff1493');
                            drawCircle(cx + 12, heartY, 1.5, '#ff1493');
                            drawTriangle(cx + 9, heartY, cx + 13, heartY, cx + 11, heartY + 2, '#ff1493');
                        }
                    } else {
                        drawEllipse(cx + 8, y + 12, 3, 5, s.col); // Bra√ßo direito normal
                    }

                    // Pernas
                    drawEllipse(cx - 4, y + 22, 3, 4, s.col);
                    drawEllipse(cx + 4, y + 22, 3, 4, s.col);
                    // Detalhes fofos - bot√µes ou la√ßos
                    drawCircle(cx, y + 16, 1, '#ff1493'); // La√ßo no peito
                    drawCircle(cx - 0.5, y + 16, 0.8, '#daa520');
                    drawCircle(cx + 0.5, y + 16, 0.8, '#daa520');
                    // Sombras suaves para dar volume
                    drawEllipse(cx, y + 25, 8, 2, 'rgba(0, 0, 0, 0.2)');

                    // Indicador visual de interatividade (piscando suavemente quando n√£o est√° acenando)
                    if (!teddyBearWaving) {
                        const blinkTeddy = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                        drawCircle(cx + 6, y + 8, 0.8, `rgba(255, 69, 184, ${blinkTeddy})`);
                    }
                    break;

                case 'tire_swing':
                    // Pneu reciclado como balan√ßo
                    ctx.strokeStyle = '#424242';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(scx, sy + 10, 5, 0, Math.PI * 2);
                    ctx.stroke();
                    // Desenho do pneu com textura
                    for(let i = 0; i < 12; i++) {
                        const angle = (i * Math.PI * 2) / 12;
                        const treadX = scx + Math.cos(angle) * 4.5;
                        const treadY = sy + 10 + Math.sin(angle) * 4.5;
                        drawCircle(treadX, treadY, 0.5, '#333');
                    }
                    // Cordas grossas
                    drawLine(cx, y, cx - 4, y + 10, 2, '#8d6e63');
                    drawLine(cx, y, cx + 4, y + 10, 2, '#8d6e63');
                    // N√≥s nas cordas
                    drawCircle(cx - 4, y + 5, 1, '#654321');
                    drawCircle(cx + 4, y + 5, 1, '#654321');
                    // Movimento pendular
                    const tireOffset = Math.sin(getGameTime() / 1000) * 4;
                    ctx.strokeStyle = '#424242';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(scx + tireOffset, sy + 10, 5, 0, Math.PI * 2);
                    ctx.stroke();
                    // Sombra m√≥vel
                    drawEllipse(cx + tireOffset, y + 18, 6, 2, 'rgba(0, 0, 0, 0.25)');
                    break;

                case 'test_cube': // Cubo Vermelho
                    drawRect(cx - 4, y, 8, 8, '#ff0000');
                    break;

                // === MANTIDOS (Conforme Pedido) ===
                case 'water_cooler':
                    drawRoundRect(left, y + 16, s.w, s.h - 16, 2, '#eceff1');

                    if (waterCoolerActive) {
                        // √Ågua jorrando do bico
                        const waterFlow = Math.sin(time / 200) * 0.3 + 0.7;
                        ctx.fillStyle = `rgba(3, 169, 244, ${0.6 * waterFlow})`;
                        ctx.beginPath();
                        ctx.arc(scx, sy + 8, 7 * waterFlow, 0, Math.PI * 2);
                        ctx.fill();

                        // Gotas caindo
                        for(let i = 0; i < 3; i++) {
                            const dropY = y + 18 + (time / 100 + i * 50) % 20;
                            const dropX = cx + Math.sin(time / 300 + i) * 3;
                            const dropSize = 0.8 + Math.sin(time / 150 + i) * 0.4;

                            if(dropY < y + s.h) {
                                drawEllipse(dropX, dropY, dropSize * 0.4, dropSize, 'rgba(3, 169, 244, 0.8)');
                                // Brilho na gota
                                drawCircle(dropX - 0.2, dropY - 0.3, dropSize * 0.3, 'rgba(255, 255, 255, 0.6)');
                            }

                            // Ondas na √°gua acumulada
                            if(dropY >= y + 20) {
                                const rippleRadius = (time / 50 + i * 10) % 15;
                                if(rippleRadius < 8) {
                                    ctx.strokeStyle = `rgba(100, 200, 255, ${(8 - rippleRadius) / 8 * 0.5})`;
                                    ctx.lineWidth = 1;
                                    ctx.beginPath();
                                    ctx.arc(scx, sy + 8, rippleRadius, 0, Math.PI * 2);
                                    ctx.stroke();
                                }
                            }
                        }

                        // Bot√£o azul pressionado (parece mais escuro)
                        drawRect(cx - 3, y + 24, 2, 4, '#0066cc');
                        drawRect(cx + 1, y + 24, 2, 4, 'red');

                        // Vapor subindo
                        for(let i = 0; i < 2; i++) {
                            const steamY = y + 12 - (time / 80 + i * 30) % 10;
                            if(steamY > y + 8) {
                                drawCircle(cx + Math.sin(time / 250 + i) * 2, steamY, 0.6, `rgba(200, 220, 255, ${(y + 12 - steamY) / 10})`);
                            }
                        }
                    } else {
                        // Estado inativo
                    ctx.fillStyle = 'rgba(3, 169, 244, 0.6)';
                    ctx.beginPath();
                    ctx.arc(scx, sy + 8, 7, 0, Math.PI * 2);
                    ctx.fill();
                    drawRect(cx - 3, y + 24, 2, 4, 'blue');
                    drawRect(cx + 1, y + 24, 2, 4, 'red');
                    }

                    // Indicador visual de interatividade
                    const blinkWater = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx, y + 12, 0.8, `rgba(100, 150, 255, ${blinkWater})`);
                    break;

                case 'painting': 
                    drawRect(left, y, s.w, s.h, '#5d4037'); 
                    drawRect(left + 2, y + 2, s.w - 4, s.h - 4, '#fff'); 
                    const artSeed = seed + cx;
                    const numShapes = 3 + Math.floor(pseudoRandom(artSeed) * 4);
                    for(let i=0; i<numShapes; i++) {
                        const rCol = `hsl(${Math.floor(pseudoRandom(artSeed+i)*360)}, 70%, 50%)`;
                        ctx.fillStyle = rCol;
                        const shapeType = pseudoRandom(artSeed+i+1);
                        const px = sx + 4 + pseudoRandom(artSeed+i+2) * (s.w - 12);
                        const py = sy + 4 + pseudoRandom(artSeed+i+3) * (s.h - 12);
                        const size = 4 + pseudoRandom(artSeed+i+4) * 8;
                        ctx.beginPath();
                        if (shapeType < 0.33) ctx.arc(px, py, size/2, 0, Math.PI*2);
                        else if (shapeType < 0.66) ctx.rect(px - size/2, py - size/2, size, size);
                        else {
                            ctx.moveTo(px, py - size/2);
                            ctx.lineTo(px + size/2, py + size/2);
                            ctx.lineTo(px - size/2, py + size/2);
                        }
                        ctx.fill();
                    }
                    break;

                case 'floor_lamp': // Lumin√°ria de Piso com Estado de Energia
                    // Base pesada
                    drawRect(cx - 3, y + 16, 6, 2, '#424242');

                    // Haste vertical
                    drawRect(cx - 2, y + 16, 4, s.h - 16, '#212121');
                    drawRect(cx - 1.5, y + 17, 3, s.h - 18, '#666');

                    // Bra√ßo horizontal
                    drawRect(cx - 8, y, 16, 2, '#212121');
                    drawRect(cx - 7.5, y + 0.5, 15, 1, '#666');

                    // Abajur (difusor)
                    ctx.fillStyle = s.col;
                    ctx.beginPath();
                    ctx.moveTo(scx - 8, sy);
                    ctx.lineTo(scx + 8, sy);
                    ctx.lineTo(scx + 12, sy + 16);
                    ctx.lineTo(scx - 12, sy + 16);
                    ctx.closePath();
                    ctx.fill();

                    // Moldura do abajur
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    // Efeito de luz - s√≥ quando ligada
                    if (floorLampOn) {
                        ctx.fillStyle = 'rgba(255, 235, 59, 0.4)';
                        ctx.beginPath();
                        ctx.moveTo(scx - 12, sy + 16);
                        ctx.lineTo(scx + 12, sy + 16);
                        ctx.lineTo(scx + 20, sy + 60);
                        ctx.lineTo(scx - 20, sy + 60);
                        ctx.fill();

                        // Filamento vis√≠vel
                        drawCircle(cx, y + 8, 0.3, '#ffff88');
                    }

                    // Interruptor na base
                    let floorSwitchColor = floorLampOn ? '#4caf50' : '#ff5722';
                    drawCircle(cx, y + 17.5, 0.4, floorSwitchColor);

                    break;

                case 'sofa':
                    drawRoundRect(left, y + 12, 8, s.h - 12, 3, '#455a64'); 
                    drawRoundRect(right - 8, y + 12, 8, s.h - 12, 3, '#455a64');
                    drawRect(left + 8, y + 20, s.w - 16, s.h - 20, s.col);
                    drawLine(cx, y + 20, cx, y + s.h, 1, 'rgba(0,0,0,0.2)');
                    drawRoundRect(left + 6, y, s.w - 12, 20, 4, '#37474f');
                    break;

                case 'speaker':
                    drawRoundRect(left, y, s.w, s.h, 2, '#212121');
                    drawCircle(cx, y + s.h - 12, 6, '#424242');
                    drawCircle(cx, y + s.h - 12, 2, '#111');
                    drawCircle(cx, y + 10, 3, '#424242');
                    if (Math.floor(time / 100) % 2 === 0) drawCircle(cx, y + s.h - 12, 7, 'rgba(255,255,255,0.1)');
                    break;

                case 'tv':
                    drawRoundRect(left, y, s.w, s.h, 2, '#111'); 
                    const screenW = s.w - 4;
                    const screenH = s.h - 4;
                    const tvSx = sx + 2;
                    const tvSy = sy + 2;

                    if (tvActive) {
                        // Tela ligada mostrando diferentes canais
                        switch (tvChannel) {
                            case 0: // Canal de not√≠cias (azul com texto)
                         ctx.fillStyle = '#1565c0';
                         ctx.fillRect(tvSx, tvSy, screenW, screenH * 0.7);
                         ctx.fillStyle = '#fff';
                         ctx.fillRect(tvSx + 5, tvSy + screenH * 0.7 + 2, screenW - 10, 2);
                                // Texto de not√≠cia simulada
                                drawText('BREAKING NEWS', tvSx + 5, tvSy + 8, 1, '#fff');
                                drawText('TECHNOLOGY UPDATE', tvSx + 5, tvSy + 16, 1, '#ffff00');
                                break;

                            case 1: // Canal esportivo (verde com bola)
                         ctx.fillStyle = '#aeea00';
                         ctx.fillRect(tvSx, tvSy, screenW, screenH);
                                // Bola animada
                         ctx.fillStyle = '#ff4081';
                                const ballX = tvSx + 10 + Math.sin(time / 300) * 15;
                                const ballY = tvSy + screenH/2 + Math.cos(time / 200) * 8;
                                ctx.beginPath();
                                ctx.arc(ballX, ballY, 3, 0, Math.PI * 2);
                                ctx.fill();
                                // Campo
                                ctx.strokeStyle = '#fff';
                                ctx.lineWidth = 1;
                                ctx.strokeRect(tvSx + 2, tvSy + 2, screenW - 4, screenH - 4);
                                // Gols
                                drawRect(tvSx, tvSy + screenH/2 - 5, 3, 10, '#fff');
                                drawRect(tvSx + screenW - 3, tvSy + screenH/2 - 5, 3, 10, '#fff');
                                break;

                            case 2: // Canal de desenhos (colorido com formas)
                                // Fundo colorido
                                for(let x=0; x<screenW; x+=4) {
                                    for(let y_pos=0; y_pos<screenH; y_pos+=4) {
                                        const hue = (x + y_pos + time/100) % 360;
                                        ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                                        ctx.fillRect(tvSx + x, tvSy + y_pos, 4, 4);
                                    }
                                }
                                // Formas animadas
                                const shapeCount = 5;
                                for(let i=0; i<shapeCount; i++) {
                                    const shapeX = tvSx + 10 + (i * screenW / shapeCount);
                                    const shapeY = tvSy + 10 + Math.sin(time / 400 + i) * 8;
                                    const shapeColor = `hsl(${(time / 50 + i * 60) % 360}, 80%, 60%)`;

                                    if(i % 2 === 0) {
                                        // C√≠rculos
                                        ctx.fillStyle = shapeColor;
                                        ctx.beginPath();
                                        ctx.arc(shapeX, shapeY, 3, 0, Math.PI * 2);
                                        ctx.fill();
                    } else {
                                        // Quadrados
                                        drawRect(shapeX - 2, shapeY - 2, 4, 4, shapeColor);
                                    }
                                }
                                break;

                            case 3: // Canal de filme (neve/static)
                                ctx.fillStyle = '#000';
                                ctx.fillRect(tvSx, tvSy, screenW, screenH);
                                // Ru√≠do de static
                                for(let i=0; i<50; i++) {
                                    const noiseX = tvSx + Math.random() * screenW;
                                    const noiseY = tvSy + Math.random() * screenH;
                                    const brightness = Math.random();
                                    ctx.fillStyle = `rgb(${brightness*255}, ${brightness*255}, ${brightness*255})`;
                                    ctx.fillRect(noiseX, noiseY, 1, 1);
                                }
                                // Faixas horizontais de interfer√™ncia
                                for(let i=0; i<3; i++) {
                                    const interferenceY = tvSy + (time / 100 + i * 10) % screenH;
                                    ctx.fillStyle = `rgba(0, 255, 255, 0.5)`;
                                    ctx.fillRect(tvSx, interferenceY, screenW, 2);
                                }
                                break;
                        }

                        // LED de energia ligado
                        drawCircle(cx, y + s.h - 3, 2, '#00ff00');
                    } else {
                        // TV desligada - tela preta
                        ctx.fillStyle = '#000';
                        ctx.fillRect(tvSx, tvSy, screenW, screenH);
                        drawCircle(cx, y + s.h - 3, 2, '#ff0000');
                    }

                    // Antenas
                    drawLine(cx, y, cx - 6, y - 8, 1, '#999');
                    drawLine(cx, y, cx + 6, y - 8, 1, '#999');

                    // Indicador visual de interatividade
                    const blinkTV = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx + 8, y + 2, 0.8, `rgba(255, 255, 0, ${blinkTV})`);
                    break;

                case 'filing_cabinet': 
                    drawRoundRect(left, y, s.w, s.h, 2, s.col);
                    for(let i=0; i<4; i++) {
                        const gy = y + 2 + (i * (s.h/4));
                        drawRect(left + 2, gy, s.w - 4, (s.h/4) - 2, '#cfd8dc');
                        drawRect(cx - 3, gy + 4, 6, 2, '#90a4ae'); 
                    }
                    break;

                case 'desk': 
                    drawRect(left, y, s.w, 4, s.col); 
                    drawRect(left, y + 4, 4, s.h - 4, s.col); 
                    drawRect(right - 14, y + 4, 14, s.h - 4, s.col);
                    drawRect(right - 12, y + 8, 10, 6, '#5d4037'); 
                    drawRect(right - 12, y + 18, 10, 6, '#5d4037'); 
                    break;

                case 'chair':
                    drawRect(left + 3, y + s.h/2, s.w - 6, 4, '#3e2723');
                    drawRect(left + 3, y, 3, s.h, '#5d4037');
                    drawLine(left + 3, y + 5, left + s.w - 3, y + 5, 2, '#5d4037');
                    drawRect(right - 5, y + s.h/2, 3, s.h/2, '#5d4037');
                    break;

                case 'bed':
                    drawRect(left, y + 10, s.w, s.h - 10, '#cfd8dc'); 
                    drawRect(left + 4, 4, s.h - 4, s.wood); 
                    drawRect(right - 4, y + 14, 4, s.h - 14, s.wood); 
                    drawRect(left + 4, y + 12, s.w - 8, s.h - 12, '#3949ab'); 
                    drawRoundRect(left + 6, y + 6, 12, 6, 3, '#fff');
                    break;

                case 'bunk_bed': 
                    drawRect(left, y, 4, s.h, s.wood);
                    drawRect(right - 4, y, 4, s.h, s.wood);
                    drawRect(left + 4, y + s.h - 20, s.w - 8, 10, '#3949ab');
                    drawRect(left + 4, y + 20, s.w - 8, 10, '#3949ab');
                    drawRect(cx - 6, y, 2, s.h, s.wood);
                    drawRect(cx + 6, y, 2, s.h, s.wood);
                    for(let i=1; i<5; i++) drawRect(cx - 6, y + (i*12), 14, 2, s.wood);
                    break;

                case 'wardrobe':
                    drawRect(left, y, s.w, s.h, s.col);
                    drawRect(left + 2, y + 4, (s.w/2) - 3, s.h - 8, '#5d4037');
                    drawRect(cx + 1, y + 4, (s.w/2) - 3, s.h - 8, '#5d4037');
                    drawCircle(cx - 2, y + s.h/2, 2, 'gold');
                    drawCircle(cx + 2, y + s.h/2, 2, 'gold');
                    break;

                case 'coat_rack':
                    drawRect(cx - 1, y, 2, s.h, s.col); 
                    drawRect(cx - 6, floorY - 2, 12, 2, s.col); 
                    drawLine(cx, y + 10, cx - 6, y + 6, 2, s.col);
                    drawLine(cx, y + 10, cx + 6, y + 6, 2, s.col);
                    drawLine(cx, y + 20, cx - 6, y + 16, 2, s.col);
                    drawLine(cx, y + 20, cx + 6, y + 16, 2, s.col);
                    break;

                case 'arcade':
                    // Estrutura externa do fliperama
                    ctx.fillStyle = s.col;
                    ctx.beginPath();
                    ctx.moveTo(sx + 6, sy);
                    ctx.lineTo(sx + s.w, sy);
                    ctx.lineTo(sx + s.w, sy + s.h);
                    ctx.lineTo(sx, sy + s.h);
                    ctx.lineTo(sx, sy + s.h/2);
                    ctx.lineTo(sx + 6, sy + s.h/2 - 6);
                    ctx.fill();

                    // Tela do jogo
                    drawRect(left + 8, y + 10, s.w - 12, 16, '#000');

                    if (arcadeActive) {
                        // Tela ativa com jogo tipo Pacman
                        const screenX = left + 10;
                        const screenY = y + 12;
                        const screenW = s.w - 16;
                        const screenH = 12;

                        // Fundo da tela
                        drawRect(screenX, screenY, screenW, screenH, '#000');

                        // Labirinto simples
                        ctx.strokeStyle = '#2121de';
                        ctx.lineWidth = 1;
                        // Paredes horizontais
                        for(let i=0; i<3; i++) {
                            drawRect(screenX + 2, screenY + 2 + i*3, screenW - 4, 1, '#2121de');
                        }
                        // Paredes verticais
                        for(let i=0; i<4; i++) {
                            drawRect(screenX + 2 + i*(screenW-4)/3, screenY + 2, 1, screenH - 2, '#2121de');
                        }

                        // Pacman animado
                        const pacmanX = screenX + 4 + Math.sin(arcadeAnimation * Math.PI * 2) * 6;
                        const pacmanY = screenY + 6 + Math.cos(arcadeAnimation * Math.PI * 4) * 2;
                        const mouthAngle = Math.sin(arcadeAnimation * Math.PI * 6) * 0.5 + 0.5;

                        ctx.fillStyle = '#ffff00';
                        ctx.beginPath();
                        ctx.arc(pacmanX, pacmanY, 2, mouthAngle * Math.PI, (2 - mouthAngle) * Math.PI);
                        ctx.lineTo(pacmanX, pacmanY);
                        ctx.fill();

                        // Fantasmas coloridos
                        const ghostColors = ['#ff0000', '#ffb8ff', '#00ffff', '#ffb852'];
                        for(let i=0; i<4; i++) {
                            const ghostX = screenX + screenW - 8 + Math.sin(arcadeAnimation * Math.PI * 2 + i) * 3;
                            const ghostY = screenY + 4 + i * 2;
                            const ghostFloat = Math.sin(arcadeAnimation * Math.PI * 3 + i) * 0.5;

                            // Corpo do fantasma
                            drawRect(ghostX - 1, ghostY + ghostFloat, 3, 3, ghostColors[i]);
                            // Olhos
                            drawCircle(ghostX - 0.5, ghostY + 0.5 + ghostFloat, 0.3, '#fff');
                            drawCircle(ghostX + 0.5, ghostY + 0.5 + ghostFloat, 0.3, '#fff');
                            // Pupilas
                            drawCircle(ghostX - 0.5, ghostY + 0.5 + ghostFloat, 0.1, '#000');
                            drawCircle(ghostX + 0.5, ghostY + 0.5 + ghostFloat, 0.1, '#000');
                        }

                        // Bolinhas de comida
                        for(let i=0; i<8; i++) {
                            const dotX = screenX + 6 + (i % 4) * 8;
                            const dotY = screenY + 4 + Math.floor(i / 4) * 6;
                            const dotBlink = Math.floor(time / 200 + i) % 2;
                            if(dotBlink) drawCircle(dotX, dotY, 0.5, '#ffb897');
                        }

                        // Pontua√ß√£o
                        drawText('SCORE: ' + Math.floor(arcadeAnimation * 1000), screenX + 2, screenY + screenH - 2, 1, '#fff');
                    } else {
                        // Tela inativa
                        drawRect(left + 10, y + 12, s.w - 16, 12, '#000080');
                        drawText('INSERT COIN', cx - 15, y + 18, 2, '#ffff00');
                    }

                    // Controles inferiores
                    drawRect(left, y + s.h/2, s.w, 8, '#ad1457');
                    drawCircle(cx - 4, y + s.h/2 - 2, 2, 'red'); 
                    drawCircle(cx + 4, y + s.h/2 + 2, 1, 'yellow');

                    // Indicador visual de interatividade
                    const blinkArcade = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx, y + 8, 0.8, `rgba(0, 255, 0, ${blinkArcade})`);
                    break;

                case 'tv_stand': 
                     drawRoundRect(left, y, s.w, s.h, 2, '#424242');
                     drawRect(left + 2, y + 4, (s.w/3) - 2, s.h - 8, '#616161'); 
                     drawRect(right - (s.w/3), y + 4, (s.w/3) - 2, s.h - 8, '#616161'); 
                     drawRect(left + (s.w/3) + 2, y + 4, (s.w/3) - 4, 4, '#111'); 
                     break;

                case 'fountain':
                    drawRoundRect(left, y + s.h - 10, s.w, 10, 2, '#cfd8dc');
                    drawRect(cx - 10, y + 10, 20, 4, '#cfd8dc');
                    drawRect(cx - 2, y + 14, 4, s.h - 24, '#cfd8dc'); 
                    ctx.fillStyle = 'rgba(0, 229, 255, 0.6)';
                    for(let i=0; i<3; i++) {
                        const dropY = (time/5 + i*10) % 15;
                        drawRect(cx - 8, y + 14 + dropY, 2, 2, null); 
                        drawRect(cx + 6, y + 14 + dropY, 2, 2, null); 
                    }
                    ctx.fill();
                    break;

                case 'bush':
                    ctx.fillStyle = '#2e7d32';
                    drawCircle(cx - 6, y + 10, 8, null);
                    drawCircle(cx + 6, y + 12, 8, null);
                    drawCircle(cx, y + 6, 9, null);
                    ctx.fillStyle = 'red';
                    drawCircle(cx - 4, y + 8, 2, null);
                    drawCircle(cx + 5, y + 14, 2, null);
                    break;

                case 'statue':
                    drawRect(left, y + s.h - 8, s.w, 8, '#757575');
                    ctx.fillStyle = '#bdbdbd';
                    ctx.beginPath();
                    ctx.arc(scx, sy + 8, 5, 0, Math.PI*2); 
                    ctx.fill();
                    drawRect(cx - 6, y + 14, 12, 16, '#bdbdbd'); 
                    drawRect(cx - 4, y + 30, 8, s.h - 38, '#bdbdbd'); 
                    break;

                case 'street_lamp': // Poste de Luz com Estado
                    // Poste vertical
                    drawRect(cx - 1, y, 2, s.h, '#212121');
                    drawRect(cx - 0.8, y + 1, 1.6, s.h - 2, '#666');

                    // Bra√ßo horizontal
                    drawRect(cx - 5, y + 4, 10, 2, '#212121');
                    drawRect(cx - 4.5, y + 4.5, 9, 1, '#666');

                    // Lumin√°ria
                    drawRect(cx - 4, y + 2, 8, 3, '#424242');

                    // Bulbo e luz - s√≥ quando ligado
                    if (streetLampOn) {
                        drawCircle(cx, y + 3.5, 1, '#ffeb3b'); // Bulbo
                        drawCircle(cx, y + 3.5, 0.6, '#ffffff'); // Centro brilhante

                        // Feixe de luz para baixo
                        ctx.fillStyle = 'rgba(255, 235, 59, 0.3)';
                        ctx.beginPath();
                        ctx.moveTo(cx - 6, y + 6);
                        ctx.lineTo(cx + 6, y + 6);
                        ctx.lineTo(cx + 12, y + 20);
                        ctx.lineTo(cx - 12, y + 20);
                        ctx.fill();
                    } else {
                        drawCircle(cx, y + 3.5, 1, '#666'); // Bulbo apagado
                    }

                    // Cabo el√©trico
                    drawLine(cx + 2, y + 6, cx + 8, y + 6, 0.5, '#000');

                    break;

                case 'garden_bench':
                    drawRect(left, y + 10, s.w, 4, s.col); 
                    drawRect(left, y + 16, s.w, 4, s.col); 
                    drawRoundRect(left + 4, y + 20, 2, 6, 1, '#212121');
                    drawRoundRect(right - 6, y + 20, 2, 6, 1, '#212121');
                    drawRect(left, y + 12, 2, 6, '#212121');
                    drawRect(right - 2, y + 12, 2, 6, '#212121');
                    break;

                case 'robo_arm':
                    // Base do bra√ßo rob√¥
                    drawRect(cx - 6, y + s.h - 6, 12, 6, '#424242'); 

                    if (roboArmActive) {
                        // Anima√ß√£o do bra√ßo se movendo
                        const armAngle1 = Math.sin(roboArmAnimation * Math.PI * 2) * 0.3;
                        const armAngle2 = Math.sin(roboArmAnimation * Math.PI * 2 + Math.PI/4) * 0.4;
                        const armAngle3 = Math.sin(roboArmAnimation * Math.PI * 2 + Math.PI/2) * 0.2;

                    const jx = scx; 
                    const jy = sy + s.h - 6;

                    // Junta 1 (ombro)
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 6;
                    ctx.beginPath();
                    ctx.moveTo(jx, jy);
                    ctx.lineTo(jx + Math.cos(armAngle1) * 12, jy + Math.sin(armAngle1) * 12);
                    ctx.stroke();

                    // Junta 2 (cotovelo)
                    const elbowX = jx + Math.cos(armAngle1) * 12;
                    const elbowY = jy + Math.sin(armAngle1) * 12;
                    ctx.strokeStyle = '#888';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(elbowX, elbowY);
                    ctx.lineTo(elbowX + Math.cos(armAngle1 + armAngle2) * 10, elbowY + Math.sin(armAngle1 + armAngle2) * 10);
                    ctx.stroke();

                    // Junta 3 (pulso) com garra
                    const wristX = elbowX + Math.cos(armAngle1 + armAngle2) * 10;
                    const wristY = elbowY + Math.sin(armAngle1 + armAngle2) * 10;
                    ctx.strokeStyle = '#aaa';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(wristX, wristY);
                    ctx.lineTo(wristX + Math.cos(armAngle1 + armAngle2 + armAngle3) * 8, wristY + Math.sin(armAngle1 + armAngle2 + armAngle3) * 8);
                    ctx.stroke();

                    // Garra animada
                    const clawX = wristX + Math.cos(armAngle1 + armAngle2 + armAngle3) * 8;
                    const clawY = wristY + Math.sin(armAngle1 + armAngle2 + armAngle3) * 8;
                    const clawOpen = Math.sin(time / 300) * 2 + 3;

                    ctx.strokeStyle = '#ccc';
                    ctx.lineWidth = 2;
                    // Dedos da garra
                    ctx.beginPath();
                    ctx.moveTo(clawX, clawY);
                    ctx.lineTo(clawX - clawOpen, clawY + clawOpen);
                    ctx.moveTo(clawX, clawY);
                    ctx.lineTo(clawX + clawOpen, clawY + clawOpen);
                    ctx.stroke();

                        // Luz indicadora piscando
                        const lightIntensity = Math.sin(time / 200) > 0 ? 1 : 0.3;
                        drawCircle(cx, y + s.h - 3, 1.5, `rgba(255, 0, 0, ${lightIntensity})`);
                    } else {
                        // Estado inativo - bra√ßo parado
                        ctx.strokeStyle = '#666';
                        ctx.lineWidth = 6;
                        ctx.beginPath();
                        ctx.moveTo(cx, y + s.h - 6);
                        ctx.lineTo(cx + 8, y + s.h - 20);
                        ctx.stroke();

                        ctx.strokeStyle = '#888';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(cx + 8, y + s.h - 20);
                        ctx.lineTo(cx + 12, y + s.h - 30);
                        ctx.stroke();

                        ctx.strokeStyle = '#aaa';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(cx + 12, y + s.h - 30);
                        ctx.lineTo(cx + 14, y + s.h - 38);
                        ctx.stroke();

                        // Garra parada
                        ctx.strokeStyle = '#ccc';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(cx + 14, y + s.h - 38);
                        ctx.lineTo(cx + 12, y + s.h - 42);
                        ctx.moveTo(cx + 14, y + s.h - 38);
                        ctx.lineTo(cx + 16, y + s.h - 42);
                        ctx.stroke();

                        // Luz indicadora apagada
                        drawCircle(cx, y + s.h - 3, 1.5, 'rgba(255, 0, 0, 0.3)');
                    }

                    // Indicador visual de interatividade
                    const blinkRobo = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx + 8, y + s.h - 2, 0.8, `rgba(255, 100, 100, ${blinkRobo})`);
                    break;

                case 'safety_shower':
                    // Estrutura b√°sica
                    drawRect(cx + 8, y, 2, s.h, '#fbc02d'); 
                    drawRect(cx, y, 10, 2, '#fbc02d'); 
                    drawRect(cx, y, 2, 4, '#fbc02d'); 
                    drawRect(cx + 6, y + 40, 4, 2, '#fbc02d');

                    if (safetyShowerActive) {
                        // Chuveiro com efeito pulsante
                    const showerPulse = Math.sin(time / 400) * 0.5 + 1;
                    drawCircle(cx + 4, y + 40, 3 * showerPulse, '#e0e0e0');

                    // √Ågua caindo em gotas
                    for(let i=0; i<8; i++) {
                        const dropY = y + 45 + (time / 30 + i * 10) % 35;
                        const dropX = cx + 2 + Math.sin(time / 500 + i) * 3;
                        const dropSize = 0.8 + Math.sin(time / 200 + i * 2) * 0.3;

                        if(dropY < y + s.h) {
                            // Gota d'√°gua
                            drawEllipse(dropX, dropY, dropSize * 0.5, dropSize, 'rgba(100, 200, 255, 0.8)');
                            // Brilho na gota
                            drawCircle(dropX - 0.2, dropY - 0.3, dropSize * 0.3, 'rgba(255, 255, 255, 0.6)');
                        }

                        // Vapor subindo
                        const steamY = y + 35 - (time / 50 + i * 15) % 20;
                        if(steamY > y + 20) {
                            const steamAlpha = (y + 35 - steamY) / 20;
                            drawCircle(cx + 4 + Math.sin(time / 300 + i) * 2, steamY, 1, `rgba(200, 220, 255, ${steamAlpha * 0.5})`);
                        }
                    }

                        // LED de emerg√™ncia piscando
                        const emergencyLight = Math.floor(time / 500) % 2;
                        drawCircle(cx + 12, y + 5, 1.5, emergencyLight ? '#ff0000' : '#660000');
                    } else {
                        // Estado inativo - sem √°gua, LED fixo
                        drawCircle(cx + 4, y + 40, 2, '#c0c0c0');
                        drawCircle(cx + 12, y + 5, 1.5, '#660000');
                    }

                    // Indicador visual de interatividade
                    const blinkShower = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx - 2, y + 5, 0.8, `rgba(100, 150, 255, ${blinkShower})`);
                    break;

                case 'fridge':
                    drawRoundRect(left, y, s.w, s.h, 2, s.col);
                    drawLine(cx, y, cx, y + s.h, 1, '#90a4ae'); 

                    if (fridgeActive) {
                        // Compressor vibrando
                        const compressorVibration = Math.sin(time / 100) * 0.5;
                        drawRect(cx - 2 + compressorVibration, y + 20, 4, 8, '#37474f');

                        // Luz interna acesa
                        drawRect(cx - s.w/2 + 2, y + 2, s.w - 4, 10, 'rgba(255, 255, 100, 0.3)');

                        // Ventilador interno girando
                        const fanAngle = time / 50;
                        ctx.strokeStyle = '#666';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        for(let j=0; j<4; j++) {
                            const angle = fanAngle + (j * Math.PI / 2);
                            ctx.moveTo(cx, y + 25);
                            ctx.lineTo(cx + Math.cos(angle) * 3, y + 25 + Math.sin(angle) * 3);
                        }
                        ctx.stroke();

                        // Som visual (ondas sonoras)
                        for(let i=0; i<3; i++) {
                            const waveRadius = (time / 20 + i * 20) % 30;
                            if(waveRadius < 15) {
                                ctx.strokeStyle = `rgba(100, 150, 255, ${1 - waveRadius/15})`;
                                ctx.lineWidth = 1;
                                ctx.beginPath();
                                ctx.arc(cx, y + 25, waveRadius, 0, Math.PI * 2);
                                ctx.stroke();
                            }
                        }
                    } else {
                    drawRect(cx - 2, y + 20, 4, 8, '#37474f'); 
                    }

                    // Prateleiras sempre vis√≠veis
                    drawRect(cx - 4, y + 25, 2, 10, '#eee'); 
                    drawRect(cx + 2, y + 25, 2, 10, '#eee');

                    // Indicador visual de interatividade
                    const blinkFridge = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx + 6, y + 2, 0.8, `rgba(100, 200, 255, ${blinkFridge})`);
                    break;

                case 'stove':
                    drawRect(left, y, s.w, s.h, s.col);
                    drawRect(left + 2, y + 10, s.w - 4, 16, '#263238'); 

                    if (stoveActive) {
                        // Chamas animadas nas bocas
                        for(let burner=0; burner<4; burner++) {
                            const burnerX = left + 4 + burner * 6;
                            const burnerY = y + 12;

                            // Chamas dan√ßantes
                            for(let flame=0; flame<3; flame++) {
                                const flameHeight = 4 + Math.sin(time / 100 + burner + flame) * 2;
                                const flameWidth = 2 + Math.sin(time / 80 + burner + flame) * 0.5;
                                const flameX = burnerX + Math.sin(time / 150 + burner + flame) * 0.5;

                                // Gradiente de cor da chama (laranja/vermelho)
                                const flameColor = flame === 0 ? '#ff6b35' : flame === 1 ? '#f7931e' : '#ffff88';
                                drawEllipse(flameX, burnerY + flame * 2, flameWidth, flameHeight, flameColor);
                            }
                        }

                        // Bot√µes iluminados
                        drawCircle(left + 6, y + 3, 2, '#ff6b35');
                        drawCircle(right - 6, y + 3, 2, '#ff6b35');

                        // Vapor subindo
                        for(let i=0; i<5; i++) {
                            const steamX = cx + Math.sin(time / 200 + i) * 8;
                            const steamY = y + 2 - (time / 60 + i * 10) % 20;
                            const steamAlpha = Math.max(0, (y + 2 - steamY) / 20);
                            drawCircle(steamX, steamY, 0.8, `rgba(200, 220, 255, ${steamAlpha * 0.6})`);
                        }
                    } else {
                        // Bocas vazias
                    drawLine(left + 4, y + 12, left + 10, y + 24, 1, 'rgba(255,255,255,0.2)');
                    drawCircle(left + 6, y + 3, 2, '#111');
                    drawCircle(right - 6, y + 3, 2, '#111');
                    }

                    drawRect(cx - 4, y + 28, 8, 2, '#cfd8dc'); 

                    // Indicador visual de interatividade
                    const blinkStove = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx, y + 5, 0.8, `rgba(255, 100, 100, ${blinkStove})`);
                    break;

                case 'sink':
                    // Base da pia com arm√°rio embaixo
                    drawRoundRect(left, y + 12, s.w, s.h - 12, 2, s.col);
                    // Cubo da pia com granito
                    drawRoundRect(left + 4, y, s.w - 8, 14, 2, '#e0e0e0');
                    // Borda da cuba com acabamento
                    drawRect(left + 6, y + 2, s.w - 12, 10, '#f0f0f0');
                    drawRect(left + 8, y + 4, s.w - 16, 6, '#e8f4f8');
                    // Torneira cromada detalhada
                    drawRect(cx - 2, y - 4, 4, 6, '#c0c0c0');
                    drawCircle(cx, y - 6, 3, '#silver');
                    drawRect(cx - 1, y - 8, 2, 4, '#silver');
                    // Alavanca da torneira
                    drawRect(cx - 0.5, y - 9, 1, 3, '#424242');
                    if (sinkActive) {
                        // √Ågua corrente mais realista
                        const waterLevel = Math.sin(time / 300) * 0.5 + 1.5;
                        ctx.fillStyle = 'rgba(0, 191, 255, 0.9)';
                        ctx.beginPath();
                        ctx.arc(scx, sy + 6, waterLevel, 0, Math.PI * 2);
                        ctx.fill();

                        // Gotas caindo animadas
                        for(let i = 0; i < 5; i++) {
                            const dropY = y + 8 + (time / 20 + i * 8) % 25;
                            const dropX = cx - 1 + i * 0.5 + Math.sin(time / 100 + i) * 0.3;
                            const dropSize = 0.3 + Math.sin(time / 50 + i) * 0.2;

                            if(dropY < y + 12) {
                                drawEllipse(dropX, dropY, dropSize, dropSize * 1.5, 'rgba(0, 191, 255, 0.8)');
                                // Brilho na gota
                                drawCircle(dropX - 0.1, dropY - 0.2, dropSize * 0.5, 'rgba(255, 255, 255, 0.6)');
                            }

                            // Ondas na √°gua
                            if(dropY >= y + 11) {
                                const rippleRadius = (time / 30 + i * 5) % 20;
                                if(rippleRadius < 10) {
                                    ctx.strokeStyle = `rgba(100, 200, 255, ${1 - rippleRadius/10})`;
                                    ctx.lineWidth = 1;
                                    ctx.beginPath();
                                    ctx.arc(scx, sy + 6, rippleRadius, 0, Math.PI * 2);
                                    ctx.stroke();
                                }
                            }
                        }

                        // Vapor subindo
                        for(let i=0; i<3; i++) {
                            const steamY = y - 2 - (time / 40 + i * 15) % 15;
                            if(steamY > y - 10) {
                                drawCircle(cx + Math.sin(time / 200 + i) * 3, steamY, 0.6, `rgba(200, 220, 255, ${(y + 2 - steamY) / 15})`);
                            }
                        }
                    } else {
                        // Estado inativo - apenas um pouco de √°gua parada
                        ctx.fillStyle = 'rgba(0, 191, 255, 0.4)';
                        ctx.beginPath();
                        ctx.arc(scx, sy + 6, 1, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Indicador visual de interatividade
                    const blinkSink = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx - 6, y + 2, 0.8, `rgba(100, 150, 255, ${blinkSink})`);
                    break;

                case 'toilet':
                    // Base retangular do vaso
                    drawRoundRect(left, y + 16, s.w, s.h - 16, 2, s.col);
                    // Tampa do vaso com dobradi√ßa
                    drawRoundRect(left + 2, y + 12, s.w - 4, 6, 3, '#f0f0f0');
                    drawCircle(right - 4, y + 15, 1, '#c0c0c0');
                    // Assento com espuma
                    drawRoundRect(left + 2, y + 8, s.w - 4, 6, 3, s.col);
                    drawRect(left + 4, y + 10, s.w - 8, 2, '#e8f4f8');
                    // Tanque de √°gua com detalhes
                    drawRoundRect(right - 12, y, 10, 14, 2, '#e8e8e8');
                    drawRect(right - 10, y + 2, 6, 10, '#f0f0f0');
                    // Bot√£o de descarga duplo
                    drawCircle(right - 7, y + 3, 2, '#ff5722');
                    drawCircle(right - 7, y + 8, 2, '#2196f3');
                    // Tubula√ß√£o vis√≠vel
                    drawRect(cx - 1, y + 30, 2, 2, '#c0c0c0');
                    // Reflexo na √°gua
                    drawRect(left + 4, y + 20, 2, 4, 'rgba(173, 216, 230, 0.6)');
                    drawRect(left + 8, y + 22, 1, 2, 'rgba(173, 216, 230, 0.4)');
                    break;

                case 'shower':
                    // Moldura do box com vidro temperado
                    drawRect(left, y, 2, s.h, '#d0d0d0');
                    drawRect(right - 2, y, 2, s.h, '#d0d0d0');
                    drawRect(left, y, s.w, 2, '#d0d0d0');
                    // Porta de vidro com reflexo
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.fillRect(sx + 2, sy + 2, s.w - 4, s.h - 4);
                    // Moldura cromada
                    drawRect(sx + 1, sy + 1, s.w - 2, 1, '#c0c0c0');
                    drawRect(sx + 1, sy + s.h - 3, s.w - 2, 1, '#c0c0c0');
                    // Chuveiro de teto com ducha
                    drawCircle(cx, y - 10, 4, '#c0c0c0');
                    drawRect(cx - 1, y - 14, 2, 6, '#c0c0c0');
                    // Detalhes da ducha
                    for(let i = 0; i < 6; i++) {
                        const angle = (i * Math.PI * 2) / 6;
                        const dx = Math.cos(angle) * 2;
                        const dy = Math.sin(angle) * 2;
                        drawCircle(cx + dx, y - 12 + dy, 0.5, '#e0e0e0');
                    }
                    // Registro com detalhes
                    drawRect(cx - 6, y + 20, 12, 8, '#f0f0f0');
                    drawCircle(cx - 3, y + 24, 2, '#ff5722');
                    drawCircle(cx + 3, y + 24, 2, '#2196f3');
                    drawRect(cx - 1, y + 26, 2, 2, '#c0c0c0');
                    // √Ågua caindo realista
                    for(let i = 0; i < 8; i++) {
                        const xOffset = (i - 4) * 2;
                        const length = 6 + Math.random() * 4;
                        drawRect(cx + xOffset, y + 30, 1, length, 'rgba(0, 191, 255, 0.8)');
                        drawRect(cx + xOffset, y + 30 + length, 1, 2, 'rgba(0, 191, 255, 0.4)');
                    }
                    break;

                case 'bathtub':
                    // Corpo da banheira com porcelana
                    drawRoundRect(left, y, s.w, s.h, 4, s.col);
                    // Interior esmaltado
                    drawRoundRect(left + 2, y + 2, s.w - 4, s.h - 4, 3, '#e8f4f8');
                    // Bordas arredondadas
                    drawRoundRect(left, y, s.w, 4, 4, '#d0d0d0');
                    drawRoundRect(left, y + s.h - 4, s.w, 4, 4, '#d0d0d0');
                    // Torneira de banheira detalhada
                    drawRect(right - 8, y - 4, 6, 8, '#c0c0c0');
                    drawCircle(right - 5, y - 6, 2, '#silver');
                    drawRect(right - 6, y - 8, 2, 4, '#silver');
                    // Chuveiro de m√£o
                    drawCircle(right - 5, y + 2, 1.5, '#c0c0c0');
                    drawRect(right - 6, y, 2, 4, '#c0c0c0');
                    // Saboneteira
                    drawRect(left + 4, y + 6, 6, 3, '#e0e0e0');
                    drawCircle(left + 7, y + 7.5, 1, '#f5f5f5');
                    // √Ågua na banheira
                    drawRect(left + 4, y + 6, s.w - 8, s.h - 10, 'rgba(0, 191, 255, 0.4)');
                    // Espuma
                    for(let i = 0; i < 8; i++) {
                        const foamX = left + 6 + Math.random() * (s.w - 12);
                        const foamY = y + 8 + Math.random() * (s.h - 16);
                        drawCircle(foamX, foamY, 1 + Math.random() * 2, 'rgba(255, 255, 255, 0.8)');
                    }
                    // Bolhas subindo
                    for(let i = 0; i < 5; i++) {
                        const bubbleX = left + 8 + Math.random() * (s.w - 16);
                        const bubbleY = y + s.h - 8 - i * 3;
                        drawCircle(bubbleX, bubbleY, 0.5, 'rgba(255, 255, 255, 0.6)');
                    }
                    break;

                case 'piano': // Piano Melhorado com Mais Detalhes
                    // Estrutura principal de madeira polida
                    drawRect(left, y + 16, s.w, 8, '#8d6e63'); // Base inferior
                    drawRect(left + 1, y + 17, s.w - 2, 6, '#a1887f'); // Revestimento

                    // Corpo principal (caixa de resson√¢ncia)
                    drawRect(left + 2, y + 8, s.w - 4, 8, '#5d4037');
                    drawRect(left + 3, y + 9, s.w - 6, 6, '#8d6e63');

                    // Tampa superior articulada
                    drawRect(left + 4, y, s.w - 8, 8, '#3e2723');
                    drawRect(left + 5, y + 1, s.w - 10, 6, '#5d4037');

                    // Dobradi√ßa da tampa
                    drawCircle(left + 6, y + 4, 0.5, '#c0c0c0');
                    drawCircle(right - 6, y + 4, 0.5, '#c0c0c0');

                    // Teclado completo
                    // Teclas brancas (88 teclas, mostrando apenas 24 vis√≠veis)
                    for(let i = 0; i < 24; i++) {
                        const keyX = left + 6 + i * 1.2;
                        drawRect(keyX, y + 16, 1.1, 6, '#ffffff');
                        // Reflexo sutil
                        drawRect(keyX, y + 17, 1.1, 1, '#f5f5f5');
                        // Sombra inferior
                        drawRect(keyX, y + 21, 1.1, 1, '#e0e0e0');
                    }

                    // Teclas pretas (bem temperadas)
                    for(let i = 0; i < 20; i++) {
                        if(i % 7 !== 2 && i % 7 !== 6) { // Padr√£o de teclas pretas
                            const blackKeyX = left + 7.4 + i * 1.2;
                            drawRect(blackKeyX, y + 16, 0.8, 4, '#000000');
                            // Brilho nas teclas pretas
                            drawRect(blackKeyX, y + 16, 0.8, 0.5, '#333333');
                        }
                    }

                    // Mecanismo interno vis√≠vel (parcialmente)
                    for(let i = 0; i < 8; i++) {
                        drawRect(left + 8 + i * 2, y + 12, 0.5, 4, '#c0c0c0');
                    }

                    // Pedais com detalhes
                    drawRect(cx - 8, y + 22, 3, 2, '#c0c0c0'); // Sustain (direito)
                    drawRect(cx - 8, y + 23, 3, 0.5, '#e0e0e0');
                    drawCircle(cx - 6.5, y + 22.5, 0.3, '#666');

                    drawRect(cx - 3, y + 22, 3, 2, '#c0c0c0'); // Soft (meio)
                    drawRect(cx - 3, y + 23, 3, 0.5, '#e0e0e0');
                    drawCircle(cx - 1.5, y + 22.5, 0.3, '#666');

                    drawRect(cx + 2, y + 22, 3, 2, '#c0c0c0'); // Una corda (esquerdo)
                    drawRect(cx + 2, y + 23, 3, 0.5, '#e0e0e0');
                    drawCircle(cx + 3.5, y + 22.5, 0.3, '#666');

                    // Detalhes ornamentais na madeira
                    drawRect(left + 6, y + 2, s.w - 12, 1, '#8d6e63'); // Moldura superior
                    drawRect(left + 6, y + 6, s.w - 12, 0.5, '#a1887f'); // Detalhe

                    // Partitura sobre o piano (folhas musicais)
                    drawRect(cx - 5, y - 6, 10, 4, '#f5f5f5'); // Papel
                    drawRect(cx - 4, y - 5, 8, 0.5, '#000000'); // Pauta superior
                    drawRect(cx - 4, y - 4, 8, 0.5, '#000000'); // Pauta inferior
                    drawRect(cx - 4, y - 3, 8, 0.5, '#000000'); // Pauta m√©dia

                    // Notas musicais simples
                    drawCircle(cx - 3, y - 4.5, 0.3, '#000000');
                    drawCircle(cx - 1, y - 3.5, 0.3, '#000000');
                    drawCircle(cx + 1, y - 4.5, 0.3, '#000000');

                    // Suporte do piano (pernas)
                    drawRect(left + 6, y + 24, 3, 4, '#5d4037');
                    drawRect(right - 9, y + 24, 3, 4, '#5d4037');

                    // Etiqueta de marca
                    drawRect(cx - 3, y + 1, 6, 1, '#daa520');
                    drawText('STEINWAY', cx - 2.5, y + 2, 0.6, '#000');

                    // Indicador visual de interatividade
                    const blinkPiano = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx, y - 2, 0.8, `rgba(139, 69, 19, ${blinkPiano})`);
                    break;

                case 'violin':
                    // Corpo do violino
                    ctx.fillStyle = s.col;
                    ctx.beginPath();
                    ctx.ellipse(scx, sy + 12, 3, 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Contorno superior
                    ctx.strokeStyle = '#5d4037';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.ellipse(scx, sy + 6, 2.5, 3, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    // Contorno inferior
                    ctx.beginPath();
                    ctx.ellipse(scx, sy + 18, 2.5, 3, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    // Cordas
                    for(let i = 0; i < 4; i++) {
                        const stringY = y + 8 + i * 1.5;
                        drawLine(cx - 2.5, stringY, cx + 2.5, stringY, 0.5, '#ffd700');
                    }
                    // Cavalete
                    drawRect(cx - 1, y + 12, 2, 0.5, '#8d6e63');
                    // Arco
                    drawRect(cx + 4, y + 10, 8, 1, '#8d6e63');
                    drawRect(cx + 4, y + 11, 8, 0.5, '#654321');
                    // Crina do arco
                    for(let i = 0; i < 6; i++) {
                        drawRect(cx + 5 + i*1, y + 9, 0.5, 4, '#f5f5f5');
                    }
                    // Sombras
                    drawEllipse(cx, y + 20, 3, 1, 'rgba(0, 0, 0, 0.2)');
                    break;

                case 'guitar':
                    // Corpo da guitarra el√©trica
                    drawEllipse(cx, y + 16, 6, 8, s.col);
                    // Bra√ßo
                    drawRect(cx - 1, y, 2, 16, s.col);
                    // Headstock
                    drawRect(cx - 2, y - 4, 4, 4, s.col);
                    // Cordas
                    for(let i = 0; i < 6; i++) {
                        const stringY = y + 2 + i * 1.8;
                        drawLine(cx - 5, stringY, cx + 5, stringY, 0.3, '#c0c0c0');
                    }
                    // Tarraxas
                    for(let i = 0; i < 6; i++) {
                        const tunerX = cx - 1.5 + (i % 3) * 1;
                        const tunerY = y - 2 + Math.floor(i / 3) * 1.5;
                        drawCircle(tunerX, tunerY, 0.4, '#silver');
                    }
                    // Escudo/pegada
                    drawRect(cx - 3, y + 14, 6, 4, '#8d6e63');
                    // Captadores
                    drawRect(cx - 4, y + 10, 2, 1, '#silver');
                    drawRect(cx + 2, y + 10, 2, 1, '#silver');
                    // Ponte
                    drawRect(cx - 2, y + 18, 4, 1, '#silver');
                    // Cord√£o
                    drawRect(cx + 6, y + 8, 6, 1, '#000000');
                    break;

                case 'drum_set':
                    // Bumbo
                    drawEllipse(cx, y + 16, 8, 6, s.col);
                    drawEllipse(cx, y + 16, 7, 5, '#424242');
                    // Caixa
                    drawRect(cx - 6, y + 6, 12, 8, s.col);
                    drawRect(cx - 5, y + 7, 10, 6, '#424242');
                    // Prato ride
                    drawCircle(cx + 8, y + 4, 4, '#c0c0c0');
                    drawCircle(cx + 8, y + 4, 3, '#silver');
                    // Prato crash
                    drawCircle(cx - 8, y + 2, 3.5, '#c0c0c0');
                    drawCircle(cx - 8, y + 2, 2.5, '#silver');
                    // Hi-hat
                    drawRect(cx - 2, y, 4, 1, '#c0c0c0');
                    drawRect(cx - 2, y + 1, 4, 1, '#silver');
                    // Tom-tom
                    drawEllipse(cx + 4, y + 8, 3, 2, s.col);
                    drawEllipse(cx + 4, y + 8, 2.5, 1.5, '#424242');
                    // Bateria pequena
                    drawEllipse(cx - 4, y + 10, 2.5, 2, s.col);
                    drawEllipse(cx - 4, y + 10, 2, 1.5, '#424242');
                    // Peles
                    for(let i = 0; i < 4; i++) {
                        const drumY = y + 8 + i * 2;
                        drawCircle(cx, drumY, 6 - i, 'rgba(255, 255, 255, 0.3)');
                    }
                    // Suportes
                    drawRect(cx - 10, y + 18, 20, 2, '#666666');
                    break;

                case 'saxophone':
                    // Corpo curvo do saxofone
                    ctx.strokeStyle = s.col;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(scx - 2, sy + 12, 6, Math.PI/4, Math.PI * 1.5);
                    ctx.stroke();
                    // Camp√¢nula
                    ctx.beginPath();
                    ctx.arc(scx + 4, sy + 6, 3, 0, Math.PI * 2);
                    ctx.stroke();
                    // Chaves e v√°lvulas
                    for(let i = 0; i < 8; i++) {
                        const keyX = cx - 3 + (i % 4) * 2;
                        const keyY = y + 4 + Math.floor(i / 4) * 3;
                        drawCircle(keyX, keyY, 0.6, '#silver');
                        drawRect(keyX - 0.3, keyY + 0.6, 0.6, 1, '#silver');
                    }
                    // Boquilha
                    drawRect(cx - 6, y, 2, 4, '#212121');
                    // Correia
                    drawLine(cx - 4, y + 8, cx - 8, y + 12, 1, '#8d6e63');
                    drawLine(cx - 8, y + 12, cx - 6, y + 16, 1, '#8d6e63');
                    // Reflexos dourados
                    drawEllipse(cx, y + 10, 5, 3, 'rgba(255, 215, 0, 0.3)');
                    break;

                case 'trumpet':
                    // Camp√¢nula
                    ctx.fillStyle = s.col;
                    ctx.beginPath();
                    ctx.arc(scx + 2, sy + 2, 2.5, 0, Math.PI * 2);
                    ctx.fill();
                    // Tubo principal
                    drawRect(cx - 1, y + 4, 2, 12, s.col);
                    // Curva para a boquilha
                    ctx.strokeStyle = s.col;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(scx - 2, sy + 12, 3, Math.PI/2, Math.PI);
                    ctx.stroke();
                    // V√°lvulas
                    for(let i = 0; i < 3; i++) {
                        drawCircle(cx + 1, y + 6 + i*2, 0.8, '#silver');
                        drawRect(cx + 1.8, y + 5.5 + i*2, 1, 1.5, '#silver');
                    }
                    // Boquilha
                    drawRect(cx - 4, y + 14, 1.5, 2, '#212121');
                    // Detalhes ornamentais
                    drawCircle(cx + 2, y + 2, 2, 'rgba(255, 215, 0, 0.4)');
                    // Correia
                    drawLine(cx, y + 8, cx - 4, y + 12, 1, '#8d6e63');
                    break;

                case 'acoustic_guitar':
                    // Corpo do viol√£o
                    drawEllipse(cx, y + 14, 5, 8, s.col);
                    // Bra√ßo
                    drawRect(cx - 1, y, 2, 14, s.col);
                    // Headstock
                    drawEllipse(cx, y - 2, 2, 3, s.col);
                    // Cordas
                    for(let i = 0; i < 6; i++) {
                        const stringY = y + 2 + i * 1.6;
                        drawLine(cx - 4, stringY, cx + 4, stringY, 0.3, '#c0c0c0');
                    }
                    // Tarraxas
                    for(let i = 0; i < 6; i++) {
                        const tunerX = cx - 1 + (i % 3) * 0.8;
                        const tunerY = y - 1 + Math.floor(i / 3) * 1;
                        drawCircle(tunerX, tunerY, 0.3, '#silver');
                    }
                    // Escudo/pegada
                    drawRect(cx - 3, y + 12, 6, 4, '#5d4037');
                    // Ponte
                    drawRect(cx - 1.5, y + 16, 3, 1, '#8d6e63');
                    // Cord√£o
                    drawRect(cx + 5, y + 6, 4, 1, '#654321');
                    // Textura de madeira
                    for(let i = 0; i < 3; i++) {
                        drawLine(cx - 4, y + 8 + i*2, cx + 4, y + 8 + i*2, 0.5, '#4e342e');
                    }
                    break;

                case 'keyboard':
                    // Corpo do teclado
                    drawRoundRect(left, y + 6, s.w, 6, 2, s.col);
                    // Base
                    drawRect(left + 2, y + 12, s.w - 4, 3, '#424242');
                    // Teclas brancas
                    for(let i = 0; i < 16; i++) {
                        const keyX = left + 4 + i * 1.4;
                        drawRect(keyX, y + 6, 1.2, 5, '#ffffff');
                        drawRect(keyX, y + 7, 1.2, 1, '#e0e0e0');
                    }
                    // Teclas pretas
                    for(let i = 0; i < 12; i++) {
                        if(i % 7 !== 2 && i % 7 !== 6) {
                            const blackKeyX = left + 5.2 + i * 1.4;
                            drawRect(blackKeyX, y + 6, 0.8, 3, '#000000');
                        }
                    }
                    // Tela LCD
                    drawRect(cx - 6, y, 12, 3, '#000000');
                    drawRect(cx - 5, y + 0.5, 10, 2, '#001122');
                    drawText('KEYBOARD', cx - 4, y + 1.5, 1, '#00ff00');
                    // Controles
                    drawCircle(cx - 8, y + 8, 1, '#silver');
                    drawCircle(cx - 6, y + 8, 1, '#silver');
                    drawRect(cx - 4, y + 7, 8, 2, '#silver');
                    // Cabos
                    drawLine(cx + 10, y + 9, cx + 16, y + 9, 1, '#000000');
                    drawLine(cx + 10, y + 11, cx + 14, y + 11, 1, '#000000');
                    break;

                case 'bar_counter':
                    // Superf√≠cie do balc√£o
                    drawRect(left, y, s.w, 6, s.col);
                    // Base inferior
                    drawRect(left + 2, y + 6, s.w - 4, 6, '#5d4037');
                    // Detalhes da madeira
                    for(let i = 0; i < 8; i++) {
                        drawRect(left + 4 + i*4, y + 1, 2, 4, '#4e342e');
                    }
                    // Rodap√© protetor
                    drawRect(left, y + 10, s.w, 2, '#212121');
                    // Prateleiras inferiores
                    drawRect(left + 4, y + 8, s.w - 8, 1, '#8d6e63');
                    drawRect(left + 4, y + 11, s.w - 8, 1, '#8d6e63');
                    // Copos e garrafas na superf√≠cie
                    drawRect(cx - 8, y - 4, 2, 4, '#e0f7fa'); // Copo
                    drawRect(cx - 4, y - 6, 1.5, 6, '#4caf50'); // Garrafa
                    drawRect(cx, y - 3, 2, 3, '#ffeb3b'); // Cerveja
                    drawRect(cx + 6, y - 5, 2, 5, '#ff5722'); // Vinho
                    break;


                case 'beer_taps':
                    // Torneiras de chope (maiores e mais realistas)
                    // Base/placa inox
                    drawRect(cx - s.w/2, y, s.w, s.h, '#bdbdbd');
                    // Brilho lateral
                    drawRect(cx - s.w/2 + 1, y + 1, 2, s.h - 2, 'rgba(255,255,255,0.25)');
                    drawRect(cx + s.w/2 - 3, y + 2, 2, s.h - 4, 'rgba(0,0,0,0.15)');

                    // Bandeja coletora
                    drawRect(cx - s.w/2 - 1, y + s.h - 5, s.w + 2, 4, '#424242');
                    // Grelha da bandeja
                    for (let gx = -Math.floor(s.w/2); gx <= Math.floor(s.w/2); gx += 2) {
                        drawLine(cx + gx, y + s.h - 5, cx + gx, y + s.h - 1, 0.5, 'rgba(255,255,255,0.25)');
                    }

                    // Coluna central (torre)
                    drawRect(cx - 2.5, y + 2, 5, s.h - 10, '#9e9e9e');
                    drawRect(cx - 2.2, y + 3, 1, s.h - 12, 'rgba(255,255,255,0.25)');

                    // 3 torneiras
                    const tapCount = 3;
                    for (let i = 0; i < tapCount; i++) {
                        const t = (tapCount === 1) ? 0 : (i / (tapCount - 1));
                        const tapX = cx - (s.w * 0.28) + t * (s.w * 0.56);

                        // Corpo da torneira
                        drawRect(tapX - 0.8, y + 7, 1.6, 10, '#757575');
                        drawRect(tapX - 0.6, y + 8, 0.6, 8, 'rgba(255,255,255,0.25)');

                        // Bico
                        drawRect(tapX - 1.2, y + 16, 2.4, 1.2, '#616161');
                        drawRect(tapX - 0.7, y + 17.2, 1.4, 1.2, '#424242');

                        // Alavanca (vermelha)
                        drawRect(tapX - 2.2, y + 10, 4.4, 1.4, '#c62828');
                        drawRect(tapX - 2.2, y + 9.6, 1.0, 0.8, '#7f1d1d');

                        // Plaquinha de sabor
                        drawRect(tapX - 2.0, y + 5, 4.0, 1.8, '#eeeeee');
                        drawRect(tapX - 1.8, y + 5.3, 3.6, 0.4, '#b0bec5');
                    }

                    // Mangueiras laterais
                    drawLine(cx - s.w/2, y + s.h*0.55, cx - s.w/2 - 6, y + s.h*0.55 + 4, 1.2, '#616161');
                    drawLine(cx + s.w/2, y + s.h*0.55, cx + s.w/2 + 6, y + s.h*0.55 + 4, 1.2, '#616161');

                    // Pingos discretos (uma torneira)
                    drawCircle(cx, y + s.h - 3.2, 0.35, 'rgba(79,195,247,0.9)');
                    drawCircle(cx, y + s.h - 2.0, 0.25, 'rgba(79,195,247,0.8)');
                    break;

                case 'bottles_rack':
                    // Estrutura de madeira
                    drawRect(left, y, s.w, s.h, s.col);
                    // Prateleiras
                    for(let i = 0; i < 4; i++) {
                        const shelfY = y + 2 + i * 3.5;
                        drawRect(left + 1, shelfY, s.w - 2, 1, '#8d6e63');
                        // Garrafas na prateleira
                        for(let j = 0; j < 6; j++) {
                            if(Math.random() > 0.3) { // Algumas posi√ß√µes vazias
                                const bottleX = left + 2 + j * 3;
                                const bottleHeight = 2 + Math.random() * 1.5;
                                drawRect(bottleX, shelfY - bottleHeight + 1, 1.5, bottleHeight, '#4caf50');
                                // Rotulo
                                drawRect(bottleX + 0.2, shelfY - bottleHeight + 0.5, 1.1, bottleHeight - 1, '#ff5722');
                            }
                        }
                    }
                    // Suportes verticais
                    drawRect(left + 2, y, 2, s.h, '#5d4037');
                    drawRect(right - 4, y, 2, s.h, '#5d4037');
                    // Detalhes ornamentais
                    drawRect(left + 4, y + 1, s.w - 8, 0.5, '#4e342e');
                    break;

                case 'jukebox':
                    // Jukebox estilo anos 50 - madeira marrom com detalhes cromados

                    // Base da jukebox (madeira)
                    drawRect(left, y + s.h - 4, s.w, 4, '#654321'); // Base de madeira escura

                    // Corpo principal de madeira polida
                    drawRect(left + 1, y + 2, s.w - 2, s.h - 6, s.col);
                    // Textura de madeira (linhas horizontais)
                    for(let i = 0; i < 8; i++) {
                        const woodY = y + 4 + i * 4;
                        drawRect(left + 2, woodY, s.w - 4, 0.5, '#5D4E37');
                    }

                    // Moldura cromada ao redor
                    drawRect(left, y + 1, s.w, 1, '#C0C0C0'); // Topo cromado
                    drawRect(left, y + s.h - 5, s.w, 1, '#C0C0C0'); // Base cromada
                    drawRect(left, y + 1, 1, s.h - 4, '#C0C0C0'); // Lado esquerdo
                    drawRect(left + s.w - 1, y + 1, 1, s.h - 4, '#C0C0C0'); // Lado direito

                    // Painel frontal de vidro com detalhes cromados
                    drawRect(left + 2, y + 4, s.w - 4, s.h - 12, '#000033');
                    // Moldura interna cromada
                    drawRect(left + 2, y + 4, s.w - 4, 1, '#FFD700'); // Topo dourado
                    drawRect(left + 2, y + s.h - 8, s.w - 4, 1, '#FFD700'); // Base dourada

                    if (jukeboxActive) {
                        // Tela central animada
                        drawRect(cx - 6, y + 8, 12, 8, '#000044');
                        drawRect(cx - 5, y + 9, 10, 6, '#000022');

                        // Logo "JUKEBOX" pulsante
                        const logoPulse = Math.sin(time / 400) * 0.3 + 0.7;
                        ctx.shadowColor = '#FFD700';
                        ctx.shadowBlur = 3;
                        drawText('JUKEBOX', cx - 4.5, y + 12, 1.2, `rgba(255, 215, 0, ${logoPulse})`);
                        ctx.shadowBlur = 0;

                        drawText('ROCK & ROLL', cx - 4.5, y + 14, 0.7, '#FF4500');

                        // Grade de sele√ß√£o de m√∫sicas (5x3 bot√µes)
                        for(let row = 0; row < 3; row++) {
                            for(let col = 0; col < 5; col++) {
                                const btnX = left + 4 + col * 2.4;
                                const btnY = y + 18 + row * 2.2;
                                const isPlaying = row === 1 && col === 2; // M√∫sica "tocando"

                                if(isPlaying) {
                                    // Bot√£o selecionado com efeito pulsante
                                    const pulseSize = Math.sin(time / 200) * 0.2 + 1;
                                    drawRect(btnX - 0.2, btnY - 0.2, 2 * pulseSize, 1.8 * pulseSize, '#FFD700');
                                    drawRect(btnX, btnY, 1.6, 1.4, '#FF0000');
                                    drawText('‚ô™', btnX + 0.8, btnY + 1, 0.8, '#FFFFFF');
                                } else {
                                    drawRect(btnX, btnY, 1.6, 1.4, '#C0C0C0');
                                    drawRect(btnX + 0.2, btnY + 0.2, 1.2, 0.8, '#333333');
                                }
                            }
                        }

                        // Grandes alto-falantes cromados
                        // Alto-falante esquerdo
                        drawCircle(cx - 7, y + 26, 3, '#C0C0C0');
                        drawCircle(cx - 7, y + 26, 2.5, '#000000');
                        drawCircle(cx - 7, y + 26, 1.5, '#C0C0C0');

                        // Alto-falante direito
                        drawCircle(cx + 7, y + 26, 3, '#C0C0C0');
                        drawCircle(cx + 7, y + 26, 2.5, '#000000');
                        drawCircle(cx + 7, y + 26, 1.5, '#C0C0C0');

                        // Ondas sonoras potentes
                        for(let speaker = -1; speaker <= 1; speaker += 2) {
                            const speakerX = cx + speaker * 7;
                            for(let wave = 1; wave <= 4; wave++) {
                                const waveRadius = wave * 2 + Math.sin(time / 150 + wave) * 1.5;
                                const alpha = (5 - wave) / 5 * 0.6;
                                ctx.strokeStyle = `rgba(255, 255, 0, ${alpha})`;
                                ctx.lineWidth = 2;
                                ctx.beginPath();
                                ctx.arc(speakerX, y + 26, waveRadius, 0, Math.PI * 2);
                                ctx.stroke();
                            }
                        }

                        // Luzes coloridas do painel (estilo anos 50)
                        const panelLights = ['#FF0000', '#FFA500', '#FFFF00', '#00FF00', '#0000FF', '#FF00FF'];
                        for(let i = 0; i < 6; i++) {
                            const lightX = left + 3 + i * 2.3;
                            const lightPulse = Math.sin(time / 250 + i * 0.5) * 0.4 + 0.6;
                            drawCircle(lightX, y + 6, 0.6 * lightPulse, panelLights[i]);
                        }

                        // Notas musicais dan√ßantes (estilo rockabilly)
                        const notes = ['‚ô™', '‚ô´', '‚ô¨', '‚ô©'];
                        for(let i = 0; i < 4; i++) {
                            const noteY = y - 2 - (time / 80 + i * 40) % 20;
                            const noteX = cx + Math.sin(time / 300 + i * 1.5) * 8;
                            if(noteY > y - 20) {
                                const hue = (time / 30 + i * 90) % 360;
                                drawText(notes[i % notes.length], noteX, noteY, 1.2, `hsl(${hue}, 80%, 70%)`);
                            }
                        }

                        // Vibra√ß√£o da jukebox (efeito f√≠sico)
                        const shake = Math.sin(time / 50) * 0.1;
                        if(Math.abs(shake) > 0.05) {
                            // Pequenas part√≠culas de "poeira" caindo
                            for(let i = 0; i < 2; i++) {
                                const dustX = cx + (Math.random() - 0.5) * 15;
                                const dustY = y + s.h + Math.random() * 3;
                                drawCircle(dustX, dustY, 0.3, `rgba(139, 69, 19, ${Math.random() * 0.5})`);
                            }
                        }

                    } else {
                        // Estado inativo - jukebox "dormindo"
                        drawRect(cx - 6, y + 8, 12, 8, '#000022');
                        drawText('JUKEBOX', cx - 4.5, y + 12, 1, '#666666');
                        drawText('INSERT COIN', cx - 4.5, y + 14, 0.6, '#888888');

                        // Bot√µes inativos
                        for(let row = 0; row < 3; row++) {
                            for(let col = 0; col < 5; col++) {
                                const btnX = left + 4 + col * 2.4;
                                const btnY = y + 18 + row * 2.2;
                                drawRect(btnX, btnY, 1.6, 1.4, '#666666');
                                drawRect(btnX + 0.2, btnY + 0.2, 1.2, 0.8, '#333333');
                            }
                        }

                        // Alto-falantes inativos
                        drawCircle(cx - 7, y + 26, 3, '#666666');
                        drawCircle(cx - 7, y + 26, 2.5, '#333333');
                        drawCircle(cx + 7, y + 26, 3, '#666666');
                        drawCircle(cx + 7, y + 26, 2.5, '#333333');

                        // Luzes apagadas
                        for(let i = 0; i < 6; i++) {
                            const lightX = left + 3 + i * 2.3;
                            drawCircle(lightX, y + 6, 0.4, '#333333');
                        }
                    }

                    // Indicador visual de interatividade (magenta pulsante)
                    const blinkJukebox = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx + 9, y + 12, 1, `rgba(255, 0, 255, ${blinkJukebox})`);
                    break;

                case 'pool_table':
                    // Superf√≠cie da mesa
                    drawRect(left, y, s.w, s.h, s.col);
                    // Bordas
                    drawRect(left + 1, y + 1, s.w - 2, s.h - 2, '#1b5e20');
                    // Pano verde
                    drawRect(left + 3, y + 3, s.w - 6, s.h - 6, '#4caf50');
                    // Ca√ßapas
                    drawCircle(left + 4, y + 4, 1.5, '#212121'); // Canto superior esquerdo
                    drawCircle(right - 5, y + 4, 1.5, '#212121'); // Superior direito
                    drawCircle(left + 4, y + s.h - 5, 1.5, '#212121'); // Inferior esquerdo
                    drawCircle(right - 5, y + s.h - 5, 1.5, '#212121'); // Inferior direito
                    drawCircle(cx, y + 4, 1.5, '#212121'); // Superior centro
                    drawCircle(cx, y + s.h - 5, 1.5, '#212121'); // Inferior centro
                    if (poolTableActive) {
                        // Bolas animadas rolando
                        const animatedBalls = [
                            {x: cx - 6 + Math.sin(time / 400) * 3, y: y + 6 + Math.cos(time / 500) * 2, col: '#ffff00'}, // Bola 1
                            {x: cx - 4 + Math.sin(time / 350 + 1) * 4, y: y + 8 + Math.cos(time / 450 + 1) * 3, col: '#0000ff'}, // Bola 2
                            {x: cx - 2 + Math.sin(time / 300 + 2) * 2, y: y + 7 + Math.cos(time / 400 + 2) * 1.5, col: '#ff0000'}, // Bola 3
                            {x: cx + Math.sin(time / 450 + 3) * 3.5, y: y + 9 + Math.cos(time / 550 + 3) * 2.5, col: '#800080'}, // Bola 4
                            {x: cx + 2 + Math.sin(time / 320 + 4) * 2.8, y: y + 6 + Math.cos(time / 380 + 4) * 1.8, col: '#ffa500'}, // Bola 9
                            {x: cx + 4 + Math.sin(time / 380 + 5) * 3.2, y: y + 8 + Math.cos(time / 420 + 5) * 2.2, col: '#008000'}  // Bola 6
                        ];
                        animatedBalls.forEach(ball => {
                            drawCircle(ball.x, ball.y, 1, ball.col);
                            drawCircle(ball.x - 0.3, ball.y - 0.3, 0.3, 'rgba(255,255,255,0.7)');
                            // Efeito de movimento (rastro sutil)
                            drawCircle(ball.x - 0.5, ball.y - 0.5, 0.2, `rgba(255,255,255,0.3)`);
                        });

                        // Taco animado golpeando
                        const cueAngle = Math.sin(time / 600) * 0.2;
                        const cueLength = 12 + Math.sin(time / 200) * 2;
                        const cueEndX = cx + 8 + Math.cos(cueAngle) * cueLength;
                        const cueEndY = y + 10 + Math.sin(cueAngle) * cueLength;
                        drawLine(cx + 8, y + 10, cueEndX, cueEndY, 1, '#8d6e63');

                        // Indicador de for√ßa
                        const powerBar = Math.abs(Math.sin(time / 300)) * 6;
                        drawRect(cx + 16, y + 4, 2, 8, '#666');
                        drawRect(cx + 16, y + 12 - powerBar, 2, powerBar, '#ffff00');
                    } else {
                        // Bolas est√°ticas
                        const balls = [
                            {x: cx - 6, y: y + 6, col: '#ffff00'}, // Bola 1
                            {x: cx - 4, y: y + 8, col: '#0000ff'}, // Bola 2
                            {x: cx - 2, y: y + 7, col: '#ff0000'}, // Bola 3
                            {x: cx, y: y + 9, col: '#800080'}, // Bola 4
                            {x: cx + 2, y: y + 6, col: '#ffa500'}, // Bola 9
                            {x: cx + 4, y: y + 8, col: '#008000'}  // Bola 6
                        ];
                        balls.forEach(ball => {
                            drawCircle(ball.x, ball.y, 1, ball.col);
                            drawCircle(ball.x - 0.3, ball.y - 0.3, 0.3, 'rgba(255,255,255,0.7)');
                        });
                    }
                    // Tacos apoiados
                    drawRect(cx + 12, y + 8, 1, 8, '#8d6e63'); // Taco 1
                    drawRect(cx + 14, y + 6, 1, 10, '#8d6e63'); // Taco 2
                    // Pernas da mesa (mais longas)
                    drawRect(left + 4, y + s.h, 2, 5, '#8d6e63');
                    drawRect(right - 6, y + s.h, 2, 5, '#8d6e63');
                    drawRect(cx - 1, y + s.h, 2, 5, '#8d6e63');

                    // Pequenos p√©s da mesa (mais altos do ch√£o)
                    const footHeight = 2;
                    const footOffset = 3; // Maior espa√ßo entre a perna e o p√©
                    drawRect(left + 3, y + s.h + 5 + footOffset, 4, footHeight, '#654321'); // P√© esquerdo
                    drawRect(right - 7, y + s.h + 5 + footOffset, 4, footHeight, '#654321'); // P√© direito
                    drawRect(cx - 2, y + s.h + 3 + footOffset, 4, footHeight, '#654321'); // P√© central

                    // Indicador visual de interatividade
                    const blinkPool = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx, y + 2, 0.8, `rgba(0, 100, 0, ${blinkPool})`);
                    break;

                case 'dart_board':
                    // Alvo de dardos (maior e mais realista)
                    const r = Math.min(s.w, s.h) * 0.48;
                    const cy = y + s.h/2;

                    // Moldura
                    drawCircle(cx, cy, r + 1.8, '#3e2723');
                    drawCircle(cx, cy, r + 1.2, '#5d4037');

                    // Fundo preto
                    drawCircle(cx, cy, r, '#1b1b1b');

                    // An√©is (cores tradicionais simplificadas)
                    const ring1 = r * 0.86;   // duplo
                    const ring2 = r * 0.62;   // triplo
                    const ring3 = r * 0.38;   // interno
                    const bull  = r * 0.14;   // bull
                    const bull2 = r * 0.06;   // bullseye

                    // Segmentos (20) com altern√¢ncia
                    const segs = 20;
                    ctx.save();
                    ctx.translate(cx, cy);
                    for (let i = 0; i < segs; i++) {
                        const a0 = (i / segs) * Math.PI * 2;
                        const a1 = ((i + 1) / segs) * Math.PI * 2;

                        // setor base
                        ctx.beginPath();
                        ctx.moveTo(0,0);
                        ctx.arc(0,0, r, a0, a1);
                        ctx.closePath();
                        ctx.fillStyle = (i % 2 === 0) ? '#f5f5f5' : '#212121';
                        ctx.fill();

                        // recorte para manter s√≥ a √°rea do setor (sem cobrir o centro demais)
                        ctx.globalCompositeOperation = 'source-atop';

                        // faixa dupla (verde/vermelha)
                        ctx.beginPath();
                        ctx.arc(0,0, ring1, a0, a1);
                        ctx.arc(0,0, ring1 - r*0.06, a1, a0, true);
                        ctx.closePath();
                        ctx.fillStyle = (i % 2 === 0) ? '#2e7d32' : '#c62828';
                        ctx.fill();

                        // faixa tripla (verde/vermelha invertido)
                        ctx.beginPath();
                        ctx.arc(0,0, ring2, a0, a1);
                        ctx.arc(0,0, ring2 - r*0.06, a1, a0, true);
                        ctx.closePath();
                        ctx.fillStyle = (i % 2 === 0) ? '#c62828' : '#2e7d32';
                        ctx.fill();

                        ctx.globalCompositeOperation = 'source-over';
                    }
                    ctx.restore();

                    // Anel interno claro/escuro
                    drawCircle(cx, cy, ring3, 'rgba(255,255,255,0.06)');

                    // Bull e bullseye
                    drawCircle(cx, cy, bull, '#2e7d32');
                    drawCircle(cx, cy, bull2, '#c62828');

                    // Divis√≥rias radiais
                    ctx.save();
                    ctx.translate(cx, cy);
                    for (let i = 0; i < segs; i++) {
                        const a = (i / segs) * Math.PI * 2;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(a) * (r*0.22), Math.sin(a) * (r*0.22));
                        ctx.lineTo(Math.cos(a) * (r*0.98), Math.sin(a) * (r*0.98));
                        ctx.strokeStyle = 'rgba(255,255,255,0.12)';
                        ctx.lineWidth = 0.8;
                        ctx.stroke();
                    }
                    ctx.restore();

                    // Suporte na parede
                    drawRect(cx - (r + 3), y + s.h - 4, (r + 3) * 2, 3.5, '#8d6e63');
                    drawRect(cx - (r + 3), y + s.h - 4, (r + 3) * 2, 0.8, 'rgba(0,0,0,0.2)');

                    // 2 dardos cravados (simples)
                    function drawDart(dx, dy, ang) {
                        ctx.save();
                        ctx.translate(cx + dx, cy + dy);
                        ctx.rotate(ang);
                        // haste
                        drawLine(-6, 0, 4, 0, 1.2, '#b0bec5');
                        // ponta
                        drawLine(4, 0, 6, 0, 1.2, '#757575');
                        // penas
                        drawRect(-9, -2, 3, 4, '#1565c0');
                        drawRect(-12, -1.5, 3, 3, '#42a5f5');
                        ctx.restore();
                    }
                    drawDart(-r*0.15, -r*0.08, -0.2);
                    drawDart(r*0.10, r*0.12, 0.5);
                    break;

                case 'neon_signs':
                    // Letreiro neon (maior e mais realista)
                    const pad = 2;
                    // Placa de fundo
                    drawRect(left, y, s.w, s.h, 'rgba(0,0,0,0.55)');
                    drawRect(left + 1, y + 1, s.w - 2, s.h - 2, 'rgba(255,255,255,0.05)');

                    // Caixa do transformador
                    drawRect(left + s.w - 6, y + s.h - 5, 5, 4, '#263238');
                    drawRect(left + s.w - 5.6, y + s.h - 4.6, 4.2, 0.6, 'rgba(255,255,255,0.15)');

                    // Texto em neon: "BAR"
                    ctx.save();
                    ctx.translate(left + pad, y + pad);
                    const textW = s.w - pad*2 - 6;
                    const textH = s.h - pad*2;

                    // glow forte + tubo
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';

                    function neonStroke(strokeW, glowW, alpha) {
                        ctx.strokeStyle = `rgba(255, 87, 34, ${alpha})`;
                        ctx.shadowColor = `rgba(255, 87, 34, ${alpha})`;
                        ctx.shadowBlur = glowW;
                        ctx.lineWidth = strokeW;
                        ctx.stroke();
                    }

                    // Desenhar letras como caminhos simples
                    const baseX = 2;
                    const midY = textH/2 + 1;

                    // B
                    ctx.beginPath();
                    ctx.moveTo(baseX, 1);
                    ctx.lineTo(baseX, textH - 1);
                    ctx.moveTo(baseX, 1);
                    ctx.lineTo(baseX + textW*0.18, 3);
                    ctx.lineTo(baseX + textW*0.18, midY - 2);
                    ctx.lineTo(baseX, midY);
                    ctx.moveTo(baseX, midY);
                    ctx.lineTo(baseX + textW*0.18, midY + 2);
                    ctx.lineTo(baseX + textW*0.18, textH - 3);
                    ctx.lineTo(baseX, textH - 1);

                    // A
                    const ax = baseX + textW*0.32;
                    ctx.moveTo(ax, textH - 1);
                    ctx.lineTo(ax + textW*0.08, 1);
                    ctx.lineTo(ax + textW*0.16, textH - 1);
                    ctx.moveTo(ax + textW*0.04, midY);
                    ctx.lineTo(ax + textW*0.12, midY);

                    // R
                    const rx = baseX + textW*0.62;
                    ctx.moveTo(rx, textH - 1);
                    ctx.lineTo(rx, 1);
                    ctx.lineTo(rx + textW*0.18, 3);
                    ctx.lineTo(rx + textW*0.18, midY - 2);
                    ctx.lineTo(rx, midY);
                    ctx.moveTo(rx, midY);
                    ctx.lineTo(rx + textW*0.18, textH - 1);

                    // Glow + tubo
                    neonStroke(6, 14, 0.35);
                    neonStroke(3.5, 10, 0.55);
                    neonStroke(2.2, 6, 0.9);

                    ctx.restore();

                    // Cabinho do transformador
                    drawLine(left + s.w - 6, y + s.h - 3, left + s.w - 12, y + s.h - 2, 1, '#616161');
                    break;

                case 'clothing_rack': // Cabideiro de Roupas Detalhado
                    // Estrutura tubular met√°lica principal (mais robusta)
                    drawRect(cx - 1.5, y, 3, s.h, '#c0c0c0'); // Poste central mais grosso
                    drawRect(cx - 1, y + 1, 2, s.h - 2, '#e0e0e0'); // Interior mais claro

                    // Barras horizontais para cabides (4 n√≠veis)
                    for(let level = 0; level < 4; level++) {
                        const barY = y + 3 + level * 3;
                        const barLength = level % 2 === 0 ? 18 : 16; // Barras alternadas
                        const barOffset = level % 2 === 0 ? -9 : -8;

                        drawRect(cx + barOffset, barY, barLength, 2, '#a0a0a0');
                        drawRect(cx + barOffset + 1, barY + 1, barLength - 2, 0.5, '#c0c0c0'); // Reflexo
                    }

                    // Suportes diagonais para estabilidade
                    drawLine(cx - 1.5, y + 2, cx - 6, y + 6, 2, '#a0a0a0'); // Suporte esquerdo
                    drawLine(cx + 1.5, y + 2, cx + 6, y + 6, 2, '#a0a0a0'); // Suporte direito

                    // Roupas penduradas com mais detalhes
                    const clothes = [
                        { type: 'shirt', color: '#ff5722', width: 2, height: 3 },
                        { type: 'pants', color: '#2196f3', width: 2, height: 4 },
                        { type: 'dress', color: '#e91e63', width: 3, height: 4 },
                        { type: 'jacket', color: '#4caf50', width: 3, height: 3 },
                        { type: 'skirt', color: '#9c27b0', width: 2.5, height: 2.5 },
                        { type: 'blouse', color: '#ff9800', width: 2, height: 2.5 }
                    ];

                    for(let i = 0; i < 8; i++) {
                        const clothX = cx - 7 + i * 2.2;
                        const level = i % 4;
                        const clothY = y + 5 + level * 3;
                        const cloth = clothes[i % clothes.length];

                        // Cabide (mais detalhado)
                        drawRect(clothX - 0.8, clothY - 0.5, 1.6, 0.3, '#424242'); // Arco do cabide
                        drawRect(clothX - 0.2, clothY - 0.8, 0.4, 0.5, '#666'); // Gancho

                        // Roupa com detalhes espec√≠ficos por tipo
                        drawRect(clothX - cloth.width/2, clothY, cloth.width, cloth.height, cloth.color);

                        // Detalhes espec√≠ficos por tipo de roupa
                        if (cloth.type === 'shirt' || cloth.type === 'blouse') {
                            // Mangas
                            drawRect(clothX - cloth.width/2 + 0.2, clothY + cloth.height - 0.8, 0.6, 0.8, '#fff');
                            drawRect(clothX + cloth.width/2 - 0.8, clothY + cloth.height - 0.8, 0.6, 0.8, '#fff');
                            // Gola
                            drawRect(clothX - 0.3, clothY, 0.6, 0.3, '#fff');
                        } else if (cloth.type === 'jacket') {
                            // Z√≠per ou bot√µes
                            drawRect(clothX - 0.1, clothY + 0.5, 0.2, cloth.height - 1, '#c0c0c0');
                            // Mangas
                            drawRect(clothX - cloth.width/2 + 0.2, clothY + cloth.height - 0.8, 0.6, 0.8, cloth.color);
                            drawRect(clothX + cloth.width/2 - 0.8, clothY + cloth.height - 0.8, 0.6, 0.8, cloth.color);
                        } else if (cloth.type === 'dress') {
                            // Cintura
                            drawRect(clothX - cloth.width/2 + 0.5, clothY + cloth.height/2, cloth.width - 1, 0.3, '#fff');
                        }
                    }

                    // Base com rodinhas (4 rodinhas)
                    let rackWheelPositions = [-8, -3, 3, 8];
                    rackWheelPositions.forEach(wheelX => {
                        drawCircle(cx + wheelX, y + s.h, 1.2, '#silver'); // Rodinha externa
                        drawCircle(cx + wheelX, y + s.h, 0.6, '#424242'); // Centro da rodinha
                        drawRect(cx + wheelX - 0.8, y + s.h - 0.2, 1.6, 0.4, '#666'); // Eixo
                    });

                    // Etiqueta de pre√ßo em um dos cabides
                    drawRect(cx - 5, y + 5, 2, 1, '#fff');
                    drawText('$49', cx - 4.5, y + 5.8, 0.6, '#000');

                    // Indicador visual de interatividade
                    const blinkRack = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx, y + 2, 0.8, `rgba(255, 193, 7, ${blinkRack})`);
                    break;

                case 'cash_register': // Caixa Registradora com Balc√£o
                    // Primeiro desenhar o balc√£o/suporte (sempre vis√≠vel)
                    drawRect(left - 2, y + 8, s.w + 4, 4, '#8d6e63'); // Balc√£o de madeira
                    drawRect(left, y + 10, s.w, 2, '#a1887f'); // Superf√≠cie superior
                    drawRect(left - 1, y + 12, s.w + 2, 1, '#5d4037'); // Sombra inferior

                    // Pernas do balc√£o
                    drawRect(left + 2, y + 12, 2, 4, '#5d4037'); // Perna esquerda
                    drawRect(right - 4, y + 12, 2, 4, '#5d4037'); // Perna direita

                    // Corpo principal da caixa registradora
                    drawRoundRect(left, y + 4, s.w, 6, 2, '#e0e0e0'); // Corpo branco
                    drawRoundRect(left + 1, y + 5, s.w - 2, 4, 1, '#f5f5f5'); // Interior

                    // Gaveta de dinheiro (mais detalhada)
                    drawRect(left + 1, y + 2, s.w - 2, 2.5, '#424242'); // Gaveta externa
                    drawRect(left + 2, y + 2.5, s.w - 4, 1.5, '#212121'); // Interior da gaveta

                    // Puxador da gaveta
                    drawRect(left + 2, y + 1, 2, 3.5, '#silver'); // Puxador cromado
                    drawRect(left + 2.3, y + 1.3, 1.4, 3, '#e0e0e0'); // Interior do puxador

                    // Tela digital LCD
                    drawRect(cx - 3, y, 6, 3, '#000'); // Moldura
                    drawRect(cx - 2.5, y + 0.3, 5, 2.4, '#001122'); // Tela azul
                    drawText('$0.00', cx - 2, y + 1.5, 1, '#00ff00'); // Valor

                    // Teclado num√©rico (4x3)
                    const keyLabels = ['7', '8', '9', '4', '5', '6', '1', '2', '3', '0', '.', 'C'];
                    let keyIndex = 0;

                    for(let row = 0; row < 4; row++) {
                        for(let col = 0; col < 3; col++) {
                            if (keyIndex < keyLabels.length) {
                                const keyX = left + 2 + col * 2.5;
                                const keyY = y + 6 + row * 1.5;

                                // Tecla
                                drawRect(keyX, keyY, 2, 1.2, '#f0f0f0'); // Fundo
                                drawRect(keyX + 0.2, keyY + 0.2, 1.6, 0.8, '#e0e0e0'); // Interior
                                drawRect(keyX + 0.3, keyY + 0.3, 1.4, 0.6, '#fff'); // Destaque

                                // N√∫mero na tecla
                                drawText(keyLabels[keyIndex], keyX + 1, keyY + 0.9, 0.8, '#000');
                                keyIndex++;
                            }
                        }
                    }

                    // Leitor de cart√£o (maquininha)
                    drawRect(cx + 3, y + 8, 3, 2, '#212121'); // Corpo
                    drawRect(cx + 3.5, y + 8.5, 2, 0.5, '#666'); // Fenda do cart√£o
                    drawRect(cx + 3.2, y + 9.2, 2.6, 0.5, '#000'); // Tela pequena

                    // Luz de status (LED)
                    const statusLed = Math.sin(getGameTime() / 1000) > 0 ? '#00ff00' : '#004400';
                    drawCircle(cx + 5, y + 1, 0.5, statusLed);

                    // Cabo de energia
                    drawLine(cx - 4, y + 10, cx - 4, y + 14, 0.5, '#000');
                    drawCircle(cx - 4, y + 14, 0.5, '#silver'); // Plug

                    // Etiqueta de pre√ßo na lateral
                    drawRect(left - 1, y + 6, 1, 2, '#fff');
                    drawText('$', left - 0.8, y + 7, 0.8, '#000');

                    // Indicador visual de interatividade
                    const blinkRegister = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx, y + 2, 0.8, `rgba(0, 255, 0, ${blinkRegister})`);
                    break;

                case 'mannequins': // Mannequins Detalhados
                    // Corpo principal (mais estilizado)
                    drawRect(cx - 2, y + 4, 4, 8, '#f5f5f5'); // Corpo branco fosco
                    drawRect(cx - 1.5, y + 5, 3, 6, '#fafafa'); // Interior

                    // Cabe√ßa oval (mais realista)
                    drawEllipse(cx, y + 2, 1.8, 2.2, '#f5f5f5');

                    // Bra√ßos articulados
                    drawRect(cx - 4, y + 5, 2, 5, '#f5f5f5'); // Bra√ßo esquerdo
                    drawRect(cx + 2, y + 5, 2, 5, '#f5f5f5'); // Bra√ßo direito
                    // Cotovelos
                    drawCircle(cx - 3, y + 7.5, 0.3, '#e0e0e0');
                    drawCircle(cx + 3, y + 7.5, 0.3, '#e0e0e0');

                    // Pernas (mais finas)
                    drawRect(cx - 1.2, y + 12, 1.2, 4, '#f5f5f5'); // Perna esquerda
                    drawRect(cx - 0.2, y + 12, 1.2, 4, '#f5f5f5'); // Perna direita
                    // Joelhos
                    drawCircle(cx - 0.6, y + 14, 0.3, '#e0e0e0');
                    drawCircle(cx + 0.6, y + 14, 0.3, '#e0e0e0');

                    // Roupas no manequim (conjunto completo)
                    // Blusa/camiseta
                    drawRect(cx - 2.8, y + 4.5, 5.6, 3.2, '#ff5722');
                    drawRect(cx - 2.2, y + 6, 4.4, 0.8, '#fff'); // Barra inferior
                    // Mangas
                    drawRect(cx - 3.2, y + 4.5, 1, 2, '#ff5722');
                    drawRect(cx + 2.2, y + 4.5, 1, 2, '#ff5722');

                    // Cal√ßa
                    drawRect(cx - 2.2, y + 7.2, 4.4, 5, '#2196f3');
                    drawRect(cx - 1.8, y + 9, 3.6, 0.4, '#1976d2'); // Cintura
                    // Pernas da cal√ßa
                    drawRect(cx - 1.8, y + 9.4, 1.6, 2.8, '#2196f3');
                    drawRect(cx + 0.2, y + 9.4, 1.6, 2.8, '#2196f3');

                    // Detalhes faciais minimalistas
                    drawCircle(cx - 0.4, y + 1.8, 0.2, '#000'); // Olho esquerdo
                    drawCircle(cx + 0.4, y + 1.8, 0.2, '#000'); // Olho direito
                    drawRect(cx - 0.3, y + 3.2, 0.6, 0.2, '#c2185b'); // Boca

                    // Cabelo estilizado
                    drawEllipse(cx, y + 0.5, 2, 1, '#8d6e63');
                    drawEllipse(cx - 0.5, y + 0.2, 1, 0.8, '#5d4037'); // Mecha

                    // Base de metal com ajuste de altura
                    drawRect(cx - 1.5, y + 16, 3, 2, '#c0c0c0'); // Base circular
                    drawRect(cx - 1, y + 17, 2, 1, '#e0e0e0'); // Centro
                    drawRect(cx - 0.5, y + 16.5, 1, 1.5, '#666'); // Pino de ajuste

                    // Etiqueta de pre√ßo
                    drawRect(cx - 1, y + 6, 2, 1, '#fff');
                    drawText('$89', cx - 0.8, y + 6.8, 0.6, '#000');

                    // Indicador visual de interatividade
                    const blinkMannequin = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx, y, 0.8, `rgba(255, 105, 180, ${blinkMannequin})`);
                    break;

                case 'fitting_rooms': // Cabines de Prova Detalhadas
                    // Estrutura principal das cabines (parede de fundo)
                    drawRect(left, y, s.w, s.h, '#e8e8e8'); // Parede bege clara

                    // Divis√≥rias internas (pain√©is divis√≥rios)
                    drawRect(cx - 1, y, 2, s.h, '#d0d0d0'); // Divis√≥ria central
                    drawRect(cx - 1.5, y + 1, 3, s.h - 2, '#e0e0e0'); // Sombra interna

                    drawRect(cx - 8, y, 2, s.h, '#d0d0d0'); // Divis√≥ria esquerda
                    drawRect(cx - 8.5, y + 1, 3, s.h - 2, '#e0e0e0');

                    drawRect(cx + 6, y, 2, s.h, '#d0d0d0'); // Divis√≥ria direita
                    drawRect(cx + 5.5, y + 1, 3, s.h - 2, '#e0e0e0');

                    // Cortinas com dobras (mais realistas)
                    // Cabine 1 (esquerda)
                    ctx.fillStyle = '#9c27b0';
                    ctx.beginPath();
                    ctx.moveTo(cx - 9, y + 2);
                    ctx.quadraticCurveTo(cx - 8.5, y + 5, cx - 9, y + 8);
                    ctx.quadraticCurveTo(cx - 8.5, y + 11, cx - 9, y + 14);
                    ctx.lineTo(cx - 9, y + s.h - 2);
                    ctx.fill();

                    // Cabine 2 (meio)
                    ctx.fillStyle = '#ff5722';
                    ctx.beginPath();
                    ctx.moveTo(cx - 2, y + 2);
                    ctx.quadraticCurveTo(cx - 1.5, y + 5, cx - 2, y + 8);
                    ctx.quadraticCurveTo(cx - 1.5, y + 11, cx - 2, y + 14);
                    ctx.lineTo(cx - 2, y + s.h - 2);
                    ctx.fill();

                    // Cabine 3 (direita)
                    ctx.fillStyle = '#2196f3';
                    ctx.beginPath();
                    ctx.moveTo(cx + 7, y + 2);
                    ctx.quadraticCurveTo(cx + 6.5, y + 5, cx + 7, y + 8);
                    ctx.quadraticCurveTo(cx + 6.5, y + 11, cx + 7, y + 14);
                    ctx.lineTo(cx + 7, y + s.h - 2);
                    ctx.fill();

                    // N√∫meros das cabines em placas douradas
                    // Cabine 1
                    drawRect(cx - 7.5, y + 3, 2, 1.5, '#daa520');
                    drawText('1', cx - 6.8, y + 4, 1.2, '#000');

                    // Cabine 2
                    drawRect(cx - 0.5, y + 3, 2, 1.5, '#daa520');
                    drawText('2', cx + 0.2, y + 4, 1.2, '#000');

                    // Cabine 3
                    drawRect(cx + 6.5, y + 3, 2, 1.5, '#daa520');
                    drawText('3', cx + 7.2, y + 4, 1.2, '#000');

                    // Travas/indicadores de ocupado
                    // Cabine 1 - livre (verde)
                    drawCircle(cx - 6.5, y + 6, 0.4, '#4caf50');
                    // Cabine 2 - ocupado (vermelho)
                    drawCircle(cx + 0.5, y + 6, 0.4, '#f44336');
                    // Cabine 3 - livre (verde)
                    drawCircle(cx + 7.5, y + 6, 0.4, '#4caf50');

                    // Espelhos internos (vis√≠veis nas aberturas)
                    drawRect(cx - 7, y + 8, 0.5, 3, 'rgba(255, 255, 255, 0.7)');
                    drawRect(cx + 1, y + 8, 0.5, 3, 'rgba(255, 255, 255, 0.7)');
                    drawRect(cx + 8, y + 8, 0.5, 3, 'rgba(255, 255, 255, 0.7)');

                    // Bancos internos
                    drawRect(cx - 6, y + s.h - 3, 2, 1, '#8d6e63'); // Banco cabine 1
                    drawRect(cx + 0, y + s.h - 3, 2, 1, '#8d6e63'); // Banco cabine 2
                    drawRect(cx + 7, y + s.h - 3, 2, 1, '#8d6e63'); // Banco cabine 3

                    // Placa "Fitting Rooms" acima
                    drawRect(cx - 6, y - 3, 12, 2, '#8d6e63');
                    drawText('FITTING ROOMS', cx - 5.5, y - 1.5, 1, '#fff');

                    // Indicador visual de interatividade
                    const blinkFitting = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx, y + 2, 0.8, `rgba(255, 0, 255, ${blinkFitting})`);
                    // Cabides internos
                    drawRect(cx - 7, y + 8, 1, 4, '#c0c0c0');
                    drawRect(cx - 1, y + 8, 1, 4, '#c0c0c0');
                    drawRect(cx + 7, y + 8, 1, 4, '#c0c0c0');
                    // Espelhos internos (representa√ß√£o)
                    drawRect(cx - 6, y + 6, 2, 4, 'rgba(255, 255, 255, 0.8)');
                    drawRect(cx, y + 6, 2, 4, 'rgba(255, 255, 255, 0.8)');
                    drawRect(cx + 8, y + 6, 2, 4, 'rgba(255, 255, 255, 0.8)');
                    break;

                case 'shoe_rack': // Rack de Sapatos Detalhado
                    // Estrutura principal de madeira polida
                    drawRect(left, y, s.w, s.h, '#d7ccc8'); // Madeira clara
                    drawRect(left + 1, y + 1, s.w - 2, s.h - 2, '#f5f5f5'); // Interior

                    // Prateleiras com detalhes
                    for(let i = 0; i < 3; i++) {
                        const shelfY = y + 2 + i * 3.5;
                        // Prateleira principal
                        drawRect(left + 1, shelfY, s.w - 2, 1.5, '#8d6e63');
                        drawRect(left + 2, shelfY + 0.5, s.w - 4, 0.8, '#a1887f');

                        // Sapatos organizados por tipo
                        const shoesOnShelf = [
                            { type: 'sneakers', color: '#fff', size: 2.2 },
                            { type: 'heels', color: '#000', size: 1.8 },
                            { type: 'boots', color: '#8d6e63', size: 2.5 },
                            { type: 'sandals', color: '#ff9800', size: 1.5 }
                        ];

                        for(let j = 0; j < shoesOnShelf.length; j++) {
                            const shoe = shoesOnShelf[j];
                            const shoeX = left + 2 + j * 4;

                            if (shoe.type === 'sneakers') {
                                // T√™nis esportivo
                                drawRect(shoeX, shelfY + 1, shoe.size, 1.5, shoe.color);
                                drawRect(shoeX + shoe.size, shelfY + 1, shoe.size * 0.8, 1.5, shoe.color);
                                // Cadar√ßos
                                drawRect(shoeX + 0.3, shelfY + 1.2, shoe.size - 0.6, 0.3, '#000');
                                drawRect(shoeX + shoe.size + 0.2, shelfY + 1.2, shoe.size * 0.8 - 0.4, 0.3, '#000');
                                // Logo
                                drawRect(shoeX + 0.5, shelfY + 2, 0.5, 0.3, '#ff5722');

                            } else if (shoe.type === 'heels') {
                                // Salto alto elegante
                                drawRect(shoeX, shelfY + 1, shoe.size, 2, shoe.color);
                                // Salto
                                drawRect(shoeX + 0.3, shelfY + 3, 0.4, 0.8, '#silver');
                                drawRect(shoeX + shoe.size - 0.7, shelfY + 3, 0.4, 0.8, '#silver');
                                // Detalhes
                                drawRect(shoeX + 0.2, shelfY + 1.2, shoe.size - 0.4, 0.3, '#c2185b');

                            } else if (shoe.type === 'boots') {
                                // Bota estilo cowboy
                                drawRect(shoeX, shelfY + 1, shoe.size, 2.5, shoe.color);
                                drawRect(shoeX + 0.2, shelfY + 3.5, shoe.size - 0.4, 0.5, '#a1887f');
                                // Bico fino
                                drawRect(shoeX + 0.5, shelfY + 2.5, shoe.size - 1, 0.3, '#5d4037');

                            } else if (shoe.type === 'sandals') {
                                // Sand√°lia
                                drawRect(shoeX, shelfY + 1, shoe.size, 0.8, shoe.color);
                                drawRect(shoeX + 0.3, shelfY + 1.8, 0.3, 0.5, '#8d6e63'); // Correia
                                drawRect(shoeX + shoe.size - 0.6, shelfY + 1.8, 0.3, 0.5, '#8d6e63');
                            }

                            // Etiqueta de tamanho
                            drawRect(shoeX + shoe.size/2 - 0.3, shelfY + 0.5, 0.6, 0.4, '#fff');
                            drawText(Math.floor(35 + j * 2) + '', shoeX + shoe.size/2 - 0.2, shelfY + 0.7, 0.3, '#000');
                        }
                    }

                    // Suportes laterais refor√ßados
                    drawRect(left + 2, y, 2, s.h, '#5d4037'); // Lateral esquerda
                    drawRect(left + 2.5, y + 1, 1, s.h - 2, '#8d6e63');
                    drawRect(right - 4, y, 2, s.h, '#5d4037'); // Lateral direita
                    drawRect(right - 3.5, y + 1, 1, s.h - 2, '#8d6e63');

                    // Placa identificadora
                    drawRect(cx - 4, y - 2, 8, 1.5, '#8d6e63');
                    drawText('SHOE RACK', cx - 3.5, y - 0.8, 0.8, '#fff');

                    // Etiqueta de pre√ßo
                    drawRect(cx - 2, y + s.h + 1, 4, 1, '#fff');
                    drawText('FROM $39', cx - 1.5, y + s.h + 1.8, 0.6, '#000');

                    // Indicador visual de interatividade
                    const blinkShoe = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx, y + 2, 0.8, `rgba(160, 82, 45, ${blinkShoe})`);
                    break;

                case 'mirror_wall': // Espelho de Parede Decorativo
                    // Moldura elegante em madeira dourada
                    drawRect(left, y, s.w, 3, '#daa520'); // Moldura superior dourada
                    drawRect(left, y + s.h - 3, s.w, 3, '#daa520'); // Moldura inferior
                    drawRect(left, y, 3, s.h, '#daa520'); // Lateral esquerda
                    drawRect(right - 3, y, 3, s.h, '#daa520'); // Lateral direita

                    // Interior da moldura (preto fosco)
                    drawRect(left + 1, y + 1, s.w - 2, 2, '#424242');
                    drawRect(left + 1, y + s.h - 3, s.w - 2, 2, '#424242');
                    drawRect(left + 1, y + 1, 2, s.h - 2, '#424242');
                    drawRect(right - 3, y + 1, 2, s.h - 2, '#424242');

                    // Superf√≠cie espelhada com reflexo realista
                    drawRect(left + 3, y + 3, s.w - 6, s.h - 6, 'rgba(255, 255, 255, 0.95)');

                    // Reflexos luminosos (como luz ambiente)
                    // Luz superior esquerda
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.beginPath();
                    ctx.arc(left + 6, y + 6, 3, 0, Math.PI * 2);
                    ctx.fill();

                    // Reflexo inferior direito
                    ctx.fillStyle = 'rgba(255, 193, 7, 0.4)';
                    ctx.beginPath();
                    ctx.arc(right - 8, y + s.h - 8, 2, 0, Math.PI * 2);
                    ctx.fill();

                    // Pessoa refletida (cliente olhando no espelho)
                    // Corpo
                    drawRect(cx - 1.5, y + 8, 3, 6, 'rgba(0, 0, 0, 0.3)');
                    // Cabe√ßa
                    drawCircle(cx, y + 6, 1.2, 'rgba(0, 0, 0, 0.3)');
                    // Bra√ßos (posi√ß√£o de provar roupa)
                    drawRect(cx - 3, y + 9, 1.5, 4, 'rgba(0, 0, 0, 0.3)');
                    drawRect(cx + 1.5, y + 9, 1.5, 4, 'rgba(0, 0, 0, 0.3)');

                    // Reflexos de produtos ao redor
                    // Cabides refletidos
                    for(let i = 0; i < 3; i++) {
                        const refX = left + 8 + i * 4;
                        drawRect(refX, y + 10, 0.8, 3, 'rgba(139, 69, 19, 0.2)');
                    }

                    // Detalhes ornamentais na moldura
                    for(let i = 0; i < Math.floor((s.w - 6) / 6); i++) {
                        // Superior
                        drawCircle(left + 6 + i * 6, y + 1.5, 0.4, '#ffd700');
                        // Inferior
                        drawCircle(left + 6 + i * 6, y + s.h - 1.5, 0.4, '#ffd700');
                    }

                    // Laterais
                    for(let i = 0; i < Math.floor((s.h - 6) / 8); i++) {
                        drawCircle(left + 1.5, y + 6 + i * 8, 0.4, '#ffd700');
                        drawCircle(right - 1.5, y + 6 + i * 8, 0.4, '#ffd700');
                    }

                    // Logo da loja refletido
                    drawRect(cx - 4, y + 4, 8, 1.5, 'rgba(255, 0, 255, 0.3)');
                    drawText('Fashion', cx - 3.5, y + 5, 0.8, 'rgba(255, 0, 255, 0.5)');

                    // Indicador visual de interatividade
                    const blinkMirror = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx, y + 2, 0.8, `rgba(255, 215, 0, ${blinkMirror})`);
                    break;

                case 'display_window': // Vitrine de Exposi√ß√£o Detalhada
                    // Estrutura externa da vitrine
                    drawRect(left, y, s.w, s.h, '#f5f5f5');

                    // Moldura elegante em madeira escura
                    drawRect(left, y, s.w, 3, '#5d4037'); // Superior
                    drawRect(left, y + s.h - 3, s.w, 3, '#5d4037'); // Inferior
                    drawRect(left, y, 3, s.h, '#5d4037'); // Esquerda
                    drawRect(right - 3, y, 3, s.h, '#5d4037'); // Direita

                    // Vidro temperado com reflexo sutil
                    drawRect(left + 3, y + 3, s.w - 6, s.h - 6, 'rgba(255, 255, 255, 0.85)');
                    // Reflexo do ambiente
                    drawRect(left + 4, y + 4, s.w - 8, 2, 'rgba(135, 206, 235, 0.3)');

                    // Manequim principal central (modelo apresentando cole√ß√£o)
                    // Corpo estilizado
                    drawRect(cx - 1.5, y + 7, 3, 6, '#f5f5f5');
                    drawRect(cx - 1, y + 8, 2, 4, '#fafafa');
                    // Cabe√ßa oval elegante
                    drawEllipse(cx, y + 5, 1.2, 1.5, '#f5f5f5');
                    // Cabelos estilizados
                    drawEllipse(cx, y + 4, 1.5, 1, '#8d6e63');

                    // Look principal - conjunto elegante
                    // Blusa/top
                    drawRect(cx - 3, y + 7.5, 6, 2.5, '#e91e63');
                    drawRect(cx - 2.5, y + 8.5, 5, 0.8, '#fff'); // Decote
                    // Saia/cal√ßa
                    drawRect(cx - 2.5, y + 10, 5, 3, '#2196f3');
                    drawRect(cx - 2, y + 11.5, 4, 0.5, '#1976d2'); // Cintura

                    // Acess√≥rios do manequim principal
                    // Colar
                    drawCircle(cx, y + 9, 0.3, '#ffd700');
                    drawRect(cx - 0.5, y + 9, 1, 0.1, '#ffd700');
                    // Brincos
                    drawCircle(cx - 0.8, y + 5.5, 0.15, '#c2185b');
                    drawCircle(cx + 0.8, y + 5.5, 0.15, '#c2185b');

                    // Manequins laterais (exposi√ß√µes secund√°rias)
                    // Esquerda - vestido longo
                    drawRect(cx - 8, y + 8, 2.5, 5, '#f5f5f5'); // Corpo
                    drawCircle(cx - 7, y + 6.5, 0.8, '#f5f5f5'); // Cabe√ßa
                    drawRect(cx - 9.5, y + 8.5, 5, 4, '#4caf50'); // Vestido
                    drawRect(cx - 9, y + 11, 4, 0.5, '#388e3c'); // Cintura

                    // Direita - look casual
                    drawRect(cx + 5.5, y + 7, 2.5, 5, '#f5f5f5'); // Corpo
                    drawCircle(cx + 6.5, y + 5.5, 0.8, '#f5f5f5'); // Cabe√ßa
                    drawRect(cx + 4, y + 7.5, 5, 2, '#ff9800'); // Blusa
                    drawRect(cx + 4.5, y + 9.5, 4, 2.5, '#795548'); // Cal√ßa jeans

                    // Acess√≥rios diversos na vitrine
                    // Bolsas
                    drawRect(cx - 10, y + 10, 1.5, 2, '#8d6e63'); // Bolsa marrom
                    drawCircle(cx + 8, y + 8, 1, '#ffd700'); // Bolsa dourada

                    // Chap√©us/√≥culos
                    drawRect(cx + 9, y + 5, 2, 0.8, '#000'); // Chap√©u
                    drawRect(cx - 5, y + 4, 1.5, 0.5, '#000'); // √ìculos

                    // Cal√ßados expostos
                    drawRect(cx - 6, y + 14, 1.5, 1, '#fff'); // T√™nis
                    drawRect(cx + 7, y + 14, 1.2, 1.8, '#000'); // Bota

                    // Letreiro "NEW COLLECTION"
                    drawRect(cx - 6, y + 1, 12, 2, '#9c27b0');
                    drawText('NEW COLLECTION', cx - 5.5, y + 2, 0.9, '#fff');

                    // Etiqueta de pre√ßo na vitrine
                    drawRect(cx - 2, y + 13, 4, 1, '#fff');
                    drawText('$299', cx - 1.5, y + 13.8, 0.7, '#000');

                    // Indicador visual de interatividade
                    const blinkWindow = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx, y + 2, 0.8, `rgba(255, 0, 255, ${blinkWindow})`);
                    break;

                case 'hangers_rack': // Rack de Cabides Industrial
                    // Estrutura met√°lica principal
                    const rackWidth = Math.min(s.w, 20); // Largura limitada

                    // Barra principal cromada
                    drawRect(cx - rackWidth/2, y + 3, rackWidth, 2.5, '#c0c0c0');
                    drawRect(cx - rackWidth/2 + 0.5, y + 3.5, rackWidth - 1, 1, '#e0e0e0');

                    // Suportes verticais refor√ßados
                    drawRect(cx - rackWidth/2, y, 3, 10, '#424242'); // Esquerdo
                    drawRect(cx - rackWidth/2 + 1, y + 1, 1, 8, '#616161');
                    drawRect(cx + rackWidth/2 - 3, y, 3, 10, '#424242'); // Direito
                    drawRect(cx + rackWidth/2 - 2, y + 1, 1, 8, '#616161');

                    // Base de suporte
                    drawRect(cx - rackWidth/2 - 1, y + 10, rackWidth + 2, 1.5, '#666');
                    drawRect(cx - rackWidth/2, y + 11, rackWidth, 0.5, '#999');

                    // Cabides pendurados com variedade
                    const hangerTypes = ['wire', 'wood', 'plastic', 'metal'];
                    const hangerColors = ['#c0c0c0', '#8d6e63', '#ff9800', '#424242'];

                    for(let i = 0; i < 10; i++) {
                        const hangerX = cx - rackWidth/2 + 2 + i * ((rackWidth - 4) / 9);
                        const hangerType = hangerTypes[i % hangerTypes.length];
                        const hangerColor = hangerColors[i % hangerColors.length];

                        if (hangerType === 'wire') {
                            // Cabide de arame fino
                            drawRect(hangerX, y + 1, 0.3, 2, '#666'); // Gancho fino
                            drawRect(hangerX - 0.8, y + 3, 1.8, 0.2, '#c0c0c0'); // Corpo
                            // Curva sutil
                            drawCircle(hangerX - 0.5, y + 3.1, 0.2, '#c0c0c0');

                        } else if (hangerType === 'wood') {
                            // Cabide de madeira
                            drawRect(hangerX, y + 1, 0.4, 2, '#8d6e63'); // Gancho
                            drawRect(hangerX - 1, y + 3, 2.2, 0.4, '#a1887f'); // Corpo
                            // Textura de madeira
                            drawRect(hangerX - 0.8, y + 3.1, 1.8, 0.2, '#795548');

                        } else if (hangerType === 'plastic') {
                            // Cabide pl√°stico colorido
                            drawRect(hangerX, y + 1, 0.4, 2, '#666'); // Gancho
                            drawRect(hangerX - 1, y + 3, 2.2, 0.3, hangerColor); // Corpo
                            // Brilho pl√°stico
                            drawRect(hangerX - 0.9, y + 3.1, 2, 0.1, '#fff');

                        } else if (hangerType === 'metal') {
                            // Cabide met√°lico pesado
                            drawRect(hangerX, y + 1, 0.5, 2, '#424242'); // Gancho grosso
                            drawRect(hangerX - 1.2, y + 3, 2.6, 0.4, '#616161'); // Corpo refor√ßado
                            // Detalhes met√°licos
                            drawRect(hangerX - 1, y + 3.2, 2.2, 0.1, '#c0c0c0');
                        }

                        // Algumas roupas penduradas
                        if (i % 3 === 0) { // Apenas alguns cabides com roupa
                            const clothColor = ['#e91e63', '#2196f3', '#4caf50', '#ff9800'][i % 4];
                            const clothType = i % 4;
                            const clothY = y + 3.5;

                            if (clothType === 0) { // Camisa
                                drawRect(hangerX - 1.2, clothY, 2.6, 2, clothColor);
                            } else if (clothType === 1) { // Cal√ßa
                                drawRect(hangerX - 1, clothY, 2.2, 3, clothColor);
                            } else if (clothType === 2) { // Vestido
                                drawRect(hangerX - 1.5, clothY, 3.2, 3.5, clothColor);
                            } else { // Jaqueta
                                drawRect(hangerX - 1.8, clothY, 3.8, 2.5, clothColor);
                            }
                        }
                    }

                    // Detalhes dos suportes com rebites
                    drawCircle(cx - rackWidth/2 + 1.5, y + 1, 0.5, '#silver');
                    drawCircle(cx - rackWidth/2 + 1.5, y + 4, 0.5, '#silver');
                    drawCircle(cx + rackWidth/2 - 1.5, y + 1, 0.5, '#silver');
                    drawCircle(cx + rackWidth/2 - 1.5, y + 4, 0.5, '#silver');

                    // Etiquetas de organiza√ß√£o
                    drawRect(cx - 3, y - 2, 6, 1.5, '#fff');
                    drawText('S | M | L', cx - 2.5, y - 0.8, 0.8, '#000');

                    // Indicador visual de interatividade
                    const blinkHangers = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx, y + 2, 0.8, `rgba(192, 192, 192, ${blinkHangers})`);
                    break;

                case 'info_kiosk': // Quiosque de Informa√ß√µes Interativo
                    // Base s√≥lida
                    drawRect(left, y + 12, s.w, 4, '#424242');
                    drawRect(left + 1, y + 13, s.w - 2, 2, '#616161');

                    // Estrutura principal (coluna central)
                    drawRect(cx - 2, y, 4, 14, '#e0e0e0');
                    drawRect(cx - 1.5, y + 1, 3, 12, '#f5f5f5');

                    // Tela touchscreen grande
                    drawRect(cx - 8, y + 2, 16, 10, '#000'); // Moldura preta
                    drawRect(cx - 7.5, y + 2.5, 15, 9, '#001122'); // Tela azul escura

                    // Interface na tela
                    // Cabe√ßalho
                    drawRect(cx - 7, y + 3, 14, 1.5, '#1976d2');
                    drawText('INFORMA√á√ïES', cx - 6.5, y + 4, 0.8, '#fff');

                    // Bot√µes na tela
                    const buttons = [
                        { label: 'MAPA', y: y + 6, color: '#4caf50' },
                        { label: 'HOR√ÅRIOS', y: y + 8, color: '#ff9800' },
                        { label: 'SERVI√áOS', y: y + 10, color: '#2196f3' }
                    ];

                    buttons.forEach((btn, i) => {
                        drawRect(cx - 6, btn.y, 12, 1.5, btn.color);
                        drawText(btn.label, cx - 5.5, btn.y + 1, 0.8, '#fff');
                    });

                    // Teclado num√©rico lateral
                    drawRect(cx + 10, y + 4, 4, 8, '#424242');
                    drawRect(cx + 10.5, y + 4.5, 3, 7, '#212121');

                    // Bot√µes do teclado (3x4)
                    for(let row = 0; row < 4; row++) {
                        for(let col = 0; col < 3; col++) {
                            const keyX = cx + 11 + col * 0.9;
                            const keyY = y + 5.5 + row * 1.5;
                            drawRect(keyX, keyY, 0.8, 1, '#666');
                            drawRect(keyX + 0.1, keyY + 0.1, 0.6, 0.8, '#999');
                        }
                    }

                    // Luzes indicadoras
                    drawCircle(cx + 12.5, y + 2, 0.4, '#00ff00'); // Verde - operacional
                    drawCircle(cx + 12.5, y + 3, 0.4, '#2196f3'); // Azul - wifi
                    drawCircle(cx + 12.5, y + 4, 0.4, '#ff5722'); // Vermelho - alerta

                    // Alto-falante
                    drawRect(cx - 10, y + 8, 2, 4, '#212121');
                    drawRect(cx - 9.5, y + 8.5, 1, 3, '#666');
                    // Grade do alto-falante
                    for(let i = 0; i < 6; i++) {
                        drawRect(cx - 9.3, y + 9 + i * 0.3, 0.6, 0.1, '#000');
                    }

                    // Suporte inferior
                    drawRect(cx - 4, y + 16, 8, 2, '#666');
                    drawRect(cx - 3.5, y + 17, 7, 1, '#999');

                    // Logotipo/identifica√ß√£o
                    drawRect(cx - 3, y - 2, 6, 1.5, '#1976d2');
                    drawText('INFO POINT', cx - 2.5, y - 0.8, 0.7, '#fff');

                    // Cabo de energia
                    drawLine(cx + 4, y + 16, cx + 8, y + 20, 0.5, '#000');

                    // Indicador visual de interatividade
                    const blinkInfo = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx, y + 2, 0.8, `rgba(25, 118, 210, ${blinkInfo})`);
                    break;

                case 'classical_statue':
                    // Est√°tua cl√°ssica grega/romana
                    // Base quadrada
                    drawRect(cx - 6, y + s.h - 4, 12, 4, '#8d6e63');
                    // Coluna do corpo
                    drawRect(cx - 3, y + 8, 6, s.h - 12, '#f5f5dc');
                    // Cabe√ßa oval
                    drawEllipse(cx, y + 4, 3, 4, '#f5f5dc');
                    // Bra√ßos estendidos
                    drawRect(cx - 8, y + 10, 5, 2, '#f5f5dc');
                    drawRect(cx + 3, y + 10, 5, 2, '#f5f5dc');
                    // Detalhes da t√∫nica
                    drawLine(cx - 3, y + 8, cx + 3, y + 8, 1, '#e0e0e0');
                    drawLine(cx - 3, y + 12, cx + 3, y + 12, 1, '#e0e0e0');
                    // Olhos simples
                    drawCircle(cx - 1, y + 3, 0.5, '#000');
                    drawCircle(cx + 1, y + 3, 0.5, '#000');
                    break;

                case 'ancient_painting':
                    // Quadro antigo com moldura dourada
                    // Moldura externa
                    drawRect(cx - s.w/2, y, s.w, s.h, '#daa520');
                    // Moldura interna (fundo do quadro)
                    drawRect(cx - s.w/2 + 2, y + 2, s.w - 4, s.h - 4, '#8b4513');
                    // Cena simples (paisagem antiga)
                    drawRect(cx - s.w/2 + 3, y + 3, s.w - 6, s.h - 6, '#87ceeb'); // C√©u
                    drawRect(cx - s.w/2 + 3, y + s.h - 8, s.w - 6, 5, '#228b22'); // Grama
                    drawTriangle(cx - 6, y + s.h - 8, cx, y + 6, cx + 6, y + s.h - 8, '#654321'); // Montanha
                    drawCircle(cx - 3, y + 5, 2, '#ffd700'); // Sol
                    break;

                case 'artifact_display':
                    // Vitrine de vidro com artefatos
                    // Estrutura de metal
                    drawRect(cx - s.w/2, y, s.w, 3, '#424242');
                    drawRect(cx - s.w/2, y + s.h - 3, s.w, 3, '#424242');
                    drawRect(cx - s.w/2, y, 3, s.h, '#424242');
                    drawRect(cx + s.w/2 - 3, y, 3, s.h, '#424242');
                    // Vidro (transparente com bordas)
                    drawRect(cx - s.w/2 + 3, y + 3, s.w - 6, s.h - 6, 'rgba(135, 206, 235, 0.3)');
                    drawRect(cx - s.w/2 + 3, y + 3, s.w - 6, 1, '#87ceeb');
                    drawRect(cx - s.w/2 + 3, y + s.h - 4, s.w - 6, 1, '#87ceeb');
                    // Artefatos dentro (mudam baseado no modo)
                    switch (artifactDisplayMode) {
                        case 0: // Modo padr√£o
                            drawCircle(cx - 4, y + 8, 1.5, '#daa520'); // Moeda antiga
                            drawRect(cx, y + 6, 3, 2, '#8b4513'); // Pequena estatueta
                            drawCircle(cx + 4, y + 10, 1, '#c0c0c0'); // J√≥ia
                            break;
                        case 1: // Cole√ß√£o de moedas
                            for (let i = 0; i < 6; i++) {
                                const coinX = cx - 6 + (i % 3) * 4;
                                const coinY = y + 6 + Math.floor(i / 3) * 3;
                                drawCircle(coinX, coinY, 1, '#daa520');
                            }
                            break;
                        case 2: // Ferramentas antigas
                            drawRect(cx - 5, y + 6, 2, 4, '#696969'); // Martelo
                            drawRect(cx - 1, y + 8, 4, 1, '#8b4513'); // Cabo
                            drawCircle(cx + 3, y + 7, 1.5, '#c0c0c0'); // Anel
                            drawRect(cx + 6, y + 6, 1, 3, '#daa520'); // Chave
                            break;
                        case 3: // Joias e pedras preciosas
                            drawCircle(cx - 4, y + 7, 1.2, '#ff0000'); // Rubi
                            drawCircle(cx - 1, y + 6, 1, '#008000'); // Esmeralda
                            drawCircle(cx + 2, y + 8, 0.8, '#0000ff'); // Safira
                            drawCircle(cx + 5, y + 7, 1.3, '#daa520'); // Ouro
                            // Brilho das joias
                            drawCircle(cx - 4, y + 6, 0.3, 'rgba(255, 255, 255, 0.8)');
                            drawCircle(cx - 1, y + 5, 0.2, 'rgba(255, 255, 255, 0.8)');
                            drawCircle(cx + 2, y + 7, 0.2, 'rgba(255, 255, 255, 0.8)');
                            break;
                    }
                    break;

                case 'marble_bust':
                    // Busto de m√°rmore cl√°ssico
                    // Base circular
                    drawEllipse(cx, y + s.h - 3, 5, 2, '#f5f5f5');
                    // Pesco√ßo
                    drawRect(cx - 2, y + s.h - 8, 4, 5, '#f5f5f5');
                    // Cabe√ßa oval
                    drawEllipse(cx, y + 6, 4, 6, '#f5f5f5');
                    // Cabelos estilizados
                    drawEllipse(cx, y + 2, 4.5, 3, '#2c1810');
                    // Olhos
                    drawEllipse(cx - 1.2, y + 5, 0.8, 0.6, '#000');
                    drawEllipse(cx + 1.2, y + 5, 0.8, 0.6, '#000');
                    // Nariz
                    drawRect(cx - 0.3, y + 4, 0.6, 2, '#f5f5f5');
                    // Boca
                    drawEllipse(cx, y + 8, 1, 0.5, '#c0392b');
                    // Detalhes de m√°rmore (veios)
                    drawLine(cx - 3, y + 3, cx + 2, y + 7, 1, '#e8e8e8');
                    break;

                case 'abstract_sculpture':
                    // Forma abstrata 1: Escultura com formas geom√©tricas irregulares
                    // Base triangular
                    drawTriangle(cx - 6, y + s.h - 3, cx, y + s.h - 8, cx + 6, y + s.h - 3, s.col);
                    // Corpo principal com curvas
                    ctx.fillStyle = s.col;
                    ctx.beginPath();
                    ctx.moveTo(cx - 4, y + s.h - 8);
                    ctx.quadraticCurveTo(cx, y + 6, cx + 4, y + s.h - 8);
                    ctx.quadraticCurveTo(cx + 6, y + 12, cx, y + 18);
                    ctx.quadraticCurveTo(cx - 6, y + 12, cx - 4, y + s.h - 8);
                    ctx.fill();
                    // Elementos flutuantes (com anima√ß√£o quando ativa)
                    if (abstractSculptureActive) {
                        const float1 = Math.sin(abstractSculptureAnimation * Math.PI * 2) * 2;
                        const float2 = Math.sin(abstractSculptureAnimation * Math.PI * 3 + Math.PI/2) * 1.5;
                        const float3 = Math.sin(abstractSculptureAnimation * Math.PI * 4 + Math.PI) * 1;

                        drawEllipse(cx - 3 + float1, y + 8 + float1, 2, 3, '#ff5722');
                        drawRect(cx + 2 + float2, y + 10 + float2, 3, 2, '#2196f3');
                        drawCircle(cx + float3, y + 4 + float3, 1.5, '#4caf50');

                        // Linhas de tens√£o animadas
                        const tension1 = Math.sin(abstractSculptureAnimation * Math.PI * 2) * 1;
                        const tension2 = Math.sin(abstractSculptureAnimation * Math.PI * 2 + Math.PI) * 1;
                        drawLine(cx - 4 + tension1, y + 10 + tension1, cx + 4 + tension2, y + 14 + tension2, 2, '#fff');
                        drawLine(cx + 2 + tension2, y + 6 + tension2, cx - 2 + tension1, y + 12 + tension1, 2, '#fff');

                        // Part√≠culas flutuantes adicionais
                        for (let i = 0; i < 5; i++) {
                            const particleX = cx + Math.sin(abstractSculptureAnimation * Math.PI * (i+1) + i) * 6;
                            const particleY = y + 6 + Math.cos(abstractSculptureAnimation * Math.PI * (i+1) + i) * 4;
                            const particleSize = 0.5 + Math.sin(abstractSculptureAnimation * Math.PI * 2 + i) * 0.3;
                            drawCircle(particleX, particleY, particleSize, `hsl(${i * 60}, 70%, 60%)`);
                        }
                    } else {
                        // Estado normal (parado)
                        drawEllipse(cx - 3, y + 8, 2, 3, '#ff5722');
                        drawRect(cx + 2, y + 10, 3, 2, '#2196f3');
                        drawCircle(cx, y + 4, 1.5, '#4caf50');
                        // Linhas de tens√£o est√°ticas
                        drawLine(cx - 4, y + 10, cx + 4, y + 14, 2, '#fff');
                        drawLine(cx + 2, y + 6, cx - 2, y + 12, 2, '#fff');
                    }

                    // Indicador visual de interatividade
                    const blinkSculpture = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx, y - 2, 0.8, `rgba(255, 0, 255, ${blinkSculpture})`);
                    break;
                    break;

                case 'art_installation':
                    // Forma abstrata 2: Instala√ß√£o art√≠stica com elementos suspensos
                    // Estrutura principal (m√≥vel)
                    drawRect(cx - 1, y, 2, s.h, '#424242');
                    // Bra√ßos horizontais
                    drawRect(cx - 8, y + 4, 6, 2, '#666');
                    drawRect(cx + 2, y + 8, 6, 2, '#666');
                    drawRect(cx - 6, y + 12, 4, 2, '#666');
                    drawRect(cx + 4, y + 16, 4, 2, '#666');
                    // Elementos suspensos abstratos
                    drawEllipse(cx - 5, y + 8, 2, 1, '#e91e63'); // Forma oval
                    drawTriangle(cx + 5, y + 10, cx + 7, y + 14, cx + 3, y + 14, '#9c27b0'); // Tri√¢ngulo
                    drawRect(cx - 4, y + 16, 2, 3, '#00bcd4'); // Ret√¢ngulo
                    drawCircle(cx + 6, y + 20, 1.5, '#ff9800'); // C√≠rculo
                    // Cordas de suspens√£o
                    for(let i = 0; i < 4; i++) {
                        drawLine(cx, y + 2 + i*4, cx - 5 + i*3, y + 6 + i*4, 1, '#999');
                    }
                    break;

                case 'decorative_pedestal':
                    // Pedestal decorativo para expor objetos
                    // Base larga
                    drawRect(cx - s.w/2, y + s.h - 3, s.w, 3, '#8d6e63');
                    // Corpo principal
                    drawRect(cx - s.w/2 + 2, y + 4, s.w - 4, s.h - 7, s.col);
                    // Topo decorativo
                    drawRect(cx - s.w/2 + 3, y + 1, s.w - 6, 3, '#a1887f');
                    // Detalhes ornamentais
                    drawCircle(cx - 4, y + 2, 0.8, '#daa520');
                    drawCircle(cx, y + 2, 0.8, '#daa520');
                    drawCircle(cx + 4, y + 2, 0.8, '#daa520');
                    // Acabamento na base
                    drawLine(cx - s.w/2 + 1, y + s.h - 2, cx + s.w/2 - 1, y + s.h - 2, 1, '#654321');
                    break;

                case 'exhibit_light':
                    // Lumin√°ria de exposi√ß√£o direcionada com intera√ß√£o
                    // Base de fixa√ß√£o na parede
                    drawRect(cx - s.w/2, y, s.w, 2, '#424242');
                    // Bra√ßo articulado
                    drawRect(cx - 1, y, 2, 8, '#666');

                    // Lumin√°ria principal (muda de cor quando ligada)
                    const lightColor = exhibitLightOn ? '#ffff88' : '#c0c0c0';
                    drawEllipse(cx, y - 2, 3, 4, lightColor);

                    // Refletor interno (mais brilhante quando ligado)
                    const reflectorColor = exhibitLightOn ? '#ffffff' : '#fff';
                    drawEllipse(cx, y - 2, 2, 2, reflectorColor);

                    // Feixe de luz direcionado (s√≥ aparece quando ligado)
                    if (exhibitLightOn) {
                        // Anima√ß√£o suave da intensidade da luz
                        const intensity = Math.sin(getGameTime() * 0.008) * 0.1 + 0.9; // Pulsa√ß√£o suave
                        const alpha = 0.4 * intensity;
                        ctx.fillStyle = `rgba(255, 255, 0, ${alpha})`;
                        ctx.beginPath();
                        ctx.moveTo(cx - 1, y + 2);
                        ctx.lineTo(cx + 8, y + 12);
                        ctx.lineTo(cx - 10, y + 12);
                        ctx.closePath();
                        ctx.fill();

                        // Raios de luz adicionais quando ligada
                        for (let i = 0; i < 3; i++) {
                            const rayAngle = (i * Math.PI / 8) + Math.sin(getGameTime() * 0.005 + i) * 0.1;
                            const rayLength = 15 + Math.sin(getGameTime() * 0.01 + i * 2) * 3;
                            const rayX = cx + Math.cos(rayAngle) * rayLength;
                            const rayY = y + 2 + Math.sin(rayAngle) * rayLength;
                            drawLine(cx, y + 2, rayX, rayY, 1, `rgba(255, 255, 255, ${alpha * 0.5})`);
                        }
                    }

                    // Detalhes met√°licos
                    drawCircle(cx, y + 1, 0.8, '#silver');

                    // Indicador visual de interatividade (piscando suavemente)
                    const blinkLight = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx + 3, y + 3, 0.5, `rgba(0, 255, 0, ${blinkLight})`);
                    break;

                case 'medicine_cabinet':
                    // Estrutura de madeira com portas espelhadas
                    drawRoundRect(left, y, s.w, s.h, 2, '#f5f5f5');
                    // Moldura
                    drawRect(left, y, s.w, 2, '#d0d0d0');
                    drawRect(left, y + s.h - 2, s.w, 2, '#d0d0d0');
                    drawRect(left, y, 2, s.h, '#d0d0d0');
                    drawRect(right - 2, y, 2, s.h, '#d0d0d0');
                    // Divis√£o central
                    drawRect(cx - 1, y + 2, 2, s.h - 4, '#e0e0e0');
                    // Espelhos com reflexo sutil
                    drawRect(left + 2, y + 2, (s.w/2) - 3, s.h - 4, 'rgba(255, 255, 255, 0.95)');
                    drawRect(cx + 1, y + 2, (s.w/2) - 3, s.h - 4, 'rgba(255, 255, 255, 0.95)');
                    // Reflexos nos espelhos
                    drawLine(left + 4, y + 4, left + 6, y + 8, 1, 'rgba(0, 191, 255, 0.3)');
                    drawLine(cx + 3, y + 6, cx + 5, y + 10, 1, 'rgba(0, 191, 255, 0.3)');
                    // Puxadores cromados
                    drawRect(cx - 6, y + s.h/2 - 1, 4, 2, '#c0c0c0');
                    drawRect(cx + 2, y + s.h/2 - 1, 4, 2, '#c0c0c0');
                    drawCircle(cx - 4, y + s.h/2, 1, '#silver');
                    drawCircle(cx + 4, y + s.h/2, 1, '#silver');
                    // Conte√∫do vis√≠vel atrav√©s do vidro
                    drawRect(left + 4, y + 6, 3, 4, '#ff5722');
                    drawRect(left + 8, y + 8, 2, 5, '#2196f3');
                    drawCircle(cx + 3, y + 10, 1.5, '#4caf50');
                    drawRect(cx + 6, y + 12, 4, 2, '#ff9800');
                    break;

                case 'laundry_basket':
                    // Cesto de roupa com design moderno
                    drawEllipse(cx, y + s.h/2, s.w/2, s.h/2, s.col);
                    // Abertura oval com refor√ßo
                    drawEllipse(cx, y + 4, (s.w/2) - 2, 3, '#f0f0f0');
                    drawEllipse(cx, y + 4, (s.w/2) - 2, 3, '#e0e0e0');
                    // Al√ßas refor√ßadas
                    drawRect(cx - 8, y + 2, 3, 6, '#d0d0d0');
                    drawRect(cx + 5, y + 2, 3, 6, '#d0d0d0');
                    // Detalhes das al√ßas
                    drawRect(cx - 7, y + 1, 1, 8, '#c0c0c0');
                    drawRect(cx + 6, y + 1, 1, 8, '#c0c0c0');
                    // Roupa vis√≠vel transbordando
                    drawRect(cx - 4, y + 8, 3, 2, '#fff');
                    drawRect(cx, y + 10, 2, 3, '#ff5722');
                    drawRect(cx + 2, y + 6, 2, 2, '#2196f3');
                    drawRect(cx - 2, y + 12, 4, 2, '#4caf50');
                    // Pregas e dobras
                    drawLine(cx - 6, y + 12, cx + 6, y + 12, 1, '#e0e0e0');
                    drawLine(cx - 5, y + 16, cx + 5, y + 16, 1, '#e0e0e0');
                    // Sombra interna
                    drawEllipse(cx, y + s.h/2 + 2, s.w/2 - 1, s.h/2 - 1, 'rgba(0, 0, 0, 0.1)');
                    break;

                case 'towel_rack':
                    // Estrutura tubular cromada
                    drawRect(cx - s.w/2, y + 2, s.w, 3, '#c0c0c0');
                    // Suportes verticais com detalhes
                    drawRect(cx - s.w/2, y, 3, 8, '#c0c0c0');
                    drawRect(cx + s.w/2 - 3, y, 3, 8, '#c0c0c0');
                    // Parafusos de fixa√ß√£o
                    drawCircle(cx - s.w/2 + 1.5, y + 1, 0.5, '#silver');
                    drawCircle(cx + s.w/2 - 1.5, y + 1, 0.5, '#silver');
                    // Toalhas penduradas com dobras realistas
                    // Toalha 1 (azul) com textura
                    ctx.fillStyle = '#2196f3';
                    ctx.fillRect(sx - 12, sy + 5, 8, 14);
                    for(let i = 0; i < 3; i++) {
                        drawLine(sx - 12, sy + 7 + i*3, sx - 4, sy + 7 + i*3, 1, '#1976d2');
                    }
                    // Toalha 2 (branca) com bordado
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(sx - 4, sy + 5, 8, 14);
                    drawRect(sx - 3, sy + 6, 6, 12, '#f0f0f0');
                    drawLine(sx - 3, sy + 9, sx + 3, sy + 9, 1, '#e0e0e0');
                    drawLine(sx - 3, sy + 13, sx + 3, sy + 13, 1, '#e0e0e0');
                    // Toalha 3 (rosa) com padr√£o
                    ctx.fillStyle = '#e91e63';
                    ctx.fillRect(sx + 4, sy + 5, 8, 14);
                    for(let i = 0; i < 4; i++) {
                        for(let j = 0; j < 2; j++) {
                            drawCircle(sx + 6 + i*1.5, sy + 7 + j*4, 0.3, '#c2185b');
                        }
                    }
                    // Bordas das toalhas com detalhes
                    drawRect(cx - 10, y + 5, 8, 14, '#1976d2');
                    drawRect(cx - 2, y + 5, 8, 14, '#f0f0f0');
                    drawRect(cx + 6, y + 5, 8, 14, '#c2185b');
                    // Gotas d'√°gua nas toalhas
                    drawCircle(cx - 8, y + 8, 0.5, 'rgba(0, 191, 255, 0.6)');
                    drawCircle(cx, y + 10, 0.5, 'rgba(0, 191, 255, 0.6)');
                    drawCircle(cx + 8, y + 12, 0.5, 'rgba(0, 191, 255, 0.6)');
                    break;

                case 'trash_can':
                    drawRect(left + 2, y + 4, s.w - 4, s.h - 4, s.col);
                    drawRoundRect(left, y, s.w, 4, 2, '#616161');
                    drawRect(cx - 2, y + s.h - 2, 4, 2, '#212121');
                    break;

                case 'microwave':
                    drawRoundRect(left, y, s.w, s.h, 2, '#eee');

                    if (microwaveActive) {
                        // Interior iluminado
                        drawRect(left + 2, y + 2, s.w - 6, s.h - 4, '#ffff88');

                        // Prato girat√≥rio
                        const plateAngle = time / 200;
                        ctx.strokeStyle = '#666';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(cx - 4, y + s.h - 6, 6, 0, Math.PI * 2);
                        ctx.stroke();

                        // Marca√ß√µes no prato
                        for(let i=0; i<6; i++) {
                            const markAngle = plateAngle + (i * Math.PI / 3);
                            const markX = cx - 4 + Math.cos(markAngle) * 5;
                            const markY = y + s.h - 6 + Math.sin(markAngle) * 5;
                            drawCircle(markX, markY, 0.5, '#999');
                        }

                        // Onda de microondas (linhas onduladas)
                        for(let wave=0; wave<3; wave++) {
                            ctx.strokeStyle = `rgba(255, 100, 100, ${0.5 - wave * 0.1})`;
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(cx - 8, y + 8 + wave * 4);
                            for(let x=0; x<16; x+=2) {
                                const waveY = Math.sin((time / 50) + x + wave * 2) * 2;
                                ctx.lineTo(cx - 8 + x, y + 8 + wave * 4 + waveY);
                            }
                            ctx.stroke();
                        }

                        // LED verde piscando mais r√°pido
                        const ledBlink = Math.floor(time / 200) % 2;
                        drawRect(right - 3, y + 4, 1, 2, ledBlink ? 'lime' : '#666');

                        // Luz de aquecimento
                        drawCircle(cx, y + 4, 2, `rgba(255, 150, 50, ${Math.sin(time / 100) * 0.3 + 0.7})`);
                    } else {
                        // Estado inativo
                    drawRect(left + 2, y + 2, s.w - 6, s.h - 4, '#212121'); 
                    drawRect(right - 4, y + 2, 3, s.h - 4, '#ccc'); 
                    drawRect(right - 3, y + 4, 1, 2, 'lime'); 
                    }

                    // Indicador visual de interatividade
                    const blinkMicro = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx + 6, y + 4, 0.8, `rgba(150, 255, 150, ${blinkMicro})`);
                    break;

                case 'vending':
                    drawRect(left, y, s.w, s.h, '#b71c1c'); 
                    drawRect(left + 4, y + 4, s.w - 8, s.h - 20, '#212121'); 

                    if (vendingActive) {
                        // Snacks animados caindo
                        for(let i=0; i<9; i++) {
                            const snackX = left + 6 + (i % 3) * 8;
                            const snackY = y + 8 + Math.floor(i / 3) * 10;
                            const snackType = i % 3;

                            if(snackType === 0) {
                                // Chocolate bar
                                drawRect(snackX, snackY, 4, 2, '#8b4513');
                                drawRect(snackX, snackY + 1, 4, 1, '#daa520');
                            } else if(snackType === 1) {
                                // Chips bag
                                drawRect(snackX, snackY, 3, 3, '#ffff99');
                                drawLine(snackX + 1, snackY + 1, snackX + 2, snackY + 2, 1, '#ff6b35');
                            } else {
                                // Candy
                                drawCircle(snackX + 2, snackY + 1, 1.5, '#ff69b4');
                                drawCircle(snackX + 1, snackY + 2, 1, '#ffff00');
                            }
                        }

                        // Item caindo
                        const dropProgress = (time / 500) % 1;
                        const dropY = y + s.h - 16 + dropProgress * 12;
                        if(dropY < y + s.h - 4) {
                            drawRect(cx - 1, dropY, 2, 3, '#ff6b35');
                            drawRect(cx - 1, dropY + 1, 2, 1, '#daa520');
                        }

                        // Luz de "DISPENSING"
                        const dispensingLight = Math.floor(time / 200) % 2;
                        drawRect(right - 6, y + s.h/2, 2, 6, dispensingLight ? '#00ff00' : '#666');
                    } else {
                        // Snacks est√°ticos
                    for(let i=0; i<3; i++) {
                        for(let j=0; j<3; j++) {
                            ctx.fillStyle = (i+j)%2===0 ? 'orange' : 'cyan';
                            ctx.fillRect(sx + 6 + (j*8), sy + 8 + (i*10), 4, 4);
                        }
                    }
                    drawRect(right - 6, y + s.h/2, 2, 6, '#000'); 
                    }

                    drawRect(left + 4, y + s.h - 12, s.w - 8, 8, '#333'); 

                    // Indicador visual de interatividade
                    const blinkVending = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx, y + 6, 0.8, `rgba(255, 165, 0, ${blinkVending})`);
                    break;

                case 'tool_cabinet':
                    drawRect(left, y, s.w, s.h, s.col);
                    for(let i=0; i<6; i++) {
                        const gy = y + 2 + (i * 5);
                        drawRect(left + 2, gy, s.w - 4, 4, '#b71c1c');
                        drawRect(left + 2, gy, s.w - 4, 1, 'rgba(0,0,0,0.2)'); 
                        drawRect(cx - 4, gy + 1, 8, 2, '#cfd8dc'); 
                    }
                    drawCircle(left + 4, y + s.h, 2, '#000');
                    drawCircle(right - 4, y + s.h, 2, '#000');
                    break;

                case 'treadmill':
                    if (treadmillActive) {
                        // Esteira em movimento
                        const beltSpeed = time / 20;

                        // Faixas da esteira se movendo
                        for(let i = 0; i < 8; i++) {
                            const stripeX = left + 4 + ((beltSpeed + i * 20) % 40);
                            if(stripeX < right - 8) {
                                drawRect(stripeX, floorY - 2, 3, 2, '#666');
                            }
                        }

                        // Pessoa correndo (silhueta simples)
                        const runnerX = cx + Math.sin(time / 300) * 8;
                        const runnerPhase = Math.floor(time / 200) % 4;

                        // Corpo da pessoa
                        drawRect(runnerX - 1, y + 8, 2, 6, '#333');
                        // Cabe√ßa
                        drawCircle(runnerX, y + 5, 1.5, '#666');
                        // Bra√ßos (anima√ß√£o de corrida)
                        if(runnerPhase % 2 === 0) {
                            drawRect(runnerX - 3, y + 9, 2, 1, '#333'); // Bra√ßo esquerdo para frente
                            drawRect(runnerX + 1, y + 11, 2, 1, '#333'); // Bra√ßo direito para tr√°s
                        } else {
                            drawRect(runnerX - 3, y + 11, 2, 1, '#333'); // Bra√ßo esquerdo para tr√°s
                            drawRect(runnerX + 1, y + 9, 2, 1, '#333'); // Bra√ßo direito para frente
                        }
                        // Pernas (anima√ß√£o de corrida)
                        if(runnerPhase < 2) {
                            drawRect(runnerX - 1, y + 14, 1, 3, '#333'); // Perna esquerda para frente
                            drawRect(runnerX, y + 16, 1, 2, '#333'); // Perna direita para tr√°s
                        } else {
                            drawRect(runnerX - 1, y + 16, 1, 2, '#333'); // Perna esquerda para tr√°s
                            drawRect(runnerX, y + 14, 1, 3, '#333'); // Perna direita para frente
                        }

                        // Painel de controle com dados
                        drawRect(right - 10, y + 2, 10, 6, '#000');
                        drawRect(right - 9, y + 3, 8, 1, '#00ff00'); // Barra de progresso
                        drawText(Math.floor(time / 100) % 100 + '', right - 6, y + 6, 0.8, '#00ff00'); // Velocidade

                        // Luzes indicadoras
                        const light1 = Math.floor(time / 300) % 2;
                        const light2 = Math.floor(time / 500) % 2;
                        drawCircle(cx - 8, y + 2, 0.8, light1 ? '#ff0000' : '#660000');
                        drawCircle(cx + 8, y + 2, 0.8, light2 ? '#00ff00' : '#006600');
                    } else {
                        // Estado inativo
                    drawRect(left, floorY - 4, s.w, 4, '#212121'); 
                    drawRect(left + 2, floorY - 4, s.w - 4, 2, '#424242'); 
                    drawRect(right - 4, y, 4, s.h, '#212121'); 
                    drawRect(right - 10, y + 2, 10, 6, '#000'); 
                    drawLine(right - 4, y + 10, left + 10, y + 12, 2, '#212121'); 
                    }

                    // Indicador visual de interatividade
                    const blinkTread = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx, y + 4, 0.8, `rgba(255, 100, 100, ${blinkTread})`);
                    break;

                case 'mesinha':
                case 'coffee_table':
                    drawRect(left, y, s.w, 4, s.col);
                    drawRect(left + 2, y + 4, 2, s.h - 4, s.col);
                    drawRect(right - 4, y + 4, 2, s.h - 4, s.col);
                    drawRect(left + 2, y, s.w - 4, 1, 'rgba(255,255,255,0.3)');
                    break;

                case 'meeting_table':
                    drawRoundRect(left, y, s.w, 4, 2, s.col);
                    drawRect(cx - 10, y + 4, 20, s.h - 4, '#424242');
                    drawRect(cx - 15, y + s.h - 2, 30, 2, '#424242');
                    break;

                case 'microscope':
                    // Microsc√≥pio detalhado e realista
                    const microscopeTime = time;

                    // Base principal (cinza met√°lico)
                    drawRoundRect(left, y + 12, s.w, s.h - 12, 1, '#9e9e9e');

                    // Bra√ßo vertical (alum√≠nio)
                    drawRect(left + 4, y + 2, 6, 10, '#e0e0e0');
                    drawRect(left + 5, y + 3, 4, 8, '#f5f5f5');

                    // Bra√ßo horizontal superior
                    drawRect(left + 2, y + 8, 10, 3, '#e0e0e0');
                    drawRect(left + 3, y + 9, 8, 1, '#f5f5f5');

                    // Corpo principal (preto com detalhes)
                    drawRoundRect(left + 2, y + 4, 10, 8, 1, '#2c2c2c');

                    // Ocular (cilindro superior)
                    drawRect(left + 5, y, 4, 4, '#1a1a1a');
                    drawRect(left + 6, y + 1, 2, 2, '#000');

                    // Objetiva (cilindro inferior)
                    drawRect(left + 6, y + 12, 2, 4, '#333');
                    drawRect(left + 7, y + 13, 0, 2, '#000'); // Centro da objetiva

                    // Bra√ßo de foco (detalhes met√°licos)
                    drawRect(left + 1, y + 6, 1, 6, '#666');
                    drawRect(left + 12, y + 6, 1, 6, '#666');

                    // LED indicador (verde quando ligado, vermelho quando desligado)
                    const ledColor = microscopeOn ? '#4CAF50' : '#f44336'; // Verde = ligado, vermelho = desligado
                    drawCircle(left + 11, y + 15, 1.5, ledColor);

                    // Brilho do LED
                    ctx.shadowColor = ledColor;
                    ctx.shadowBlur = 3;
                    drawCircle(left + 11, y + 15, 0.8, ledColor);
                    ctx.shadowBlur = 0;

                    // Base inferior (mais larga)
                    drawRect(left - 1, y + 16, s.w + 2, 2, '#666');

                    // Pernas da base
                    drawRect(left, y + 18, 1, 2, '#999');
                    drawRect(left + 13, y + 18, 1, 2, '#999');

                    break;

                case 'computer': // Workstation Detalhada
                    // Monitor principal (ret√¢ngulo principal)
                    drawRect(left + 2, y, s.w - 4, s.h - 4, '#2c2c2c'); // Gabinete escuro
                    drawRect(left + 4, y + 2, s.w - 8, s.h - 6, '#000'); // Tela preta
                    drawRect(left + 6, y + 4, s.w - 12, s.h - 8, '#1a1a1a'); // Tela interna

                    // Conte√∫do da tela (simula√ß√£o de interface)
                    const monitorW = s.w - 12;
                    const monitorH = s.h - 8;

                    // Barra superior (janela)
                    drawRect(left + 6, y + 4, monitorW, 3, '#424242');
                    // Pontos de controle da janela (vermelho, amarelo, verde)
                    drawCircle(left + 8, y + 5.5, 0.8, '#f44336'); // Fechar
                    drawCircle(left + 11, y + 5.5, 0.8, '#ff9800'); // Minimizar
                    drawCircle(left + 14, y + 5.5, 0.8, '#4CAF50'); // Maximizar

                    // Conte√∫do da tela (linhas de c√≥digo/tabela)
                    for(let i = 0; i < 6; i++) {
                        const lineY = y + 10 + i * 2;
                        const lineLength = monitorW - 4 - (pseudoRandom(seed + i) * 6);
                        drawRect(left + 8, lineY, lineLength, 1, `rgba(0, 255, 0, ${0.6 + pseudoRandom(seed + i) * 0.4})`);
                    }

                    // Barra de tarefas inferior
                    drawRect(left + 6, y + s.h - 6, monitorW, 2, '#424242');

                    // √çcones na barra de tarefas
                    for(let i = 0; i < 4; i++) {
                        drawRect(left + 8 + i * 4, y + s.h - 5, 3, 1, '#fff');
                    }

                    // Teclado (abaixo do monitor)
                    const keyboardY = y + s.h;
                    drawRect(cx - 8, keyboardY, 16, 3, '#333'); // Corpo do teclado
                    drawRect(cx - 7, keyboardY + 1, 14, 1, '#666'); // Fileira de teclas

                    // Mouse (pr√≥ximo ao teclado)
                    drawRect(cx + 10, keyboardY, 3, 2, '#666'); // Corpo do mouse
                    drawRect(cx + 10.5, keyboardY + 0.5, 0.5, 1, '#000'); // Roda do scroll
                    drawLine(cx + 11, keyboardY + 1.5, cx + 12, keyboardY + 2, 1, '#000'); // Cabo

                    // Gabinete da CPU (ao lado)
                    drawRect(right - 6, y + 8, 6, 8, '#2c2c2c'); // Gabinete
                    drawRect(right - 5, y + 9, 4, 6, '#1a1a1a'); // Interior

                    // LED de energia no gabinete
                    const powerLed = Math.sin(time / 500) > 0 ? '#00ff00' : '#004400';
                    drawCircle(right - 4, y + 10, 0.5, powerLed);

                    // LEDs de atividade (HD/CPU)
                    const hdLed = Math.sin(time / 300) > 0 ? '#0000ff' : '#000044';
                    drawCircle(right - 4, y + 12, 0.5, hdLed);

                    // Ventoinhas (linhas indicando movimento)
                    for(let i = 0; i < 3; i++) {
                        const fanAngle = time / 200 + i * Math.PI * 2 / 3;
                        const fanX = right - 4 + Math.cos(fanAngle) * 0.5;
                        const fanY = y + 14 + Math.sin(fanAngle) * 0.5;
                        drawCircle(fanX, fanY, 0.2, '#666');
                    }

                    // Cabo de energia
                    drawLine(cx - 4, keyboardY + 3, cx - 4, keyboardY + 6, 1, '#000');

                    // Indicador visual de interatividade (LED pulsante)
                    const blinkComputer = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx, y + 2, 0.8, `rgba(0, 255, 0, ${blinkComputer})`);
                    break;

                case 'waiting_bench': // Banco de Espera Detalhado
                    // Estrutura principal de madeira
                    drawRect(left, y + 8, s.w, 4, '#8d6e63'); // Assento
                    drawRect(left + 2, y + 10, s.w - 4, 2, '#a1887f'); // Espessura do assento

                    // Encosto
                    drawRect(left + 2, y, s.w - 4, 6, '#8d6e63');
                    drawRect(left + 4, y + 2, s.w - 8, 2, '#a1887f');

                    // Pernas/suportes
                    drawRect(left + 4, y + 12, 2, 4, '#5d4037'); // Perna esquerda frente
                    drawRect(right - 6, y + 12, 2, 4, '#5d4037'); // Perna direita frente
                    drawRect(left + 4, y + 8, 2, 8, '#5d4037'); // Perna esquerda tr√°s
                    drawRect(right - 6, y + 8, 2, 8, '#5d4037'); // Perna direita tr√°s

                    // Bra√ßos laterais
                    drawRect(left, y + 4, 2, 4, '#8d6e63'); // Bra√ßo esquerdo
                    drawRect(right - 2, y + 4, 2, 4, '#8d6e63'); // Bra√ßo direito

                    // Detalhes de carpintaria
                    drawRect(left + 6, y + 9, s.w - 12, 1, '#795548'); // Junta do assento
                    drawRect(left + 6, y + 1, s.w - 12, 1, '#795548'); // Junta do encosto

                    // Sombras
                    drawRect(left + 2, y + 16, s.w - 4, 1, 'rgba(0,0,0,0.3)');
                    break;

                case 'coffee_machine': // M√°quina de Caf√© Expresso Detalhada
                    // Corpo principal met√°lico
                    drawRoundRect(left, y, s.w, s.h, 2, '#c0c0c0');
                    drawRoundRect(left + 1, y + 1, s.w - 2, s.h - 2, 1, '#e0e0e0');

                    // Painel de controle
                    drawRect(left + 4, y + 4, 8, 6, '#2c2c2c');
                    drawRect(left + 5, y + 5, 6, 4, '#000');

                    // Bot√µes e indicadores
                    drawCircle(left + 6, y + 7, 0.8, '#ff5722'); // Bot√£o de power
                    drawCircle(left + 9, y + 7, 0.8, '#4caf50'); // Bot√£o de start

                    // LED de status
                    const coffeeLed = Math.sin(time / 800) > 0 ? '#00ff00' : '#004400';
                    drawCircle(left + 7.5, y + 6, 0.5, coffeeLed);

                    // Porta do reservat√≥rio de √°gua
                    drawRect(left + 14, y + 6, 4, 8, '#1976d2');
                    drawRect(left + 15, y + 7, 2, 6, '#42a5f5');
                    drawCircle(left + 16, y + 9, 0.3, '#fff'); // Indicador de n√≠vel

                    // Bandeja de gotejamento
                    drawRect(left + 2, y + 12, s.w - 4, 2, '#424242');
                    drawRect(left + 3, y + 13, s.w - 6, 0.5, '#666');

                    // Suporte para x√≠caras
                    drawRect(cx - 4, y + 14, 8, 1, '#8d6e63');
                    drawRect(cx - 3, y + 15, 6, 0.5, '#a1887f');

                    // Vaporizador (cano de vapor)
                    drawRect(cx + 6, y + 2, 1, 8, '#666');
                    drawCircle(cx + 6.5, y + 1, 1, '#c0c0c0'); // Ponta do vaporizador

                    // Etiqueta de modelo
                    drawRect(left + 6, y + 11, 6, 1, '#fff');
                    drawText('ESPRESSO', left + 7, y + 12, 0.6, '#000');

                    // Indicador visual de interatividade
                    const blinkCoffee = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx, y + 2, 0.8, `rgba(255, 193, 7, ${blinkCoffee})`);
                    break;

                case 'desk_lamp': // Lumin√°ria de Mesa Detalhada
                    // Base circular pesada
                    drawCircle(cx, y + 12, 3, '#424242');
                    drawCircle(cx, y + 12, 2.5, '#616161');

                    // Haste vertical
                    drawRect(cx - 0.5, y + 4, 1, 8, '#c0c0c0');
                    drawRect(cx - 0.3, y + 5, 0.6, 6, '#e0e0e0');

                    // Bra√ßo articulado
                    drawRoundRect(cx - 6, y + 2, 8, 2, 1, '#c0c0c0');
                    drawRoundRect(cx - 5, y + 3, 6, 0.5, 0.5, '#e0e0e0');

                    // Abra√ßadeira de ajuste
                    drawCircle(cx - 6, y + 3, 0.8, '#666');
                    drawCircle(cx - 6, y + 3, 0.3, '#c0c0c0');

                    // C√∫pula do abajur (difusor)
                    ctx.fillStyle = '#fff8e1';
                    ctx.beginPath();
                    ctx.ellipse(scx, sy, 4, 3, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Moldura do abajur
                    ctx.strokeStyle = '#c0c0c0';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.ellipse(scx, sy, 4, 3, 0, 0, Math.PI * 2);
                    ctx.stroke();

                    // Interruptor na base
                    drawRect(cx - 1, y + 14, 2, 0.5, '#666');
                    drawCircle(cx, y + 14.5, 0.3, '#ff5722'); // Interruptor vermelho

                    // Cabo el√©trico
                    drawLine(cx + 2, y + 12, cx + 6, y + 16, 0.5, '#000');
                    drawLine(cx + 6, y + 16, cx + 10, y + 16, 0.5, '#000');

                    // Brilho da l√¢mpada (efeito de luz) - s√≥ quando ligada
                    if (deskLampOn) {
                        ctx.fillStyle = 'rgba(255, 255, 0, 0.4)';
                        ctx.beginPath();
                        ctx.ellipse(scx, sy, 6, 5, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Filamento vis√≠vel quando ligado
                        drawCircle(cx, y + 1, 0.3, '#ffff88');
                    }

                    // Interruptor muda de cor baseado no estado
                    let deskSwitchColor = deskLampOn ? '#4caf50' : '#ff5722';
                    drawCircle(cx, y + 14.5, 0.3, deskSwitchColor);

                    // Indicador visual de interatividade
                    const blinkLamp = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx, y, 0.8, `rgba(255, 255, 0, ${blinkLamp})`);
                    break;

                case 'printer': // Impressora LaserJet Detalhada
                    // Corpo principal da impressora
                    drawRoundRect(left, y + 4, s.w, 8, 1, '#e0e0e0');
                    drawRoundRect(left + 1, y + 5, s.w - 2, 6, 0.5, '#f5f5f5');

                    // Painel de controle LCD
                    drawRect(left + 4, y, 8, 3, '#000');
                    drawRect(left + 5, y + 0.5, 6, 2, '#1a1a1a');

                    // Tela LCD (linhas de texto simuladas)
                    drawRect(left + 5.5, y + 1, 5, 0.3, '#00ff00');
                    drawRect(left + 5.5, y + 1.8, 3, 0.3, '#00ff00');

                    // Bot√µes de controle
                    drawCircle(left + 7, y + 3.5, 0.6, '#666'); // Online
                    drawCircle(left + 9, y + 3.5, 0.6, '#ff5722'); // Cancel

                    // LED de status
                    const printerLed = Math.sin(time / 600) > 0 ? '#00ff00' : '#004400';
                    drawCircle(left + 6, y + 3.5, 0.4, printerLed);

                    // Bandeja de entrada (cima)
                    drawRect(left + 2, y + 2, s.w - 4, 1, '#c0c0c0');
                    drawRect(left + 3, y + 3, s.w - 6, 0.5, '#e0e0e0');

                    // Folhas na bandeja
                    for(let i = 0; i < 3; i++) {
                        drawRect(left + 4 + i * 1.5, y + 2.2, 3, 0.6, '#fff');
                        drawRect(left + 4.2 + i * 1.5, y + 2.4, 2.6, 0.2, '#e0e0e0');
                    }

                    // Bandeja de sa√≠da (baixo)
                    drawRect(left + 2, y + 12, s.w - 4, 2, '#c0c0c0');
                    drawRect(left + 3, y + 13, s.w - 6, 0.5, '#e0e0e0');

                    // Pap√©is impressos na sa√≠da
                    drawRect(left + 4, y + 12.5, 4, 1, '#fff');
                    drawRect(left + 8, y + 12.5, 4, 1, '#fff');
                    drawRect(left + 4.2, y + 12.7, 3.6, 0.6, '#f0f0f0');

                    // Porta USB lateral
                    drawRect(right - 4, y + 7, 2, 0.5, '#666');

                    // Etiqueta de modelo
                    drawRect(left + 6, y + 11, 6, 0.8, '#fff');
                    drawText('LASERJET', left + 7, y + 11.8, 0.5, '#000');

                    // Indicador visual de interatividade
                    const blinkPrinter = Math.sin(getGameTime() * 0.01) > 0 ? 1 : 0.3;
                    drawCircle(cx, y + 2, 0.8, `rgba(0, 150, 255, ${blinkPrinter})`);
                    break;


                default:
                    drawRoundRect(left, y, s.w, s.h, 2, s.col);
            }
        }

        function drawFloor(index) {
            const data = floors.get(index);
            if (!data) return;
            const floorY = -index * FLOOR_HEIGHT;

            // --- PASSADA 1: ESTRUTURAS E FUNDOS (Background Layer) ---
            // Desenha todas as paredes e estruturas fixas primeiro

            // 1.1 Desenhar Paredes dos Setores
            data.sectors.forEach((sector, i) => {
                const info = ROOM_THEMES[sector.theme];
                const w = sector.width;
                const sectorCenterX = sector.startX + w/2;

                // Parede de Fundo
                drawRect(sector.startX, floorY - (FLOOR_HEIGHT-10), w, FLOOR_HEIGHT-10, info.wall);

                // Placas e Identifica√ß√£o
                const signW = 125; // Aumentado 25% (100 * 1.25)
                drawRect(sectorCenterX - signW/2, floorY - 124, signW, 25, '#111'); // Altura aumentada proporcionalmente
                drawRect(sectorCenterX - signW/2 + 2, floorY - 122, signW - 4, 21, info.signColor); // Altura interna ajustada
                drawRect(sectorCenterX - signW/2 + 4, floorY - 120, signW - 8, 17, '#000'); // Altura do fundo ajustada
                drawText(info.label, sectorCenterX, floorY - 107, 18, '#fff');

                // Divis√≥rias entre setores
                if (i > 0) drawRect(sector.startX - 4, floorY - (FLOOR_HEIGHT-10), 8, FLOOR_HEIGHT-10, '#111');
            });

            // 1.2 Desenhar Estruturas Fixas (Elevador/Escada/Piso)
            drawRect(ELEVATOR_X - ELEVATOR_WIDTH/2, floorY - 130, ELEVATOR_WIDTH, 130, '#1c1c1c');
            drawRect(ELEVATOR_X - 20, floorY - 110, 40, 110, '#546e7a');
            drawRect(ELEVATOR_X - 1, floorY - 110, 2, 110, '#000');

            drawRect(STAIRS_X - STAIRS_WIDTH/2, floorY - 130, STAIRS_WIDTH, 130, '#263238');
            for(let i=0; i<8; i++) drawRect(STAIRS_X - 20, floorY - 20 - (i*15), 40, 4, '#78909c');

            // Ch√£o e Teto
            drawRect(-BUILDING_WIDTH/2 - 40, floorY, BUILDING_WIDTH + 80, 10, '#111');
            drawRect(-BUILDING_WIDTH/2, floorY, BUILDING_WIDTH, 8, '#424242');

            // N√∫mero do Andar (Fundo)
            ctx.globalAlpha = 0.2;
            drawText(index.toString(), ELEVATOR_X - 60, floorY - 60, 40, '#fff');
            ctx.globalAlpha = 1.0;

            // --- PASSADA 2: OBJETOS E ITENS (Foreground Layer) ---
            // Desenha todos os itens DEPOIS de todas as paredes estarem prontas
            data.sectors.forEach(sector => {
                sector.items.forEach(item => {
                    drawDetailedItem(item, floorY, sector.seed);
                });
            });

            // --- PASSADA 3: ENTIDADES E UI (J√° tratadas no loop principal ou abaixo) ---

            // Renderizar itens colet√°veis do andar atual (Mantido aqui para z-index correto sobre paredes)
            collectibles.forEach(collectible => {
                if (!collectible.collected && Math.abs(collectible.y - floorY) < FLOOR_HEIGHT) {
                    const floatY = collectible.y + Math.sin(getGameTime() / 500 + collectible.floatOffset) * 5;
                    const screenX = (CW() / 2) + collectible.x - camera.x;
                    const screenY = (CH() / 2) + floatY - camera.y;

                    ctx.font = '20px Arial';
                    ctx.textAlign = 'center';

                    // Brilho
                    ctx.shadowColor = '#ffff00';
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = '#fff'; // Garantir cor
                    ctx.fillText(collectible.type, screenX, screenY);
                    ctx.shadowBlur = 0;
                }
            });

            // Renderizar proj√©teis
            projectiles.forEach(p => {
                const screenX = (CW() / 2) + p.x - camera.x;
                const screenY = (CH() / 2) + p.y - camera.y;
                
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#00e5ff';
                ctx.shadowBlur = 10;
                ctx.fillStyle = '#fff';
                ctx.fillText('‚ùÑÔ∏è', screenX, screenY);
                ctx.shadowBlur = 0;
            });

            // Part√≠culas (Mantido aqui ou no main loop, mas ok aqui para profundidade local)
             particles.forEach(particle => {
                 const alpha = particle.life / particle.maxLife;
                 const colorWithAlpha =
                     particle.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');

                 // IMPORTANTE: drawCircle j√° aplica c√¢mera + centraliza√ß√£o.
                 // Ent√£o aqui passamos coordenadas do MUNDO (world space).
                 drawCircle(particle.x, particle.y, particle.size, colorWithAlpha);
             });

            // Renderizar INIMIGO VERMELHO
            if (enemy.floor === index) {
                const enemySize = PLAYER.w;
                const enemyHeight = PLAYER.h;

                if (gameMode === 'explore') {
                    // SKIN DE PALHA√áO (Modo Explorat√≥rio)
                    // Roupa colorida (listrada)
                    drawRect(enemy.x - enemySize/2, enemy.y - enemyHeight, enemySize, enemyHeight, '#ffffff');
                    drawRect(enemy.x - enemySize/2, enemy.y - enemyHeight + 5, enemySize, 5, '#ff00ff');
                    drawRect(enemy.x - enemySize/2, enemy.y - enemyHeight + 15, enemySize, 5, '#00ffff');
                    drawRect(enemy.x - enemySize/2, enemy.y - enemyHeight + 25, enemySize, 5, '#ffff00');

                    // Rosto branco
                    drawRect(enemy.x - enemySize/2 + 2, enemy.y - enemyHeight + 2, enemySize - 4, 10, '#ffffff');
                    // Nariz vermelho
                    drawCircle(enemy.x, enemy.y - enemyHeight + 7, 2, '#ff0000');
                    // Cabelo colorido (pompons)
                    drawCircle(enemy.x - enemySize/2, enemy.y - enemyHeight + 4, 3, '#ff6600');
                    drawCircle(enemy.x + enemySize/2, enemy.y - enemyHeight + 4, 3, '#ff6600');
                    // Chap√©u de festa
                    drawTriangle(enemy.x - 5, enemy.y - enemyHeight, enemy.x + 5, enemy.y - enemyHeight, enemy.x, enemy.y - enemyHeight - 10, '#00ff00');
                } else if (gameMode === 'game') {
                    // SKIN ORIGINAL (Modo Jogo) - VERMELHO
                    drawRect(enemy.x - enemySize/2, enemy.y - enemyHeight, enemySize, enemyHeight, '#ff0000');
                    drawRect(enemy.x - enemySize/2, enemy.y - enemyHeight, enemySize, 10, '#ffffff');
                    drawCircle(enemy.x, enemy.y - enemyHeight - 5, 2, '#ff0000');
                }

                // Efeitos visuais do Inimigo (Sombra/Pulo)
                if (enemy.isJumping || (enemy.state && enemy.state !== 'idle' && !enemy.isOnGround)) {
                    const shadowOffset = 10;
                    drawRect(enemy.x - enemySize/2, enemy.y - enemyHeight + shadowOffset, enemySize, enemyHeight, `rgba(0, 0, 0, 0.1)`);
                }
            }

            // Renderizar INIMIGO ROXO
            if (purpleEnemy.floor === index) {
                const enemySize = PLAYER.w;
                const enemyHeight = PLAYER.h;

                if (gameMode === 'explore') {
                    // SKIN DE PALHA√áO ROXO (Modo Explorat√≥rio)
                    // Roupa colorida (listrada) em tons roxos
                    drawRect(purpleEnemy.x - enemySize/2, purpleEnemy.y - enemyHeight, enemySize, enemyHeight, '#ffffff');
                    drawRect(purpleEnemy.x - enemySize/2, purpleEnemy.y - enemyHeight + 5, enemySize, 5, '#800080');
                    drawRect(purpleEnemy.x - enemySize/2, purpleEnemy.y - enemyHeight + 15, enemySize, 5, '#9370db');
                    drawRect(purpleEnemy.x - enemySize/2, purpleEnemy.y - enemyHeight + 25, enemySize, 5, '#dda0dd');

                    // Rosto branco
                    drawRect(purpleEnemy.x - enemySize/2 + 2, purpleEnemy.y - enemyHeight + 2, enemySize - 4, 10, '#ffffff');
                    // Nariz roxo
                    drawCircle(purpleEnemy.x, purpleEnemy.y - enemyHeight + 7, 2, '#800080');
                    // Cabelo colorido (pompons) roxos
                    drawCircle(purpleEnemy.x - enemySize/2, purpleEnemy.y - enemyHeight + 4, 3, '#4b0082');
                    drawCircle(purpleEnemy.x + enemySize/2, purpleEnemy.y - enemyHeight + 4, 3, '#4b0082');
                    // Chap√©u de festa roxo
                    drawTriangle(purpleEnemy.x - 5, purpleEnemy.y - enemyHeight, purpleEnemy.x + 5, purpleEnemy.y - enemyHeight, purpleEnemy.x, purpleEnemy.y - enemyHeight - 10, '#800080');
                } else if (gameMode === 'game') {
                    // SKIN ROXA (Modo Jogo)
                    drawRect(purpleEnemy.x - enemySize/2, purpleEnemy.y - enemyHeight, enemySize, enemyHeight, '#800080');
                    drawRect(purpleEnemy.x - enemySize/2, purpleEnemy.y - enemyHeight, enemySize, 10, '#ffffff');
                    drawCircle(purpleEnemy.x, purpleEnemy.y - enemyHeight - 5, 2, '#800080');
                }

                // Efeitos visuais do Inimigo Roxo (Sombra/Pulo)
                if (purpleEnemy.isJumping || (purpleEnemy.state && purpleEnemy.state !== 'idle' && !purpleEnemy.isOnGround)) {
                    const shadowOffset = 10;
                    drawRect(purpleEnemy.x - enemySize/2, purpleEnemy.y - enemyHeight + shadowOffset, enemySize, enemyHeight, `rgba(0, 0, 0, 0.1)`);
                }
            }
        }

        function draw() {
            const skyFactor = Math.min(1, Math.max(0, player.floor / 30));
            const r = Math.floor(20 * (1-skyFactor));
            const g = Math.floor(30 * (1-skyFactor));
            const b = Math.floor(60 * (1-skyFactor));
            ctx.fillStyle = `rgb(${r},${g},${b})`;
            ctx.fillRect(0, 0, CW(), CH());

            const centerIndex = Math.round(-camera.y / FLOOR_HEIGHT);
            for (let i = centerIndex - 3; i <= centerIndex + 3; i++) {
                getOrGenerateFloor(i); 
                drawFloor(i);
            }

            const pX = player.x - PLAYER.w/2;
            const pY = player.y - PLAYER.h;

            // Corpo do jogador
            let bodyColor = PLAYER.col;
            let headColor = PLAYER.head;

            // Efeito de invencibilidade (piscar)
            if (playerInvincible) {
                const blinkRate = 150; // ms por blink
                const blinkPhase = Math.floor(getGameTime() / blinkRate) % 2;
                if (blinkPhase === 0) {
                    bodyColor = 'rgba(255, 255, 255, 0.3)';
                    headColor = 'rgba(255, 255, 255, 0.3)';
                }
            }

            // Efeitos visuais para corrida
            if (player.isRunning) {
                // Corpo mais alongado durante corrida
                drawRect(pX - 2, pY, PLAYER.w + 4, PLAYER.h, PLAYER.col);
                drawRect(pX - 2, pY, PLAYER.w + 4, 10, PLAYER.head);

                // Part√≠culas de poeira
                const dustCount = Math.floor(Math.random() * 3) + 1;
                for (let i = 0; i < dustCount; i++) {
                    const dustX = pX + Math.random() * PLAYER.w;
                    const dustY = pY + PLAYER.h + Math.random() * 5;
                    drawCircle(dustX, dustY, 1 + Math.random() * 2, `rgba(139, 69, 19, ${0.3 + Math.random() * 0.4})`);
                }
            } else {
            drawRect(pX, pY, PLAYER.w, PLAYER.h, PLAYER.col);
            drawRect(pX, pY, PLAYER.w, 10, PLAYER.head);
            }

            // --- Vidas como 3 cora√ß√µes no corpo do player (tipo bot√µes da camisa) ---
            // some sempre o cora√ß√£o mais abaixo (bottom-first)
            const heartsTotal = 3;
            const heartsVisible = Math.max(0, Math.min(heartsTotal, playerLives));
            const heartX = pX + PLAYER.w * 0.5;
            const heartTopY = pY + 18;
            const heartGap = 6;       // dist√¢ncia vertical entre cora√ß√µes
            const heartSize = 4;      // tamanho do cora√ß√£o

            for (let i = 0; i < heartsTotal; i++) {
                // i=0 topo, i=2 baixo. Se playerLives=2 -> mostra topo+meio, some o de baixo.
                const y = heartTopY + i * heartGap;
                if (i < heartsVisible) {
                    drawHeart(heartX, y, heartSize, '#ff2d55', 0.95);
                } else {
                    // opcional: cora√ß√£o vazio discreto (quase invis√≠vel)
                    drawHeart(heartX, y, heartSize, '#44000f', 0.35);
                }
            }

                // Efeitos visuais para pulo
                if (player.isJumping || !player.isOnGround) {
                    // Corpo mais compacto durante pulo
                    drawRect(pX + 2, pY + 2, PLAYER.w - 4, PLAYER.h - 4, PLAYER.col);
                    drawRect(pX + 2, pY + 2, PLAYER.w - 4, 6, PLAYER.head);

                    // Tra√ßo de movimento (sombra)
                    const shadowOffset = Math.min(Math.abs(player.velocityY) * 0.5, 10);
                    drawRect(pX, pY + shadowOffset, PLAYER.w, PLAYER.h, `rgba(0, 0, 0, ${0.2 - shadowOffset * 0.02})`);

                    // Part√≠culas de pulo
                    if (player.velocityY < -5) { // S√≥ durante subida
                        const particleCount = Math.floor(Math.random() * 2) + 1;
                        for (let i = 0; i < particleCount; i++) {
                            const particleX = pX + Math.random() * PLAYER.w;
                            const particleY = pY + PLAYER.h + Math.random() * 3;
                            drawCircle(particleX, particleY, 1, `rgba(255, 255, 255, ${0.6 + Math.random() * 0.4})`);
                        }
                    }
                }

                // Renderizar objeto carregado
                if (player.isCarrying && player.carriedItem) {
                    const carriedX = pX + PLAYER.w / 2;
                    const carriedY = pY - 15; // Acima da cabe√ßa

                    // Desenhar uma representa√ß√£o simplificada do objeto carregado
                    drawRect(carriedX - 8, carriedY - 8, 16, 16, '#8B4513');

                    // Adicionar brilho para indicar que est√° sendo carregado
                    ctx.shadowColor = '#FFD700';
                    ctx.shadowBlur = 5;
                    drawRect(carriedX - 6, carriedY - 6, 12, 12, '#DAA520');
                    ctx.shadowBlur = 0;

                    // Pequeno indicador de carregamento
                    drawCircle(carriedX + 6, carriedY - 6, 2, '#FF0000');
                }
            const eyeOff = (player.state === 'idle' && Math.abs(player.x) > 0) ? (player.x > lastX ? 2 : -2) : 0;
            drawRect(pX + 4 + eyeOff, pY + 4, 2, 2, '#000');
            drawRect(pX + 10 + eyeOff, pY + 4, 2, 2, '#000');
            lastX = player.x;

            let hoveredLabel = null;
            let hoveredX = 0;
            let hoveredY = 0;

            if (Math.abs(player.x - ELEVATOR_X) < ELEVATOR_WIDTH/2) {
                hoveredLabel = "ELEVADOR"; hoveredX = ELEVATOR_X; hoveredY = player.y - 80;
            } else if (Math.abs(player.x - STAIRS_X) < STAIRS_WIDTH/2) {
                hoveredLabel = "ESCADA"; hoveredX = STAIRS_X; hoveredY = player.y - 80;
            } else {
                const currentFloorData = floors.get(player.floor);
                if (currentFloorData) {
                    let minDist = 999;
                    for(let s of currentFloorData.sectors) {
                        for(let item of s.items) {
                            const spec = SPECS[item.type];
                            if (!spec) continue;
                            const dist = Math.abs(player.x - item.x);
                            if (dist < (spec.w/2 + 10) && dist < minDist) {
                                if (item.yOff && dist > 10) continue;
                                hoveredLabel = ITEM_NAMES[item.type] || item.type;
                                hoveredX = item.x;
                                // Altura fixa do tooltip acima do jogador
                                hoveredY = player.y - 80;
                                minDist = dist;
                            }
                        }
                    }
                }
            }

            if (hoveredLabel) {
                const textWidth = hoveredLabel.length * 9; 
                drawRoundRect(hoveredX - textWidth/2 - 11, hoveredY - 16, textWidth + 22, 22, 15, 'rgba(120,120,80,0.85)');
                drawText(hoveredLabel, hoveredX, hoveredY - 0, 18, '#fff');
                ctx.fillStyle = 'rgba(0,0,0,0.85)';
                const sx = (CW() / 2) + hoveredX - camera.x;
                const sy = (CH() / 2) + hoveredY - camera.y + 6;
                ctx.beginPath();
                ctx.moveTo(sx - 4, sy);
                ctx.lineTo(sx + 4, sy);
                ctx.lineTo(sx, sy + 5);
                ctx.fill();
            }
        }

        let lastX = 0;

        
        // Inicializar menu ap√≥s o DOM estar pronto (evita falhas em alguns navegadores/ambientes)
        function boot() {
            try {
                initMainMenu();
            } catch (e) {
                console.error(e);
                // fallback vis√≠vel na tela
                const errBox = document.createElement('div');
                errBox.style.position = 'fixed';
                errBox.style.top = '0';
                errBox.style.left = '0';
                errBox.style.right = '0';
                errBox.style.padding = '12px 16px';
                errBox.style.zIndex = '99999';
                errBox.style.background = 'rgba(0,0,0,0.85)';
                errBox.style.color = '#fff';
                errBox.style.fontFamily = 'monospace';
                errBox.style.fontSize = '12px';
                errBox.textContent = 'Erro ao iniciar o jogo: ' + (e && e.message ? e.message : String(e));
                document.body.appendChild(errBox);
            }
        }

        if (document.readyState === 'loading') {
            window.addEventListener('DOMContentLoaded', boot);
        } else {
            boot();
        }


    
canvas.addEventListener("touchmove", (e) => {
    touchMoved = true;
}, { passive: true });

canvas.addEventListener("touchend", (e) => {
    if (gamePaused || gameEnded) return;

    const endX = e.changedTouches[0].clientX;
    const endY = e.changedTouches[0].clientY;

    const dx = endX - touchStartX;
    const dy = endY - touchStartY;

    const absX = Math.abs(dx);
    const absY = Math.abs(dy);

    const screenW = window.innerWidth;

    /* ---------- SWIPE VERTICAL ---------- */
    if (absY > absX && absY > SWIPE_THRESHOLD) {
        if (dy < 0) {
            // deslizar para cima
            attemptVerticalMove(1);
        } else {
            // deslizar para baixo
            attemptVerticalMove(-1);
        }
        return;
    }

    /* ---------- TOQUE (sem swipe) ---------- */
    const touchXRatio = endX / screenW;

    // borda esquerda
    if (touchXRatio < EDGE_ZONE) {
        keys.left = true;
        setTimeout(() => keys.left = false, 120);
        return;
    }

    // borda direita
    if (touchXRatio > 1 - EDGE_ZONE) {
        keys.right = true;
        setTimeout(() => keys.right = false, 120);
        return;
    }

    // centro da tela ‚Üí pulo
    const centerMin = 0.5 - CENTER_ZONE / 2;
    const centerMax = 0.5 + CENTER_ZONE / 2;

    if (touchXRatio > centerMin && touchXRatio < centerMax) {
        attemptJump();
    }

}, { passive: true });


/* ===============================
   TOUCH CONTROLS (Mobile Buttons + Swipe Andares)
   - Swipe vertical no canvas: sobe/desce andar
   - Bot√µes: esquerda/direita (hold), Carregar/soltar, A√ß√£o, Pular
   =============================== */

(function initTouchControls(){
    // falha segura
    if (typeof canvas === 'undefined') return;

    // ----- Swipe vertical (apenas para mudar andares) -----
    let sX = 0, sY = 0;
    const SWIPE_THRESHOLD = 40;

    canvas.addEventListener("touchstart", (e) => {
        if (gamePaused || gameEnded) return;
        const t = e.touches[0];
        sX = t.clientX;
        sY = t.clientY;
    }, { passive: true });

    canvas.addEventListener("touchend", (e) => {
        if (gamePaused || gameEnded) return;
        const t = e.changedTouches[0];
        const dx = t.clientX - sX;
        const dy = t.clientY - sY;

        const absX = Math.abs(dx);
        const absY = Math.abs(dy);

        if (absY > absX && absY > SWIPE_THRESHOLD) {
            if (dy < 0) attemptVerticalMove(1);   // up
            else        attemptVerticalMove(-1);  // down
        }
    }, { passive: true });

    // ----- Helpers para bot√µes -----
    function bindHold(btn, keyName){
        if (!btn) return;

        const down = (ev) => {
            if (gamePaused || gameEnded) return;
            ev.preventDefault();
            ev.stopPropagation();
            keys[keyName] = true;

            // Primeiro movimento lateral (invencibilidade inicial no modo jogo)
            if (!hasMadeFirstMove && gameMode === 'game' && (keyName === 'left' || keyName === 'right')) {
                const now = getGameTime();
                hasMadeFirstMove = true;
                playerInvincible = true;
                playerInvincibilityStart = now;
                updateProtectionIndicator();
            }
        };

        const up = (ev) => {
            ev.preventDefault?.();
            ev.stopPropagation?.();
            keys[keyName] = false;
        };

        btn.addEventListener("touchstart", down, { passive: false });
        btn.addEventListener("touchend", up, { passive: false });
        btn.addEventListener("touchcancel", up, { passive: false });

        // Desktop fallback
        btn.addEventListener("mousedown", down);
        window.addEventListener("mouseup", up);
        btn.addEventListener("mouseleave", up);
    }

    function bindTap(btn, fn){
        if (!btn) return;

        const act = (ev) => {
            if (gamePaused || gameEnded) return;
            ev.preventDefault();
            ev.stopPropagation();
            fn();
        };

        btn.addEventListener("touchstart", act, { passive: false });
        btn.addEventListener("click", act);
    }

    // ----- Mapear bot√µes -----
    const btnLeft  = document.getElementById("btnLeft");
    const btnRight = document.getElementById("btnRight");
    const btnCarry = document.getElementById("btnCarry");
    const btnAction= document.getElementById("btnAction");
    const btnJump  = document.getElementById("btnJump");

    bindHold(btnLeft, "left");
    bindHold(btnRight, "right");

    bindTap(btnCarry, () => attemptPickupOrDrop());
    bindTap(btnAction, () => attemptInteract());
    bindTap(btnJump, () => attemptJump());
})();


/* ===============================
   TOUCH UI VISIBILITY (menu vs game)
   =============================== */
(function(){
    const ui = document.getElementById('touchUI');
    const menu = document.getElementById('mainMenu');
    if (!ui || !menu) return;

    const sync = () => {
        const menuVisible = (menu.style.display !== 'none');
        ui.style.display = menuVisible ? 'none' : 'block';
    };

    sync();

    const obs = new MutationObserver(sync);
    obs.observe(menu, { attributes: true, attributeFilter: ['style'] });

    ['gameModeBtn','exploreModeBtn','missionTestStartBtn'].forEach(id => {
        const b = document.getElementById(id);
        if (b) b.addEventListener('click', () => setTimeout(sync, 0));
    });
})();

</script>

<!-- ===============================
     TOUCH UI (Bot√µes Mobile)
     =============================== -->
<div id="touchUI" aria-hidden="true">
    <div class="touchPadLeft">
        <div class="touchBtn" id="btnLeft">‚óÄ</div>
        <div class="touchBtn" id="btnRight">‚ñ∂</div>
    </div>
    <div class="touchPadRight">
        <div class="touchBtn smallText" id="btnCarry">Carregar/<br>soltar</div>
        <div class="touchBtn" id="btnAction">A√ß√£o</div>
        <div class="touchBtn" id="btnJump">Pular</div>
    </div>
</div>

</body>
</html>